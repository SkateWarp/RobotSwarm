Directory Structure:

└── ./
    ├── include
    │   ├── ColladaLoader.js
    │   ├── DDSLoader.js
    │   ├── MTLLoader.js
    │   ├── OBJLoader.js
    │   ├── OrbitControls.js
    │   ├── STLLoader.js
    │   └── TGALoader.js
    ├── src
    │   ├── Asset.ts
    │   ├── AssetViewer.ts
    │   ├── AudioTopic.ts
    │   ├── Color.ts
    │   ├── FuelServer.ts
    │   ├── Gamepad.ts
    │   ├── Globals.ts
    │   ├── GzObjLoader.ts
    │   ├── gzweb.js
    │   ├── Inertia.ts
    │   ├── Material.ts
    │   ├── ModelUserData.ts
    │   ├── PBRMaterial.ts
    │   ├── Pose.ts
    │   ├── Publisher.ts
    │   ├── Scene.ts
    │   ├── SceneManager.ts
    │   ├── SDFParser.ts
    │   ├── Shaders.js
    │   ├── SpawnModel.ts
    │   ├── Topic.ts
    │   ├── Transport.ts
    │   └── WsLoadingManager.ts
    ├── tests
    │   └── unit
    │       ├── SceneManger.test.ts
    │       └── Transport.test.ts
    ├── index.js
    ├── jest.config.ts
    ├── README.md
    ├── rollup.config.js
    └── tsconfig.json



---
File: /include/ColladaLoader.js
---

import {
	AmbientLight,
	AnimationClip,
	Bone,
	BufferGeometry,
	ClampToEdgeWrapping,
	Color,
	DirectionalLight,
	DoubleSide,
	Euler,
	FileLoader,
	Float32BufferAttribute,
	FrontSide,
	Group,
	Line,
	LineBasicMaterial,
	LineSegments,
	Loader,
	LoaderUtils,
	MathUtils,
	Matrix4,
	Mesh,
	MeshBasicMaterial,
	MeshLambertMaterial,
	MeshPhongMaterial,
	OrthographicCamera,
	PerspectiveCamera,
	PointLight,
	Quaternion,
	QuaternionKeyframeTrack,
	RepeatWrapping,
  RGBAFormat,
	Scene,
	Skeleton,
	SkinnedMesh,
	SpotLight,
	TextureLoader,
	Vector2,
	Vector3,
	VectorKeyframeTrack,
	LinearEncoding,
} from 'three';
import { TGALoader } from './TGALoader';

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Modified by German Mas:
 * - Restored the Up Axis rotation to its original state.
 * - Hardcode the up axis to always return Y_UP. This change was made in
 * previous versions of gzweb. Kept for backwards compatibility. If not used,
 * meshes that declare Z_UP have incorrect rotations, where we should have none.
 * The Y_UP prevents any further rotation from happening.
 * - getTexture had an sRGB encoding. Changed to Linear encoding to maintain the
 * behavior of previous versions.
 *
 * Diff of modification by Nate Koenig:
 *
diff --git a/include/ColladaLoader.js b/include/ColladaLoader.js
index cea5ac1..1980da1 100644
--- a/include/ColladaLoader.js
+++ b/include/ColladaLoader.js
@@ -29,6 +29,7 @@ import {
 	Quaternion,
 	QuaternionKeyframeTrack,
 	RepeatWrapping,
+  RGBAFormat,
 	Scene,
 	Skeleton,
 	SkinnedMesh,
@@ -1644,14 +1645,14 @@ class ColladaLoader extends Loader {

 					if ( loader !== undefined ) {

-						const texture = loader.load( image );
+						let texture;

 						// Check against the cache, if enabled.
 						if (scope.enableTexturesCache && scope.texturesCache.has(image)) {
 							texture = scope.texturesCache.get(image);
 							return texture;
 						} else {
-							savedPath = loader.path;
+							const savedPath = loader.path;
 							// Remove the path if the image has a full URL.
 							if (image.startsWith('https://')) {
 								loader.path = undefined;
@@ -1689,7 +1690,7 @@ class ColladaLoader extends Loader {
                       imageElem.src = isJPEG ? "data:image/jpg;base64,": "data:image/png;base64,";
                       imageElem.src += window.btoa(binary);

-                      scopeTexture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
+                      scopeTexture.format = isJPEG ? RGBFormat : RGBAFormat;
                       scopeTexture.needsUpdate = true;
                       scopeTexture.image = imageElem;
                     });
@@ -4216,9 +4217,9 @@ class ColladaLoader extends Loader {
 		const scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );
 		scene.animations = animations;

-		if ( asset.upAxis === 'Z_UP' ) {
+		if ( asset.upAxis === 'Y_UP' ) {

-			scene.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );
+			scene.quaternion.setFromEuler( new Euler( Math.PI / 2, 0, 0 ) );

 		}
 *
 *
 *
 * Modified by Nate Koenig :
 *
 *     Added a findResourceCb variable that is used by the texture loading
 *     in the `getTexture` function to fetch resources that were not
 *     accessible via standard URIs.
 *
 * Modified by German Mas:
 *
 * The Collada Loader caches the textures of meshes by default.
 * To disable:
 *   const loader = new THREE.ColladaLoader();
 *   loader.enableTexturesCache = false;
 *
 * Change the texture loader, if the requestHeader is present.
 * Texture Loaders use an Image Loader internally, instead of a File Loader.
 * Image Loader uses an img tag, and their src request doesn't accept custom headers.
 * See https://github.com/mrdoob/three.js/issues/10439
 *
 * Modified by Nate Koenig. Added the following to the 'parse' function:
 *
 * // A name or id could be a string enclosed by angle brackets like
 * // "<name>". A name like this will not be parsed correctly by the
 * // DOMParser, so we remove the angle brackets.
 * text = text.replace(/"\<(.*?)\>"/g, '"$1" ');
 * // Single quote version
 * text = text.replace(/'\<(.*?)\>'/g, '"$1" ');
 */
class ColladaLoader extends Loader {

	constructor( manager ) {

		super( manager );
	// Cache textures enabled by default.
  	this.enableTexturesCache = true;

	// The Map used to cache textures.
  	this.texturesCache = new Map();
	this.findResourceCb = undefined;
	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text, path ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( text, path ) {

		function getElementsByTagName( xml, name ) {

			// Non recursive xml.getElementsByTagName() ...

			const array = [];
			const childNodes = xml.childNodes;

			for ( let i = 0, l = childNodes.length; i < l; i ++ ) {

				const child = childNodes[ i ];

				if ( child.nodeName === name ) {

					array.push( child );

				}

			}

			return array;

		}

		function parseStrings( text ) {

			if ( text.length === 0 ) return [];

			const parts = text.trim().split( /\s+/ );
			const array = new Array( parts.length );

			for ( let i = 0, l = parts.length; i < l; i ++ ) {

				array[ i ] = parts[ i ];

			}

			return array;

		}

		function parseFloats( text ) {

			if ( text.length === 0 ) return [];

			const parts = text.trim().split( /\s+/ );
			const array = new Array( parts.length );

			for ( let i = 0, l = parts.length; i < l; i ++ ) {

				array[ i ] = parseFloat( parts[ i ] );

			}

			return array;

		}

		function parseInts( text ) {

			if ( text.length === 0 ) return [];

			const parts = text.trim().split( /\s+/ );
			const array = new Array( parts.length );

			for ( let i = 0, l = parts.length; i < l; i ++ ) {

				array[ i ] = parseInt( parts[ i ] );

			}

			return array;

		}

		function parseId( text ) {

			return text.substring( 1 );

		}

		function generateId() {

			return 'three_default_' + ( count ++ );

		}

		function isEmpty( object ) {

			return Object.keys( object ).length === 0;

		}

		// asset

		function parseAsset( xml ) {

			return {
				unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),
				upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )
			};

		}

		function parseAssetUnit( xml ) {

			if ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {

				return parseFloat( xml.getAttribute( 'meter' ) );

			} else {

				return 1; // default 1 meter

			}

		}

		function parseAssetUpAxis( xml ) {

			// Modified by German Mas.
			// Hardcode Y_UP in order to prevent unnecesary rotations on meshes.
			return 'Y_UP';

		}

		// library

		function parseLibrary( xml, libraryName, nodeName, parser ) {

			const library = getElementsByTagName( xml, libraryName )[ 0 ];

			if ( library !== undefined ) {

				const elements = getElementsByTagName( library, nodeName );

				for ( let i = 0; i < elements.length; i ++ ) {

					parser( elements[ i ] );

				}

			}

		}

		function buildLibrary( data, builder ) {

			for ( const name in data ) {

				const object = data[ name ];
				object.build = builder( data[ name ] );

			}

		}

		// get

		function getBuild( data, builder ) {

			if ( data.build !== undefined ) return data.build;

			data.build = builder( data );

			return data.build;

		}

		// animation

		function parseAnimation( xml ) {

			const data = {
				sources: {},
				samplers: {},
				channels: {}
			};

			let hasChildren = false;

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				let id;

				switch ( child.nodeName ) {

					case 'source':
						id = child.getAttribute( 'id' );
						data.sources[ id ] = parseSource( child );
						break;

					case 'sampler':
						id = child.getAttribute( 'id' );
						data.samplers[ id ] = parseAnimationSampler( child );
						break;

					case 'channel':
						id = child.getAttribute( 'target' );
						data.channels[ id ] = parseAnimationChannel( child );
						break;

					case 'animation':
						// hierarchy of related animations
						parseAnimation( child );
						hasChildren = true;
						break;

					default:
						console.log( child );

				}

			}

			if ( hasChildren === false ) {

				// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment

				library.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;

			}

		}

		function parseAnimationSampler( xml ) {

			const data = {
				inputs: {},
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'input':
						const id = parseId( child.getAttribute( 'source' ) );
						const semantic = child.getAttribute( 'semantic' );
						data.inputs[ semantic ] = id;
						break;

				}

			}

			return data;

		}

		function parseAnimationChannel( xml ) {

			const data = {};

			const target = xml.getAttribute( 'target' );

			// parsing SID Addressing Syntax

			let parts = target.split( '/' );

			const id = parts.shift();
			let sid = parts.shift();

			// check selection syntax

			const arraySyntax = ( sid.indexOf( '(' ) !== - 1 );
			const memberSyntax = ( sid.indexOf( '.' ) !== - 1 );

			if ( memberSyntax ) {

				//  member selection access

				parts = sid.split( '.' );
				sid = parts.shift();
				data.member = parts.shift();

			} else if ( arraySyntax ) {

				// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.

				const indices = sid.split( '(' );
				sid = indices.shift();

				for ( let i = 0; i < indices.length; i ++ ) {

					indices[ i ] = parseInt( indices[ i ].replace( /\)/, '' ) );

				}

				data.indices = indices;

			}

			data.id = id;
			data.sid = sid;

			data.arraySyntax = arraySyntax;
			data.memberSyntax = memberSyntax;

			data.sampler = parseId( xml.getAttribute( 'source' ) );

			return data;

		}

		function buildAnimation( data ) {

			const tracks = [];

			const channels = data.channels;
			const samplers = data.samplers;
			const sources = data.sources;

			for ( const target in channels ) {

				if ( channels.hasOwnProperty( target ) ) {

					const channel = channels[ target ];
					const sampler = samplers[ channel.sampler ];

					const inputId = sampler.inputs.INPUT;
					const outputId = sampler.inputs.OUTPUT;

					const inputSource = sources[ inputId ];
					const outputSource = sources[ outputId ];

					const animation = buildAnimationChannel( channel, inputSource, outputSource );

					createKeyframeTracks( animation, tracks );

				}

			}

			return tracks;

		}

		function getAnimation( id ) {

			return getBuild( library.animations[ id ], buildAnimation );

		}

		function buildAnimationChannel( channel, inputSource, outputSource ) {

			const node = library.nodes[ channel.id ];
			const object3D = getNode( node.id );

			const transform = node.transforms[ channel.sid ];
			const defaultMatrix = node.matrix.clone().transpose();

			let time, stride;
			let i, il, j, jl;

			const data = {};

			// the collada spec allows the animation of data in various ways.
			// depending on the transform type (matrix, translate, rotate, scale), we execute different logic

			switch ( transform ) {

				case 'matrix':

					for ( i = 0, il = inputSource.array.length; i < il; i ++ ) {

						time = inputSource.array[ i ];
						stride = i * outputSource.stride;

						if ( data[ time ] === undefined ) data[ time ] = {};

						if ( channel.arraySyntax === true ) {

							const value = outputSource.array[ stride ];
							const index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];

							data[ time ][ index ] = value;

						} else {

							for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {

								data[ time ][ j ] = outputSource.array[ stride + j ];

							}

						}

					}

					break;

				case 'translate':
					console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
					break;

				case 'rotate':
					console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
					break;

				case 'scale':
					console.warn( 'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
					break;

			}

			const keyframes = prepareAnimationData( data, defaultMatrix );

			const animation = {
				name: object3D.uuid,
				keyframes: keyframes
			};

			return animation;

		}

		function prepareAnimationData( data, defaultMatrix ) {

			const keyframes = [];

			// transfer data into a sortable array

			for ( const time in data ) {

				keyframes.push( { time: parseFloat( time ), value: data[ time ] } );

			}

			// ensure keyframes are sorted by time

			keyframes.sort( ascending );

			// now we clean up all animation data, so we can use them for keyframe tracks

			for ( let i = 0; i < 16; i ++ ) {

				transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );

			}

			return keyframes;

			// array sort function

			function ascending( a, b ) {

				return a.time - b.time;

			}

		}

		const position = new Vector3();
		const scale = new Vector3();
		const quaternion = new Quaternion();

		function createKeyframeTracks( animation, tracks ) {

			const keyframes = animation.keyframes;
			const name = animation.name;

			const times = [];
			const positionData = [];
			const quaternionData = [];
			const scaleData = [];

			for ( let i = 0, l = keyframes.length; i < l; i ++ ) {

				const keyframe = keyframes[ i ];

				const time = keyframe.time;
				const value = keyframe.value;

				matrix.fromArray( value ).transpose();
				matrix.decompose( position, quaternion, scale );

				times.push( time );
				positionData.push( position.x, position.y, position.z );
				quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );
				scaleData.push( scale.x, scale.y, scale.z );

			}

			if ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );
			if ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );
			if ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );

			return tracks;

		}

		function transformAnimationData( keyframes, property, defaultValue ) {

			let keyframe;

			let empty = true;
			let i, l;

			// check, if values of a property are missing in our keyframes

			for ( i = 0, l = keyframes.length; i < l; i ++ ) {

				keyframe = keyframes[ i ];

				if ( keyframe.value[ property ] === undefined ) {

					keyframe.value[ property ] = null; // mark as missing

				} else {

					empty = false;

				}

			}

			if ( empty === true ) {

				// no values at all, so we set a default value

				for ( i = 0, l = keyframes.length; i < l; i ++ ) {

					keyframe = keyframes[ i ];

					keyframe.value[ property ] = defaultValue;

				}

			} else {

				// filling gaps

				createMissingKeyframes( keyframes, property );

			}

		}

		function createMissingKeyframes( keyframes, property ) {

			let prev, next;

			for ( let i = 0, l = keyframes.length; i < l; i ++ ) {

				const keyframe = keyframes[ i ];

				if ( keyframe.value[ property ] === null ) {

					prev = getPrev( keyframes, i, property );
					next = getNext( keyframes, i, property );

					if ( prev === null ) {

						keyframe.value[ property ] = next.value[ property ];
						continue;

					}

					if ( next === null ) {

						keyframe.value[ property ] = prev.value[ property ];
						continue;

					}

					interpolate( keyframe, prev, next, property );

				}

			}

		}

		function getPrev( keyframes, i, property ) {

			while ( i >= 0 ) {

				const keyframe = keyframes[ i ];

				if ( keyframe.value[ property ] !== null ) return keyframe;

				i --;

			}

			return null;

		}

		function getNext( keyframes, i, property ) {

			while ( i < keyframes.length ) {

				const keyframe = keyframes[ i ];

				if ( keyframe.value[ property ] !== null ) return keyframe;

				i ++;

			}

			return null;

		}

		function interpolate( key, prev, next, property ) {

			if ( ( next.time - prev.time ) === 0 ) {

				key.value[ property ] = prev.value[ property ];
				return;

			}

			key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];

		}

		// animation clips

		function parseAnimationClip( xml ) {

			const data = {
				name: xml.getAttribute( 'id' ) || 'default',
				start: parseFloat( xml.getAttribute( 'start' ) || 0 ),
				end: parseFloat( xml.getAttribute( 'end' ) || 0 ),
				animations: []
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'instance_animation':
						data.animations.push( parseId( child.getAttribute( 'url' ) ) );
						break;

				}

			}

			library.clips[ xml.getAttribute( 'id' ) ] = data;

		}

		function buildAnimationClip( data ) {

			const tracks = [];

			const name = data.name;
			const duration = ( data.end - data.start ) || - 1;
			const animations = data.animations;

			for ( let i = 0, il = animations.length; i < il; i ++ ) {

				const animationTracks = getAnimation( animations[ i ] );

				for ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {

					tracks.push( animationTracks[ j ] );

				}

			}

			return new AnimationClip( name, duration, tracks );

		}

		function getAnimationClip( id ) {

			return getBuild( library.clips[ id ], buildAnimationClip );

		}

		// controller

		function parseController( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'skin':
						// there is exactly one skin per controller
						data.id = parseId( child.getAttribute( 'source' ) );
						data.skin = parseSkin( child );
						break;

					case 'morph':
						data.id = parseId( child.getAttribute( 'source' ) );
						console.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );
						break;

				}

			}

			library.controllers[ xml.getAttribute( 'id' ) ] = data;

		}

		function parseSkin( xml ) {

			const data = {
				sources: {}
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'bind_shape_matrix':
						data.bindShapeMatrix = parseFloats( child.textContent );
						break;

					case 'source':
						const id = child.getAttribute( 'id' );
						data.sources[ id ] = parseSource( child );
						break;

					case 'joints':
						data.joints = parseJoints( child );
						break;

					case 'vertex_weights':
						data.vertexWeights = parseVertexWeights( child );
						break;

				}

			}

			return data;

		}

		function parseJoints( xml ) {

			const data = {
				inputs: {}
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'input':
						const semantic = child.getAttribute( 'semantic' );
						const id = parseId( child.getAttribute( 'source' ) );
						data.inputs[ semantic ] = id;
						break;

				}

			}

			return data;

		}

		function parseVertexWeights( xml ) {

			const data = {
				inputs: {}
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'input':
						const semantic = child.getAttribute( 'semantic' );
						const id = parseId( child.getAttribute( 'source' ) );
						const offset = parseInt( child.getAttribute( 'offset' ) );
						data.inputs[ semantic ] = { id: id, offset: offset };
						break;

					case 'vcount':
						data.vcount = parseInts( child.textContent );
						break;

					case 'v':
						data.v = parseInts( child.textContent );
						break;

				}

			}

			return data;

		}

		function buildController( data ) {

			const build = {
				id: data.id
			};

			const geometry = library.geometries[ build.id ];

			if ( data.skin !== undefined ) {

				build.skin = buildSkin( data.skin );

				// we enhance the 'sources' property of the corresponding geometry with our skin data

				geometry.sources.skinIndices = build.skin.indices;
				geometry.sources.skinWeights = build.skin.weights;

			}

			return build;

		}

		function buildSkin( data ) {

			const BONE_LIMIT = 4;

			const build = {
				joints: [], // this must be an array to preserve the joint order
				indices: {
					array: [],
					stride: BONE_LIMIT
				},
				weights: {
					array: [],
					stride: BONE_LIMIT
				}
			};

			const sources = data.sources;
			const vertexWeights = data.vertexWeights;

			const vcount = vertexWeights.vcount;
			const v = vertexWeights.v;
			const jointOffset = vertexWeights.inputs.JOINT.offset;
			const weightOffset = vertexWeights.inputs.WEIGHT.offset;

			const jointSource = data.sources[ data.joints.inputs.JOINT ];
			const inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];

			const weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;
			let stride = 0;

			let i, j, l;

			// procces skin data for each vertex

			for ( i = 0, l = vcount.length; i < l; i ++ ) {

				const jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex
				const vertexSkinData = [];

				for ( j = 0; j < jointCount; j ++ ) {

					const skinIndex = v[ stride + jointOffset ];
					const weightId = v[ stride + weightOffset ];
					const skinWeight = weights[ weightId ];

					vertexSkinData.push( { index: skinIndex, weight: skinWeight } );

					stride += 2;

				}

				// we sort the joints in descending order based on the weights.
				// this ensures, we only procced the most important joints of the vertex

				vertexSkinData.sort( descending );

				// now we provide for each vertex a set of four index and weight values.
				// the order of the skin data matches the order of vertices

				for ( j = 0; j < BONE_LIMIT; j ++ ) {

					const d = vertexSkinData[ j ];

					if ( d !== undefined ) {

						build.indices.array.push( d.index );
						build.weights.array.push( d.weight );

					} else {

						build.indices.array.push( 0 );
						build.weights.array.push( 0 );

					}

				}

			}

			// setup bind matrix

			if ( data.bindShapeMatrix ) {

				build.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();

			} else {

				build.bindMatrix = new Matrix4().identity();

			}

			// process bones and inverse bind matrix data

			for ( i = 0, l = jointSource.array.length; i < l; i ++ ) {

				const name = jointSource.array[ i ];
				const boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();

				build.joints.push( { name: name, boneInverse: boneInverse } );

			}

			return build;

			// array sort function

			function descending( a, b ) {

				return b.weight - a.weight;

			}

		}

		function getController( id ) {

			return getBuild( library.controllers[ id ], buildController );

		}

		// image

		function parseImage( xml ) {

			const data = {
				init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent
			};

			library.images[ xml.getAttribute( 'id' ) ] = data;

		}

		function buildImage( data ) {

			if ( data.build !== undefined ) return data.build;

			return data.init_from;

		}

		function getImage( id ) {

			const data = library.images[ id ];

			if ( data !== undefined ) {

				return getBuild( data, buildImage );

			}

			console.warn( 'THREE.ColladaLoader: Couldn\'t find image with ID:', id );

			return null;

		}

		// effect

		function parseEffect( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'profile_COMMON':
						data.profile = parseEffectProfileCOMMON( child );
						break;

				}

			}

			library.effects[ xml.getAttribute( 'id' ) ] = data;

		}

		function parseEffectProfileCOMMON( xml ) {

			const data = {
				surfaces: {},
				samplers: {}
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'newparam':
						parseEffectNewparam( child, data );
						break;

					case 'technique':
						data.technique = parseEffectTechnique( child );
						break;

					case 'extra':
						data.extra = parseEffectExtra( child );
						break;

				}

			}

			return data;

		}

		function parseEffectNewparam( xml, data ) {

			const sid = xml.getAttribute( 'sid' );

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'surface':
						data.surfaces[ sid ] = parseEffectSurface( child );
						break;

					case 'sampler2D':
						data.samplers[ sid ] = parseEffectSampler( child );
						break;

				}

			}

		}

		function parseEffectSurface( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'init_from':
						data.init_from = child.textContent;
						break;

				}

			}

			return data;

		}

		function parseEffectSampler( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'source':
						data.source = child.textContent;
						break;

				}

			}

			return data;

		}

		function parseEffectTechnique( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'constant':
					case 'lambert':
					case 'blinn':
					case 'phong':
						data.type = child.nodeName;
						data.parameters = parseEffectParameters( child );
						break;

					case 'extra':
						data.extra = parseEffectExtra( child );
						break;

				}

			}

			return data;

		}

		function parseEffectParameters( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'emission':
					case 'diffuse':
					case 'specular':
					case 'bump':
					case 'ambient':
					case 'shininess':
					case 'transparency':
						data[ child.nodeName ] = parseEffectParameter( child );
						break;
					case 'transparent':
						data[ child.nodeName ] = {
							opaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',
							data: parseEffectParameter( child )
						};
						break;

				}

			}

			return data;

		}

		function parseEffectParameter( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'color':
						data[ child.nodeName ] = parseFloats( child.textContent );
						break;

					case 'float':
						data[ child.nodeName ] = parseFloat( child.textContent );
						break;

					case 'texture':
						data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };
						break;

				}

			}

			return data;

		}

		function parseEffectParameterTexture( xml ) {

			const data = {
				technique: {}
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'extra':
						parseEffectParameterTextureExtra( child, data );
						break;

				}

			}

			return data;

		}

		function parseEffectParameterTextureExtra( xml, data ) {

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'technique':
						parseEffectParameterTextureExtraTechnique( child, data );
						break;

				}

			}

		}

		function parseEffectParameterTextureExtraTechnique( xml, data ) {

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'repeatU':
					case 'repeatV':
					case 'offsetU':
					case 'offsetV':
						data.technique[ child.nodeName ] = parseFloat( child.textContent );
						break;

					case 'wrapU':
					case 'wrapV':

						// some files have values for wrapU/wrapV which become NaN via parseInt

						if ( child.textContent.toUpperCase() === 'TRUE' ) {

							data.technique[ child.nodeName ] = 1;

						} else if ( child.textContent.toUpperCase() === 'FALSE' ) {

							data.technique[ child.nodeName ] = 0;

						} else {

							data.technique[ child.nodeName ] = parseInt( child.textContent );

						}

						break;

					case 'bump':
						data[ child.nodeName ] = parseEffectExtraTechniqueBump( child );
						break;

				}

			}

		}

		function parseEffectExtra( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'technique':
						data.technique = parseEffectExtraTechnique( child );
						break;

				}

			}

			return data;

		}

		function parseEffectExtraTechnique( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'double_sided':
						data[ child.nodeName ] = parseInt( child.textContent );
						break;

					case 'bump':
						data[ child.nodeName ] = parseEffectExtraTechniqueBump( child );
						break;

				}

			}

			return data;

		}

		function parseEffectExtraTechniqueBump( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'texture':
						data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };
						break;

				}

			}

			return data;

		}

		function buildEffect( data ) {

			return data;

		}

		function getEffect( id ) {

			return getBuild( library.effects[ id ], buildEffect );

		}

		// material

		function parseMaterial( xml ) {

			const data = {
				name: xml.getAttribute( 'name' )
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'instance_effect':
						data.url = parseId( child.getAttribute( 'url' ) );
						break;

				}

			}

			library.materials[ xml.getAttribute( 'id' ) ] = data;

		}

		function getTextureLoader( image ) {

			let loader;

			let extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/
			extension = extension.toLowerCase();

			switch ( extension ) {

				case 'tga':
					loader = tgaLoader;
					break;

				default:
					loader = textureLoader;

			}

			return loader;

		}

		function buildMaterial( data ) {

			const effect = getEffect( data.url );
			const technique = effect.profile.technique;

			let material;

			switch ( technique.type ) {

				case 'phong':
				case 'blinn':
					material = new MeshPhongMaterial();
					break;

				case 'lambert':
					material = new MeshLambertMaterial();
					break;

				default:
					material = new MeshBasicMaterial();
					break;

			}

			material.name = data.name || '';

			function getTexture( textureObject, encoding = null ) {

				const sampler = effect.profile.samplers[ textureObject.id ];
				let image = null;

				// get image

				if ( sampler !== undefined ) {

					const surface = effect.profile.surfaces[ sampler.source ];
					image = getImage( surface.init_from );

				} else {

					console.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );
					image = getImage( textureObject.id );

				}

				// create texture if image is avaiable

				if ( image !== null ) {

					const loader = getTextureLoader( image );

					if ( loader !== undefined ) {

						let texture;

						// Check against the cache, if enabled.
						if (scope.enableTexturesCache && scope.texturesCache.has(image)) {
							texture = scope.texturesCache.get(image);
							return texture;
						} else {
							const savedPath = loader.path;
							// Remove the path if the image has a full URL.
							if (image.startsWith('https://')) {
								loader.path = undefined;
							}

							texture = loader.load(image,
                // onLoad
                undefined,
                // onProgress
                undefined,
                // onError
                function(error) {
                  if (scope.findResourceCb) {
                    // Create the filename to look up.
                    var filename = [path.substring(0, path.lastIndexOf("/")),
                      image].join("/");

                    // Store the texture pointer
                    var scopeTexture = texture;

                    // Get the image using the find resource callback.
                    scope.findResourceCb(filename, (imageBytes, error) => {
                      const item = `${savedPath}${image}`;
                      if (error !== undefined) {
                        // Mark the texture as error in the loading manager.
                        loader.manager.markAsError(item);
                        return;
                      }
                      // Create the image element
                      var imageElem = document.createElementNS(
                        'http://www.w3.org/1999/xhtml', 'img');

                      var isJPEG = filename.search( /\.jpe?g($|\?)/i ) > 0 || filename.search( /^data\:image\/jpeg/ ) === 0;

                      var binary = '';
                      var len = imageBytes.byteLength;
                      for (var i = 0; i < len; i++) {
                        binary += String.fromCharCode( imageBytes[ i ] );
                      }
                      // Set the image source using base64 encoding
                      imageElem.src = isJPEG ? "data:image/jpg;base64,": "data:image/png;base64,";
                      imageElem.src += window.btoa(binary);

                      scopeTexture.format = isJPEG ? RGBFormat : RGBAFormat;
                      scopeTexture.needsUpdate = true;
                      scopeTexture.image = imageElem;

                      // Mark the texture as done in the loading manager.
                      loader.manager.markAsDone(item);
                    });
                  }
                });

							// Restore the path.
							loader.path = savedPath;
						}

						const extra = textureObject.extra;

						if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {

							const technique = extra.technique;

							texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;
							texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;

							texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );
							texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );

						} else {

							texture.wrapS = RepeatWrapping;
							texture.wrapT = RepeatWrapping;

						}

						if ( encoding !== null ) {

							texture.encoding = encoding;

						}

						// Add the texture to the Cache map, if enabled.
						if (scope.enableTexturesCache) {
							scope.texturesCache.set(image, texture);
						}

						return texture;

					} else {

						console.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );

						return null;

					}

				} else {

					console.warn( 'THREE.ColladaLoader: Couldn\'t create texture with ID:', textureObject.id );

					return null;

				}

			}

			const parameters = technique.parameters;

			for ( const key in parameters ) {

				const parameter = parameters[ key ];

				switch ( key ) {

					case 'diffuse':
						if ( parameter.color ) material.color.fromArray( parameter.color );
						if ( parameter.texture ) material.map = getTexture( parameter.texture, LinearEncoding );
						break;
					case 'specular':
						if ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );
						if ( parameter.texture ) material.specularMap = getTexture( parameter.texture );
						break;
					case 'bump':
						if ( parameter.texture ) material.normalMap = getTexture( parameter.texture );
						break;
					case 'ambient':
						if ( parameter.texture ) material.lightMap = getTexture( parameter.texture, LinearEncoding );
						break;
					case 'shininess':
						if ( parameter.float && material.shininess ) material.shininess = parameter.float;
						break;
					case 'emission':
						if ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );
						if ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, LinearEncoding );
						break;

				}

			}

			// Modified by German Mas.
			// getTexture already uses Linear encoding. No need to convert.
			// material.color.convertSRGBToLinear();
			// if ( material.specular ) material.specular.convertSRGBToLinear();
			// if ( material.emissive ) material.emissive.convertSRGBToLinear();

			//

			let transparent = parameters[ 'transparent' ];
			let transparency = parameters[ 'transparency' ];

			// <transparency> does not exist but <transparent>

			if ( transparency === undefined && transparent ) {

				transparency = {
					float: 1
				};

			}

			// <transparent> does not exist but <transparency>

			if ( transparent === undefined && transparency ) {

				transparent = {
					opaque: 'A_ONE',
					data: {
						color: [ 1, 1, 1, 1 ]
					} };

			}

			if ( transparent && transparency ) {

				// handle case if a texture exists but no color

				if ( transparent.data.texture ) {

					// we do not set an alpha map (see #13792)

					material.transparent = true;

				} else {

					const color = transparent.data.color;

					switch ( transparent.opaque ) {

						case 'A_ONE':
							material.opacity = color[ 3 ] * transparency.float;
							break;
						case 'RGB_ZERO':
							material.opacity = 1 - ( color[ 0 ] * transparency.float );
							break;
						case 'A_ZERO':
							material.opacity = 1 - ( color[ 3 ] * transparency.float );
							break;
						case 'RGB_ONE':
							material.opacity = color[ 0 ] * transparency.float;
							break;
						default:
							console.warn( 'THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque );

					}

					if ( material.opacity < 1 ) material.transparent = true;

				}

			}

			//


			if ( technique.extra !== undefined && technique.extra.technique !== undefined ) {

				const techniques = technique.extra.technique;

				for ( const k in techniques ) {

					const v = techniques[ k ];

					switch ( k ) {

						case 'double_sided':
							material.side = ( v === 1 ? DoubleSide : FrontSide );
							break;

						case 'bump':
							material.normalMap = getTexture( v.texture );
							material.normalScale = new Vector2( 1, 1 );
							break;

					}

				}

			}

			return material;

		}

		function getMaterial( id ) {

			return getBuild( library.materials[ id ], buildMaterial );

		}

		// camera

		function parseCamera( xml ) {

			const data = {
				name: xml.getAttribute( 'name' )
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'optics':
						data.optics = parseCameraOptics( child );
						break;

				}

			}

			library.cameras[ xml.getAttribute( 'id' ) ] = data;

		}

		function parseCameraOptics( xml ) {

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				switch ( child.nodeName ) {

					case 'technique_common':
						return parseCameraTechnique( child );

				}

			}

			return {};

		}

		function parseCameraTechnique( xml ) {

			const data = {};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				switch ( child.nodeName ) {

					case 'perspective':
					case 'orthographic':

						data.technique = child.nodeName;
						data.parameters = parseCameraParameters( child );

						break;

				}

			}

			return data;

		}

		function parseCameraParameters( xml ) {

			const data = {};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				switch ( child.nodeName ) {

					case 'xfov':
					case 'yfov':
					case 'xmag':
					case 'ymag':
					case 'znear':
					case 'zfar':
					case 'aspect_ratio':
						data[ child.nodeName ] = parseFloat( child.textContent );
						break;

				}

			}

			return data;

		}

		function buildCamera( data ) {

			let camera;

			switch ( data.optics.technique ) {

				case 'perspective':
					camera = new PerspectiveCamera(
						data.optics.parameters.yfov,
						data.optics.parameters.aspect_ratio,
						data.optics.parameters.znear,
						data.optics.parameters.zfar
					);
					break;

				case 'orthographic':
					let ymag = data.optics.parameters.ymag;
					let xmag = data.optics.parameters.xmag;
					const aspectRatio = data.optics.parameters.aspect_ratio;

					xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;
					ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;

					xmag *= 0.5;
					ymag *= 0.5;

					camera = new OrthographicCamera(
						- xmag, xmag, ymag, - ymag, // left, right, top, bottom
						data.optics.parameters.znear,
						data.optics.parameters.zfar
					);
					break;

				default:
					camera = new PerspectiveCamera();
					break;

			}

			camera.name = data.name || '';

			return camera;

		}

		function getCamera( id ) {

			const data = library.cameras[ id ];

			if ( data !== undefined ) {

				return getBuild( data, buildCamera );

			}

			console.warn( 'THREE.ColladaLoader: Couldn\'t find camera with ID:', id );

			return null;

		}

		// light

		function parseLight( xml ) {

			let data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'technique_common':
						data = parseLightTechnique( child );
						break;

				}

			}

			library.lights[ xml.getAttribute( 'id' ) ] = data;

		}

		function parseLightTechnique( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'directional':
					case 'point':
					case 'spot':
					case 'ambient':

						data.technique = child.nodeName;
						data.parameters = parseLightParameters( child );

				}

			}

			return data;

		}

		function parseLightParameters( xml ) {

			const data = {};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'color':
						const array = parseFloats( child.textContent );
						data.color = new Color().fromArray( array ).convertSRGBToLinear();
						break;

					case 'falloff_angle':
						data.falloffAngle = parseFloat( child.textContent );
						break;

					case 'quadratic_attenuation':
						const f = parseFloat( child.textContent );
						data.distance = f ? Math.sqrt( 1 / f ) : 0;
						break;

				}

			}

			return data;

		}

		function buildLight( data ) {

			let light;

			switch ( data.technique ) {

				case 'directional':
					light = new DirectionalLight();
					break;

				case 'point':
					light = new PointLight();
					break;

				case 'spot':
					light = new SpotLight();
					break;

				case 'ambient':
					light = new AmbientLight();
					break;

			}

			if ( data.parameters.color ) light.color.copy( data.parameters.color );
			if ( data.parameters.distance ) light.distance = data.parameters.distance;

			return light;

		}

		function getLight( id ) {

			const data = library.lights[ id ];

			if ( data !== undefined ) {

				return getBuild( data, buildLight );

			}

			console.warn( 'THREE.ColladaLoader: Couldn\'t find light with ID:', id );

			return null;

		}

		// geometry

		function parseGeometry( xml ) {

			const data = {
				name: xml.getAttribute( 'name' ),
				sources: {},
				vertices: {},
				primitives: []
			};

			const mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];

			// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep
			if ( mesh === undefined ) return;

			for ( let i = 0; i < mesh.childNodes.length; i ++ ) {

				const child = mesh.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				const id = child.getAttribute( 'id' );

				switch ( child.nodeName ) {

					case 'source':
						data.sources[ id ] = parseSource( child );
						break;

					case 'vertices':
						// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];
						data.vertices = parseGeometryVertices( child );
						break;

					case 'polygons':
						console.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );
						break;

					case 'lines':
					case 'linestrips':
					case 'polylist':
					case 'triangles':
						data.primitives.push( parseGeometryPrimitive( child ) );
						break;

					default:
						console.log( child );

				}

			}

			library.geometries[ xml.getAttribute( 'id' ) ] = data;

		}

		function parseSource( xml ) {

			const data = {
				array: [],
				stride: 3
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'float_array':
						data.array = parseFloats( child.textContent );
						break;

					case 'Name_array':
						data.array = parseStrings( child.textContent );
						break;

					case 'technique_common':
						const accessor = getElementsByTagName( child, 'accessor' )[ 0 ];

						if ( accessor !== undefined ) {

							data.stride = parseInt( accessor.getAttribute( 'stride' ) );

						}

						break;

				}

			}

			return data;

		}

		function parseGeometryVertices( xml ) {

			const data = {};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );

			}

			return data;

		}

		function parseGeometryPrimitive( xml ) {

			const primitive = {
				type: xml.nodeName,
				material: xml.getAttribute( 'material' ),
				count: parseInt( xml.getAttribute( 'count' ) ),
				inputs: {},
				stride: 0,
				hasUV: false
			};

			for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'input':
						const id = parseId( child.getAttribute( 'source' ) );
						const semantic = child.getAttribute( 'semantic' );
						const offset = parseInt( child.getAttribute( 'offset' ) );
						const set = parseInt( child.getAttribute( 'set' ) );
						const inputname = ( set > 0 ? semantic + set : semantic );
						primitive.inputs[ inputname ] = { id: id, offset: offset };
						primitive.stride = Math.max( primitive.stride, offset + 1 );
						if ( semantic === 'TEXCOORD' ) primitive.hasUV = true;
						break;

					case 'vcount':
						primitive.vcount = parseInts( child.textContent );
						break;

					case 'p':
						primitive.p = parseInts( child.textContent );
						break;

				}

			}

			return primitive;

		}

		function groupPrimitives( primitives ) {

			const build = {};

			for ( let i = 0; i < primitives.length; i ++ ) {

				const primitive = primitives[ i ];

				if ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];

				build[ primitive.type ].push( primitive );

			}

			return build;

		}

		function checkUVCoordinates( primitives ) {

			let count = 0;

			for ( let i = 0, l = primitives.length; i < l; i ++ ) {

				const primitive = primitives[ i ];

				if ( primitive.hasUV === true ) {

					count ++;

				}

			}

			if ( count > 0 && count < primitives.length ) {

				primitives.uvsNeedsFix = true;

			}

		}

		function buildGeometry( data ) {

			const build = {};

			const sources = data.sources;
			const vertices = data.vertices;
			const primitives = data.primitives;

			if ( primitives.length === 0 ) return {};

			// our goal is to create one buffer geometry for a single type of primitives
			// first, we group all primitives by their type

			const groupedPrimitives = groupPrimitives( primitives );

			for ( const type in groupedPrimitives ) {

				const primitiveType = groupedPrimitives[ type ];

				// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)

				checkUVCoordinates( primitiveType );

				// third, create a buffer geometry for each type of primitives

				build[ type ] = buildGeometryType( primitiveType, sources, vertices );

			}

			return build;

		}

		function buildGeometryType( primitives, sources, vertices ) {

			const build = {};

			const position = { array: [], stride: 0 };
			const normal = { array: [], stride: 0 };
			const uv = { array: [], stride: 0 };
			const uv2 = { array: [], stride: 0 };
			const color = { array: [], stride: 0 };

			const skinIndex = { array: [], stride: 4 };
			const skinWeight = { array: [], stride: 4 };

			const geometry = new BufferGeometry();

			const materialKeys = [];

			let start = 0;

			for ( let p = 0; p < primitives.length; p ++ ) {

				const primitive = primitives[ p ];
				const inputs = primitive.inputs;

				// groups

				let count = 0;

				switch ( primitive.type ) {

					case 'lines':
					case 'linestrips':
						count = primitive.count * 2;
						break;

					case 'triangles':
						count = primitive.count * 3;
						break;

					case 'polylist':

						for ( let g = 0; g < primitive.count; g ++ ) {

							const vc = primitive.vcount[ g ];

							switch ( vc ) {

								case 3:
									count += 3; // single triangle
									break;

								case 4:
									count += 6; // quad, subdivided into two triangles
									break;

								default:
									count += ( vc - 2 ) * 3; // polylist with more than four vertices
									break;

							}

						}

						break;

					default:
						console.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );

				}

				geometry.addGroup( start, count, p );
				start += count;

				// material

				if ( primitive.material ) {

					materialKeys.push( primitive.material );

				}

				// geometry data

				for ( const name in inputs ) {

					const input = inputs[ name ];

					switch ( name )	{

						case 'VERTEX':
							for ( const key in vertices ) {

								const id = vertices[ key ];

								switch ( key ) {

									case 'POSITION':
										const prevLength = position.array.length;
										buildGeometryData( primitive, sources[ id ], input.offset, position.array );
										position.stride = sources[ id ].stride;

										if ( sources.skinWeights && sources.skinIndices ) {

											buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );
											buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );

										}

										// see #3803

										if ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {

											const count = ( position.array.length - prevLength ) / position.stride;

											for ( let i = 0; i < count; i ++ ) {

												// fill missing uv coordinates

												uv.array.push( 0, 0 );

											}

										}

										break;

									case 'NORMAL':
										buildGeometryData( primitive, sources[ id ], input.offset, normal.array );
										normal.stride = sources[ id ].stride;
										break;

									case 'COLOR':
										buildGeometryData( primitive, sources[ id ], input.offset, color.array );
										color.stride = sources[ id ].stride;
										break;

									case 'TEXCOORD':
										buildGeometryData( primitive, sources[ id ], input.offset, uv.array );
										uv.stride = sources[ id ].stride;
										break;

									case 'TEXCOORD1':
										buildGeometryData( primitive, sources[ id ], input.offset, uv2.array );
										uv.stride = sources[ id ].stride;
										break;

									default:
										console.warn( 'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key );

								}

							}

							break;

						case 'NORMAL':
							buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );
							normal.stride = sources[ input.id ].stride;
							break;

						case 'COLOR':
							buildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true );
							color.stride = sources[ input.id ].stride;
							break;

						case 'TEXCOORD':
							buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );
							uv.stride = sources[ input.id ].stride;
							break;

						case 'TEXCOORD1':
							buildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );
							uv2.stride = sources[ input.id ].stride;
							break;

					}

				}

			}

			// build geometry

			if ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );
			if ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );
			if ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );
			if ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );
			if ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new Float32BufferAttribute( uv2.array, uv2.stride ) );

			if ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );
			if ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );

			build.data = geometry;
			build.type = primitives[ 0 ].type;
			build.materialKeys = materialKeys;

			return build;

		}

		function buildGeometryData( primitive, source, offset, array, isColor = false ) {

			const indices = primitive.p;
			const stride = primitive.stride;
			const vcount = primitive.vcount;

			function pushVector( i ) {

				let index = indices[ i + offset ] * sourceStride;
				const length = index + sourceStride;

				for ( ; index < length; index ++ ) {

					array.push( sourceArray[ index ] );

				}

				if ( isColor ) {

					// convert the vertex colors from srgb to linear if present
					const startIndex = array.length - sourceStride - 1;
					tempColor.setRGB(
						array[ startIndex + 0 ],
						array[ startIndex + 1 ],
						array[ startIndex + 2 ]
					).convertSRGBToLinear();

					array[ startIndex + 0 ] = tempColor.r;
					array[ startIndex + 1 ] = tempColor.g;
					array[ startIndex + 2 ] = tempColor.b;

				}

			}

			const sourceArray = source.array;
			const sourceStride = source.stride;

			if ( primitive.vcount !== undefined ) {

				let index = 0;

				for ( let i = 0, l = vcount.length; i < l; i ++ ) {

					const count = vcount[ i ];

					if ( count === 4 ) {

						const a = index + stride * 0;
						const b = index + stride * 1;
						const c = index + stride * 2;
						const d = index + stride * 3;

						pushVector( a ); pushVector( b ); pushVector( d );
						pushVector( b ); pushVector( c ); pushVector( d );

					} else if ( count === 3 ) {

						const a = index + stride * 0;
						const b = index + stride * 1;
						const c = index + stride * 2;

						pushVector( a ); pushVector( b ); pushVector( c );

					} else if ( count > 4 ) {

						for ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {

							const a = index + stride * 0;
							const b = index + stride * k;
							const c = index + stride * ( k + 1 );

							pushVector( a ); pushVector( b ); pushVector( c );

						}

					}

					index += stride * count;

				}

			} else {

				for ( let i = 0, l = indices.length; i < l; i += stride ) {

					pushVector( i );

				}

			}

		}

		function getGeometry( id ) {

			return getBuild( library.geometries[ id ], buildGeometry );

		}

		// kinematics

		function parseKinematicsModel( xml ) {

			const data = {
				name: xml.getAttribute( 'name' ) || '',
				joints: {},
				links: []
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'technique_common':
						parseKinematicsTechniqueCommon( child, data );
						break;

				}

			}

			library.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;

		}

		function buildKinematicsModel( data ) {

			if ( data.build !== undefined ) return data.build;

			return data;

		}

		function getKinematicsModel( id ) {

			return getBuild( library.kinematicsModels[ id ], buildKinematicsModel );

		}

		function parseKinematicsTechniqueCommon( xml, data ) {

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'joint':
						data.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );
						break;

					case 'link':
						data.links.push( parseKinematicsLink( child ) );
						break;

				}

			}

		}

		function parseKinematicsJoint( xml ) {

			let data;

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'prismatic':
					case 'revolute':
						data = parseKinematicsJointParameter( child );
						break;

				}

			}

			return data;

		}

		function parseKinematicsJointParameter( xml ) {

			const data = {
				sid: xml.getAttribute( 'sid' ),
				name: xml.getAttribute( 'name' ) || '',
				axis: new Vector3(),
				limits: {
					min: 0,
					max: 0
				},
				type: xml.nodeName,
				static: false,
				zeroPosition: 0,
				middlePosition: 0
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'axis':
						const array = parseFloats( child.textContent );
						data.axis.fromArray( array );
						break;
					case 'limits':
						const max = child.getElementsByTagName( 'max' )[ 0 ];
						const min = child.getElementsByTagName( 'min' )[ 0 ];

						data.limits.max = parseFloat( max.textContent );
						data.limits.min = parseFloat( min.textContent );
						break;

				}

			}

			// if min is equal to or greater than max, consider the joint static

			if ( data.limits.min >= data.limits.max ) {

				data.static = true;

			}

			// calculate middle position

			data.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;

			return data;

		}

		function parseKinematicsLink( xml ) {

			const data = {
				sid: xml.getAttribute( 'sid' ),
				name: xml.getAttribute( 'name' ) || '',
				attachments: [],
				transforms: []
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'attachment_full':
						data.attachments.push( parseKinematicsAttachment( child ) );
						break;

					case 'matrix':
					case 'translate':
					case 'rotate':
						data.transforms.push( parseKinematicsTransform( child ) );
						break;

				}

			}

			return data;

		}

		function parseKinematicsAttachment( xml ) {

			const data = {
				joint: xml.getAttribute( 'joint' ).split( '/' ).pop(),
				transforms: [],
				links: []
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'link':
						data.links.push( parseKinematicsLink( child ) );
						break;

					case 'matrix':
					case 'translate':
					case 'rotate':
						data.transforms.push( parseKinematicsTransform( child ) );
						break;

				}

			}

			return data;

		}

		function parseKinematicsTransform( xml ) {

			const data = {
				type: xml.nodeName
			};

			const array = parseFloats( xml.textContent );

			switch ( data.type ) {

				case 'matrix':
					data.obj = new Matrix4();
					data.obj.fromArray( array ).transpose();
					break;

				case 'translate':
					data.obj = new Vector3();
					data.obj.fromArray( array );
					break;

				case 'rotate':
					data.obj = new Vector3();
					data.obj.fromArray( array );
					data.angle = MathUtils.degToRad( array[ 3 ] );
					break;

			}

			return data;

		}

		// physics

		function parsePhysicsModel( xml ) {

			const data = {
				name: xml.getAttribute( 'name' ) || '',
				rigidBodies: {}
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'rigid_body':
						data.rigidBodies[ child.getAttribute( 'name' ) ] = {};
						parsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );
						break;

				}

			}

			library.physicsModels[ xml.getAttribute( 'id' ) ] = data;

		}

		function parsePhysicsRigidBody( xml, data ) {

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'technique_common':
						parsePhysicsTechniqueCommon( child, data );
						break;

				}

			}

		}

		function parsePhysicsTechniqueCommon( xml, data ) {

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'inertia':
						data.inertia = parseFloats( child.textContent );
						break;

					case 'mass':
						data.mass = parseFloats( child.textContent )[ 0 ];
						break;

				}

			}

		}

		// scene

		function parseKinematicsScene( xml ) {

			const data = {
				bindJointAxis: []
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'bind_joint_axis':
						data.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );
						break;

				}

			}

			library.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;

		}

		function parseKinematicsBindJointAxis( xml ) {

			const data = {
				target: xml.getAttribute( 'target' ).split( '/' ).pop()
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				switch ( child.nodeName ) {

					case 'axis':
						const param = child.getElementsByTagName( 'param' )[ 0 ];
						data.axis = param.textContent;
						const tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];
						data.jointIndex = tmpJointIndex.substring( 0, tmpJointIndex.length - 1 );
						break;

				}

			}

			return data;

		}

		function buildKinematicsScene( data ) {

			if ( data.build !== undefined ) return data.build;

			return data;

		}

		function getKinematicsScene( id ) {

			return getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );

		}

		function setupKinematics() {

			const kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];
			const kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];
			const visualSceneId = Object.keys( library.visualScenes )[ 0 ];

			if ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;

			const kinematicsModel = getKinematicsModel( kinematicsModelId );
			const kinematicsScene = getKinematicsScene( kinematicsSceneId );
			const visualScene = getVisualScene( visualSceneId );

			const bindJointAxis = kinematicsScene.bindJointAxis;
			const jointMap = {};

			for ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {

				const axis = bindJointAxis[ i ];

				// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'

				const targetElement = collada.querySelector( '[sid="' + axis.target + '"]' );

				if ( targetElement ) {

					// get the parent of the transform element

					const parentVisualElement = targetElement.parentElement;

					// connect the joint of the kinematics model with the element in the visual scene

					connect( axis.jointIndex, parentVisualElement );

				}

			}

			function connect( jointIndex, visualElement ) {

				const visualElementName = visualElement.getAttribute( 'name' );
				const joint = kinematicsModel.joints[ jointIndex ];

				visualScene.traverse( function ( object ) {

					if ( object.name === visualElementName ) {

						jointMap[ jointIndex ] = {
							object: object,
							transforms: buildTransformList( visualElement ),
							joint: joint,
							position: joint.zeroPosition
						};

					}

				} );

			}

			const m0 = new Matrix4();

			kinematics = {

				joints: kinematicsModel && kinematicsModel.joints,

				getJointValue: function ( jointIndex ) {

					const jointData = jointMap[ jointIndex ];

					if ( jointData ) {

						return jointData.position;

					} else {

						console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\'t exist.' );

					}

				},

				setJointValue: function ( jointIndex, value ) {

					const jointData = jointMap[ jointIndex ];

					if ( jointData ) {

						const joint = jointData.joint;

						if ( value > joint.limits.max || value < joint.limits.min ) {

							console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );

						} else if ( joint.static ) {

							console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );

						} else {

							const object = jointData.object;
							const axis = joint.axis;
							const transforms = jointData.transforms;

							matrix.identity();

							// each update, we have to apply all transforms in the correct order

							for ( let i = 0; i < transforms.length; i ++ ) {

								const transform = transforms[ i ];

								// if there is a connection of the transform node with a joint, apply the joint value

								if ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {

									switch ( joint.type ) {

										case 'revolute':
											matrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );
											break;

										case 'prismatic':
											matrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );
											break;

										default:
											console.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );
											break;

									}

								} else {

									switch ( transform.type ) {

										case 'matrix':
											matrix.multiply( transform.obj );
											break;

										case 'translate':
											matrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );
											break;

										case 'scale':
											matrix.scale( transform.obj );
											break;

										case 'rotate':
											matrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );
											break;

									}

								}

							}

							object.matrix.copy( matrix );
							object.matrix.decompose( object.position, object.quaternion, object.scale );

							jointMap[ jointIndex ].position = value;

						}

					} else {

						console.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );

					}

				}

			};

		}

		function buildTransformList( node ) {

			const transforms = [];

			const xml = collada.querySelector( '[id="' + node.id + '"]' );

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				let array, vector;

				switch ( child.nodeName ) {

					case 'matrix':
						array = parseFloats( child.textContent );
						const matrix = new Matrix4().fromArray( array ).transpose();
						transforms.push( {
							sid: child.getAttribute( 'sid' ),
							type: child.nodeName,
							obj: matrix
						} );
						break;

					case 'translate':
					case 'scale':
						array = parseFloats( child.textContent );
						vector = new Vector3().fromArray( array );
						transforms.push( {
							sid: child.getAttribute( 'sid' ),
							type: child.nodeName,
							obj: vector
						} );
						break;

					case 'rotate':
						array = parseFloats( child.textContent );
						vector = new Vector3().fromArray( array );
						const angle = MathUtils.degToRad( array[ 3 ] );
						transforms.push( {
							sid: child.getAttribute( 'sid' ),
							type: child.nodeName,
							obj: vector,
							angle: angle
						} );
						break;

				}

			}

			return transforms;

		}

		// nodes

		function prepareNodes( xml ) {

			const elements = xml.getElementsByTagName( 'node' );

			// ensure all node elements have id attributes

			for ( let i = 0; i < elements.length; i ++ ) {

				const element = elements[ i ];

				if ( element.hasAttribute( 'id' ) === false ) {

					element.setAttribute( 'id', generateId() );

				}

			}

		}

		const matrix = new Matrix4();
		const vector = new Vector3();

		function parseNode( xml ) {

			const data = {
				name: xml.getAttribute( 'name' ) || '',
				type: xml.getAttribute( 'type' ),
				id: xml.getAttribute( 'id' ),
				sid: xml.getAttribute( 'sid' ),
				matrix: new Matrix4(),
				nodes: [],
				instanceCameras: [],
				instanceControllers: [],
				instanceLights: [],
				instanceGeometries: [],
				instanceNodes: [],
				transforms: {}
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				if ( child.nodeType !== 1 ) continue;

				let array;

				switch ( child.nodeName ) {

					case 'node':
						data.nodes.push( child.getAttribute( 'id' ) );
						parseNode( child );
						break;

					case 'instance_camera':
						data.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );
						break;

					case 'instance_controller':
						data.instanceControllers.push( parseNodeInstance( child ) );
						break;

					case 'instance_light':
						data.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );
						break;

					case 'instance_geometry':
						data.instanceGeometries.push( parseNodeInstance( child ) );
						break;

					case 'instance_node':
						data.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );
						break;

					case 'matrix':
						array = parseFloats( child.textContent );
						data.matrix.multiply( matrix.fromArray( array ).transpose() );
						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
						break;

					case 'translate':
						array = parseFloats( child.textContent );
						vector.fromArray( array );
						data.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );
						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
						break;

					case 'rotate':
						array = parseFloats( child.textContent );
						const angle = MathUtils.degToRad( array[ 3 ] );
						data.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );
						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
						break;

					case 'scale':
						array = parseFloats( child.textContent );
						data.matrix.scale( vector.fromArray( array ) );
						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
						break;

					case 'extra':
						break;

					default:
						console.log( child );

				}

			}

			if ( hasNode( data.id ) ) {

				console.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );

			} else {

				library.nodes[ data.id ] = data;

			}

			return data;

		}

		function parseNodeInstance( xml ) {

			const data = {
				id: parseId( xml.getAttribute( 'url' ) ),
				materials: {},
				skeletons: []
			};

			for ( let i = 0; i < xml.childNodes.length; i ++ ) {

				const child = xml.childNodes[ i ];

				switch ( child.nodeName ) {

					case 'bind_material':
						const instances = child.getElementsByTagName( 'instance_material' );

						for ( let j = 0; j < instances.length; j ++ ) {

							const instance = instances[ j ];
							const symbol = instance.getAttribute( 'symbol' );
							const target = instance.getAttribute( 'target' );

							data.materials[ symbol ] = parseId( target );

						}

						break;

					case 'skeleton':
						data.skeletons.push( parseId( child.textContent ) );
						break;

					default:
						break;

				}

			}

			return data;

		}

		function buildSkeleton( skeletons, joints ) {

			const boneData = [];
			const sortedBoneData = [];

			let i, j, data;

			// a skeleton can have multiple root bones. collada expresses this
			// situtation with multiple "skeleton" tags per controller instance

			for ( i = 0; i < skeletons.length; i ++ ) {

				const skeleton = skeletons[ i ];

				let root;

				if ( hasNode( skeleton ) ) {

					root = getNode( skeleton );
					buildBoneHierarchy( root, joints, boneData );

				} else if ( hasVisualScene( skeleton ) ) {

					// handle case where the skeleton refers to the visual scene (#13335)

					const visualScene = library.visualScenes[ skeleton ];
					const children = visualScene.children;

					for ( let j = 0; j < children.length; j ++ ) {

						const child = children[ j ];

						if ( child.type === 'JOINT' ) {

							const root = getNode( child.id );
							buildBoneHierarchy( root, joints, boneData );

						}

					}

				} else {

					console.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );

				}

			}

			// sort bone data (the order is defined in the corresponding controller)

			for ( i = 0; i < joints.length; i ++ ) {

				for ( j = 0; j < boneData.length; j ++ ) {

					data = boneData[ j ];

					if ( data.bone.name === joints[ i ].name ) {

						sortedBoneData[ i ] = data;
						data.processed = true;
						break;

					}

				}

			}

			// add unprocessed bone data at the end of the list

			for ( i = 0; i < boneData.length; i ++ ) {

				data = boneData[ i ];

				if ( data.processed === false ) {

					sortedBoneData.push( data );
					data.processed = true;

				}

			}

			// setup arrays for skeleton creation

			const bones = [];
			const boneInverses = [];

			for ( i = 0; i < sortedBoneData.length; i ++ ) {

				data = sortedBoneData[ i ];

				bones.push( data.bone );
				boneInverses.push( data.boneInverse );

			}

			return new Skeleton( bones, boneInverses );

		}

		function buildBoneHierarchy( root, joints, boneData ) {

			// setup bone data from visual scene

			root.traverse( function ( object ) {

				if ( object.isBone === true ) {

					let boneInverse;

					// retrieve the boneInverse from the controller data

					for ( let i = 0; i < joints.length; i ++ ) {

						const joint = joints[ i ];

						if ( joint.name === object.name ) {

							boneInverse = joint.boneInverse;
							break;

						}

					}

					if ( boneInverse === undefined ) {

						// Unfortunately, there can be joints in the visual scene that are not part of the
						// corresponding controller. In this case, we have to create a dummy boneInverse matrix
						// for the respective bone. This bone won't affect any vertices, because there are no skin indices
						// and weights defined for it. But we still have to add the bone to the sorted bone list in order to
						// ensure a correct animation of the model.

						boneInverse = new Matrix4();

					}

					boneData.push( { bone: object, boneInverse: boneInverse, processed: false } );

				}

			} );

		}

		function buildNode( data ) {

			const objects = [];

			const matrix = data.matrix;
			const nodes = data.nodes;
			const type = data.type;
			const instanceCameras = data.instanceCameras;
			const instanceControllers = data.instanceControllers;
			const instanceLights = data.instanceLights;
			const instanceGeometries = data.instanceGeometries;
			const instanceNodes = data.instanceNodes;

			// nodes

			for ( let i = 0, l = nodes.length; i < l; i ++ ) {

				objects.push( getNode( nodes[ i ] ) );

			}

			// instance cameras

			for ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {

				const instanceCamera = getCamera( instanceCameras[ i ] );

				if ( instanceCamera !== null ) {

					objects.push( instanceCamera.clone() );

				}

			}

			// instance controllers

			for ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {

				const instance = instanceControllers[ i ];
				const controller = getController( instance.id );
				const geometries = getGeometry( controller.id );
				const newObjects = buildObjects( geometries, instance.materials );

				const skeletons = instance.skeletons;
				const joints = controller.skin.joints;

				const skeleton = buildSkeleton( skeletons, joints );

				for ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {

					const object = newObjects[ j ];

					if ( object.isSkinnedMesh ) {

						object.bind( skeleton, controller.skin.bindMatrix );
						object.normalizeSkinWeights();

					}

					objects.push( object );

				}

			}

			// instance lights

			for ( let i = 0, l = instanceLights.length; i < l; i ++ ) {

				const instanceLight = getLight( instanceLights[ i ] );

				if ( instanceLight !== null ) {

					objects.push( instanceLight.clone() );

				}

			}

			// instance geometries

			for ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {

				const instance = instanceGeometries[ i ];

				// a single geometry instance in collada can lead to multiple object3Ds.
				// this is the case when primitives are combined like triangles and lines

				const geometries = getGeometry( instance.id );
				const newObjects = buildObjects( geometries, instance.materials );

				for ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {

					objects.push( newObjects[ j ] );

				}

			}

			// instance nodes

			for ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {

				objects.push( getNode( instanceNodes[ i ] ).clone() );

			}

			let object;

			if ( nodes.length === 0 && objects.length === 1 ) {

				object = objects[ 0 ];

			} else {

				object = ( type === 'JOINT' ) ? new Bone() : new Group();

				for ( let i = 0; i < objects.length; i ++ ) {

					object.add( objects[ i ] );

				}

			}

			object.name = ( type === 'JOINT' ) ? data.sid : data.name;
			object.matrix.copy( matrix );
			object.matrix.decompose( object.position, object.quaternion, object.scale );

			return object;

		}

		const fallbackMaterial = new MeshBasicMaterial( { color: 0xff00ff } );

		function resolveMaterialBinding( keys, instanceMaterials ) {

			const materials = [];

			for ( let i = 0, l = keys.length; i < l; i ++ ) {

				const id = instanceMaterials[ keys[ i ] ];

				if ( id === undefined ) {

					console.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );
					materials.push( fallbackMaterial );

				} else {

					materials.push( getMaterial( id ) );

				}

			}

			return materials;

		}

		function buildObjects( geometries, instanceMaterials ) {

			const objects = [];

			for ( const type in geometries ) {

				const geometry = geometries[ type ];

				const materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );

				// handle case if no materials are defined

				if ( materials.length === 0 ) {

					if ( type === 'lines' || type === 'linestrips' ) {

						materials.push( new LineBasicMaterial() );

					} else {

						materials.push( new MeshPhongMaterial() );

					}

				}

				// regard skinning

				const skinning = ( geometry.data.attributes.skinIndex !== undefined );

				// choose between a single or multi materials (material array)

				const material = ( materials.length === 1 ) ? materials[ 0 ] : materials;

				// now create a specific 3D object

				let object;

				switch ( type ) {

					case 'lines':
						object = new LineSegments( geometry.data, material );
						break;

					case 'linestrips':
						object = new Line( geometry.data, material );
						break;

					case 'triangles':
					case 'polylist':
						if ( skinning ) {

							object = new SkinnedMesh( geometry.data, material );

						} else {

							object = new Mesh( geometry.data, material );

						}

						break;

				}

				objects.push( object );

			}

			return objects;

		}

		function hasNode( id ) {

			return library.nodes[ id ] !== undefined;

		}

		function getNode( id ) {

			return getBuild( library.nodes[ id ], buildNode );

		}

		// visual scenes

		function parseVisualScene( xml ) {

			const data = {
				name: xml.getAttribute( 'name' ),
				children: []
			};

			prepareNodes( xml );

			const elements = getElementsByTagName( xml, 'node' );

			for ( let i = 0; i < elements.length; i ++ ) {

				data.children.push( parseNode( elements[ i ] ) );

			}

			library.visualScenes[ xml.getAttribute( 'id' ) ] = data;

		}

		function buildVisualScene( data ) {

			const group = new Group();
			group.name = data.name;

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				const child = children[ i ];

				group.add( getNode( child.id ) );

			}

			return group;

		}

		function hasVisualScene( id ) {

			return library.visualScenes[ id ] !== undefined;

		}

		function getVisualScene( id ) {

			return getBuild( library.visualScenes[ id ], buildVisualScene );

		}

		// scenes

		function parseScene( xml ) {

			const instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];
			return getVisualScene( parseId( instance.getAttribute( 'url' ) ) );

		}

		function setupAnimations() {

			const clips = library.clips;

			if ( isEmpty( clips ) === true ) {

				if ( isEmpty( library.animations ) === false ) {

					// if there are animations but no clips, we create a default clip for playback

					const tracks = [];

					for ( const id in library.animations ) {

						const animationTracks = getAnimation( id );

						for ( let i = 0, l = animationTracks.length; i < l; i ++ ) {

							tracks.push( animationTracks[ i ] );

						}

					}

					animations.push( new AnimationClip( 'default', - 1, tracks ) );

				}

			} else {

				for ( const id in clips ) {

					animations.push( getAnimationClip( id ) );

				}

			}

		}

		// convert the parser error element into text with each child elements text
		// separated by new lines.

		function parserErrorToText( parserError ) {

			let result = '';
			const stack = [ parserError ];

			while ( stack.length ) {

				const node = stack.shift();

				if ( node.nodeType === Node.TEXT_NODE ) {

					result += node.textContent;

				} else {

					result += '\n';
					stack.push.apply( stack, node.childNodes );

				}

			}

			return result.trim();

		}

		if ( text.length === 0 ) {

			return { scene: new Scene() };

		}

    // A name or id could be a string enclosed by angle brackets like
    // "<name>". A name like this will not be parsed correctly by the
    // DOMParser, so we remove the angle brackets.
    text = text.replace(/"\<(.*?)\>"/g, '"$1" ');
    // Single quote version
    text = text.replace(/'\<(.*?)\>'/g, '"$1" ');

		const xml = new DOMParser().parseFromString( text, 'application/xml' );

		const collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];

		const parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];
		if ( parserError !== undefined ) {

			// Chrome will return parser error with a div in it

			const errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];
			let errorText;

			if ( errorElement ) {

				errorText = errorElement.textContent;

			} else {

				errorText = parserErrorToText( parserError );

			}

			console.error( 'THREE.ColladaLoader: Failed to parse collada file.\n', errorText );

			return null;

		}

		// metadata

		const version = collada.getAttribute( 'version' );
		console.log( 'THREE.ColladaLoader: File version', version );

		const asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );

		// Allows internal methods to access the cache.
		var scope = this;

		const textureLoader = new TextureLoader( this.manager );
		textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

		// Change the texture loader, if the requestHeader is present.
		// Texture Loaders use an Image Loader internally, instead of a File Loader.
		// Image Loader uses an img tag, and their src request doesn't accept custom headers.
		// See https://github.com/mrdoob/three.js/issues/10439
		if (scope.requestHeader && Object.keys(scope.requestHeader).length > 0) {
			textureLoader.load = function(url, onLoad, onProgress, onError) {
				var fileLoader = new THREE.FileLoader(scope.manager);
				fileLoader.setPath(this.path).setCrossOrigin(scope.crossOrigin);
				fileLoader.setResponseType('blob');
				fileLoader.setRequestHeader(scope.requestHeader);
				var texture = new THREE.Texture();
				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

				// Once the image is loaded, we need to revoke the ObjectURL.
				image.onload = function () {
					image.onload = null;
					URL.revokeObjectURL( image.src );
					if (onLoad) {
						onLoad(image);
					}
					texture.image = image;
					texture.needsUpdate = true;
					scope.manager.itemEnd( url );
				};

				image.onerror = onError;

				// Once the image is loaded, we need to revoke the ObjectURL.
				fileLoader.load(
					url,
					function(blob) {
						image.src = URL.createObjectURL(blob);
					},
					onProgress,
					onError
				);

				scope.manager.itemStart( url );
				return texture;
			};
		}

		let tgaLoader;

		if ( TGALoader ) {

			tgaLoader = new TGALoader( this.manager );
			tgaLoader.setPath( this.resourcePath || path );

			if (scope.requestHeader && Object.keys(scope.requestHeader).length > 0) {
				tgaLoader.setRequestHeader(scope.requestHeader);
			}
		}

		//

		const tempColor = new Color();
		const animations = [];
		let kinematics = {};
		let count = 0;

		//

		const library = {
			animations: {},
			clips: {},
			controllers: {},
			images: {},
			effects: {},
			materials: {},
			cameras: {},
			lights: {},
			geometries: {},
			nodes: {},
			visualScenes: {},
			kinematicsModels: {},
			physicsModels: {},
			kinematicsScenes: {}
		};

		parseLibrary( collada, 'library_animations', 'animation', parseAnimation );
		parseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );
		parseLibrary( collada, 'library_controllers', 'controller', parseController );
		parseLibrary( collada, 'library_images', 'image', parseImage );
		parseLibrary( collada, 'library_effects', 'effect', parseEffect );
		parseLibrary( collada, 'library_materials', 'material', parseMaterial );
		parseLibrary( collada, 'library_cameras', 'camera', parseCamera );
		parseLibrary( collada, 'library_lights', 'light', parseLight );
		parseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );
		parseLibrary( collada, 'library_nodes', 'node', parseNode );
		parseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );
		parseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );
		parseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );
		parseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );

		buildLibrary( library.animations, buildAnimation );
		buildLibrary( library.clips, buildAnimationClip );
		buildLibrary( library.controllers, buildController );
		buildLibrary( library.images, buildImage );
		buildLibrary( library.effects, buildEffect );
		buildLibrary( library.materials, buildMaterial );
		buildLibrary( library.cameras, buildCamera );
		buildLibrary( library.lights, buildLight );
		buildLibrary( library.geometries, buildGeometry );
		buildLibrary( library.visualScenes, buildVisualScene );

		setupAnimations();
		setupKinematics();

		const scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );
		scene.animations = animations;

		if ( asset.upAxis === 'Z_UP' ) {

			scene.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );

		}

		scene.scale.multiplyScalar( asset.unit );

		return {
			get animations() {

				console.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );
				return animations;

			},
			kinematics: kinematics,
			library: library,
			scene: scene
		};

	}

}

export { ColladaLoader };



---
File: /include/DDSLoader.js
---

// This file was taken from https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/DDSLoader.js
import {
  CompressedTextureLoader,
  RGBAFormat,
  RGB_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  CompressedPixelFormat
} from 'three';

class DDSLoader extends CompressedTextureLoader {

  constructor( manager ) {
    super( manager );
  }

  parse(buffer, loadMipmaps) {
    const dds = {
      isCubemap: false,
      mipmaps: [],
      width: 0,
      height: 0,
      format: null,
      mipmapCount: 1
    };
    // Adapted from @toji's DDS utils
    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
    // All values and structures referenced from:
    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/

    const DDS_MAGIC = 0x20534444; // const DDSD_CAPS = 0x1;
    // const DDSD_HEIGHT = 0x2;
    // const DDSD_WIDTH = 0x4;
    // const DDSD_PITCH = 0x8;
    // const DDSD_PIXELFORMAT = 0x1000;

    const DDSD_MIPMAPCOUNT = 0x20000; // const DDSD_LINEARSIZE = 0x80000;
    // const DDSD_DEPTH = 0x800000;
    // const DDSCAPS_COMPLEX = 0x8;
    // const DDSCAPS_MIPMAP = 0x400000;
    // const DDSCAPS_TEXTURE = 0x1000;

    const DDSCAPS2_CUBEMAP = 0x200;
    const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
    const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
    const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
    const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
    const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000; // const DDSCAPS2_VOLUME = 0x200000;
    // const DDPF_ALPHAPIXELS = 0x1;
    // const DDPF_ALPHA = 0x2;
    // const DDPF_FOURCC = 0x4;
    // const DDPF_RGB = 0x40;
    // const DDPF_YUV = 0x200;
    // const DDPF_LUMINANCE = 0x20000;

    function uint8ArraytoInt32( value, offset ) {
      return value[offset] + (value[offset+1] << 8) + (value[offset+2] << 16) + (value[offset+3] << 24);
    }

    function fourCCToInt32( value ) {

      return value.charCodeAt( 0 ) + ( value.charCodeAt( 1 ) << 8 ) + ( value.charCodeAt( 2 ) << 16 ) + ( value.charCodeAt( 3 ) << 24 );

    }

    function int32ToFourCC( value ) {

      return String.fromCharCode( value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff );

    }

    function loadARGBMip( buffer, dataOffset, width, height ) {

      const dataLength = width * height * 4;
      const srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
      const byteArray = new Uint8Array( dataLength );
      let dst = 0;
      let src = 0;

      for ( let y = 0; y < height; y ++ ) {

        for ( let x = 0; x < width; x ++ ) {

          const b = srcBuffer[ src ];
          src ++;
          const g = srcBuffer[ src ];
          src ++;
          const r = srcBuffer[ src ];
          src ++;
          const a = srcBuffer[ src ];
          src ++;
          byteArray[ dst ] = r;
          dst ++; //r

          byteArray[ dst ] = g;
          dst ++; //g

          byteArray[ dst ] = b;
          dst ++; //b

          byteArray[ dst ] = a;
          dst ++; //a

        }

      }

      return byteArray;

    }

    const FOURCC_DXT1 = fourCCToInt32( 'DXT1' );
    const FOURCC_DXT3 = fourCCToInt32( 'DXT3' );
    const FOURCC_DXT5 = fourCCToInt32( 'DXT5' );
    const FOURCC_ETC1 = fourCCToInt32( 'ETC1' );
    const headerLengthInt = 31; // The header length in 32 bit ints
    // Offsets into the header array

    const off_magic = 0;
    const off_size = 1;
    const off_flags = 2;
    const off_height = 3;
    const off_width = 4;
    const off_mipmapCount = 7; // const off_pfFlags = 20;

    const off_pfFourCC = 21;
    const off_RGBBitCount = 22;
    const off_RBitMask = 23;
    const off_GBitMask = 24;
    const off_BBitMask = 25;
    const off_ABitMask = 26; // const off_caps = 27;

    const off_caps2 = 28; // const off_caps3 = 29;
    // const off_caps4 = 30;
    // Parse header

    const header = new Int32Array( buffer, 0, headerLengthInt );

    if ( header[ off_magic ] !== DDS_MAGIC ) {

      console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );
      return dds;

    }

    let blockBytes;
    const fourCC = header[ off_pfFourCC ];
    let isRGBAUncompressed = false;

    switch ( fourCC ) {

      case FOURCC_DXT1:
        blockBytes = 8;
        dds.format = RGB_S3TC_DXT1_Format;
        break;

      case FOURCC_DXT3:
        blockBytes = 16;
        dds.format = RGBA_S3TC_DXT3_Format;
        break;

      case FOURCC_DXT5:
        blockBytes = 16;
        dds.format = RGBA_S3TC_DXT5_Format;
        break;

      case FOURCC_ETC1:
        blockBytes = 8;
        dds.format = RGB_ETC1_Format;
        break;

      default:
        if ( header[ off_RGBBitCount ] === 32 && header[ off_RBitMask ] & 0xff0000 && header[ off_GBitMask ] & 0xff00 && header[ off_BBitMask ] & 0xff && header[ off_ABitMask ] & 0xff000000 ) {

          isRGBAUncompressed = true;
          blockBytes = 64;
          dds.format = RGBAFormat;

        } else {

          console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );
          return dds;

        }

    }

    dds.mipmapCount = 1;

    if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

      dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

    }

    const caps2 = header[ off_caps2 ];
    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;

    if ( dds.isCubemap && ( ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) || ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) || ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) || ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) || ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) || ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) ) ) {

      console.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );
      return dds;

    }

    dds.width = header[ off_width ];
    dds.height = header[ off_height ];
    let dataOffset = header[ off_size ] + 4; // Extract mipmaps buffers

    const faces = dds.isCubemap ? 6 : 1;

    for ( let face = 0; face < faces; face ++ ) {

      let width = dds.width;
      let height = dds.height;


      for ( let i = 0; i < dds.mipmapCount; i ++ ) {

        let byteArray, dataLength;

        if ( isRGBAUncompressed ) {

          byteArray = loadARGBMip( buffer, dataOffset, width, height );
          dataLength = byteArray.length;

        } else {

          dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
          byteArray = new Uint8Array( buffer, dataOffset, dataLength );

        }

        const mipmap = {
          'data': byteArray,
          'width': width,
          'height': height
        };
        dds.mipmaps.push( mipmap );
        dataOffset += dataLength;
        width = Math.max( width >> 1, 1 );
        height = Math.max( height >> 1, 1 );
      }
    }

    return dds;
  }
}
export { DDSLoader };



---
File: /include/MTLLoader.js
---

import {
	Color,
	DefaultLoadingManager,
	FileLoader,
	FrontSide,
	Loader,
	LoaderUtils,
	MeshPhongMaterial,
	RepeatWrapping,
	TextureLoader,
	Vector2,
	sRGBEncoding
} from 'three';

/**
 * Loads a Wavefront .mtl file specifying materials
 */

class MTLLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	/**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to load.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text, path ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterialOptions( value ) {

		this.materialOptions = value;
		return this;

	}

	/**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {MaterialCreator}
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to parse.
	 */
	parse( text, path ) {

		const lines = text.split( '\n' );
		let info = {};
		const delimiter_pattern = /\s+/;
		const materialsInfo = {};

		for ( let i = 0; i < lines.length; i ++ ) {

			let line = lines[ i ];
			line = line.trim();

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				// Blank line or comment ignore
				continue;

			}

			const pos = line.indexOf( ' ' );

			let key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
			key = key.toLowerCase();

			let value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
			value = value.trim();

			if ( key === 'newmtl' ) {

				// New material

				info = { name: value };
				materialsInfo[ value ] = info;

			} else {

				if ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {

					const ss = value.split( delimiter_pattern, 3 );
					info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

				} else {

					info[ key ] = value;

				}

			}

		}

		const materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions );
		materialCreator.setCrossOrigin( this.crossOrigin );
		materialCreator.setManager( this.manager );
		materialCreator.setMaterials( materialsInfo );
		return materialCreator;

	}

}

/**
 * Create a new MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

class MaterialCreator {

	constructor( baseUrl = '', options = {} ) {

		this.baseUrl = baseUrl;
		this.options = options;
		this.materialsInfo = {};
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

		this.crossOrigin = 'anonymous';

		this.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide;
		this.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping;

	}

	setCrossOrigin( value ) {

		this.crossOrigin = value;
		return this;

	}

	setManager( value ) {

		this.manager = value;

	}

	setMaterials( materialsInfo ) {

		this.materialsInfo = this.convert( materialsInfo );
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

	}

	convert( materialsInfo ) {

		if ( ! this.options ) return materialsInfo;

		const converted = {};

		for ( const mn in materialsInfo ) {

			// Convert materials info into normalized form based on options

			const mat = materialsInfo[ mn ];

			const covmat = {};

			converted[ mn ] = covmat;

			for ( const prop in mat ) {

				let save = true;
				let value = mat[ prop ];
				const lprop = prop.toLowerCase();

				switch ( lprop ) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if ( this.options && this.options.normalizeRGB ) {

							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

						}

						if ( this.options && this.options.ignoreZeroRGBs ) {

							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

								// ignore

								save = false;

							}

						}

						break;

					default:

						break;

				}

				if ( save ) {

					covmat[ lprop ] = value;

				}

			}

		}

		return converted;

	}

	preload() {

		for ( const mn in this.materialsInfo ) {

			this.create( mn );

		}

	}

	getIndex( materialName ) {

		return this.nameLookup[ materialName ];

	}

	getAsArray() {

		let index = 0;

		for ( const mn in this.materialsInfo ) {

			this.materialsArray[ index ] = this.create( mn );
			this.nameLookup[ mn ] = index;
			index ++;

		}

		return this.materialsArray;

	}

	create( materialName ) {

		if ( this.materials[ materialName ] === undefined ) {

			this.createMaterial_( materialName );

		}

		return this.materials[ materialName ];

	}

	createMaterial_( materialName ) {

		// Create material

		const scope = this;
		const mat = this.materialsInfo[ materialName ];
		const params = {

			name: materialName,
			side: this.side

		};

		function resolveURL( baseUrl, url ) {

			if ( typeof url !== 'string' || url === '' )
				return '';

			// Absolute URL
			if ( /^https?:\/\//i.test( url ) ) return url;

			return baseUrl + url;

		}

		function setMapForType( mapType, value ) {

			if ( params[ mapType ] ) return; // Keep the first encountered texture

			const texParams = scope.getTextureParams( value, params );
			const map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );

			map.repeat.copy( texParams.scale );
			map.offset.copy( texParams.offset );

			map.wrapS = scope.wrap;
			map.wrapT = scope.wrap;

			if ( mapType === 'map' || mapType === 'emissiveMap' ) {

				map.encoding = sRGBEncoding;

			}

			params[ mapType ] = map;

		}

		for ( const prop in mat ) {

			const value = mat[ prop ];
			let n;

			if ( value === '' ) continue;

			switch ( prop.toLowerCase() ) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params.color = new Color().fromArray( value ).convertSRGBToLinear();

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params.specular = new Color().fromArray( value ).convertSRGBToLinear();

					break;

				case 'ke':

					// Emissive using RGB values
					params.emissive = new Color().fromArray( value ).convertSRGBToLinear();

					break;

				case 'map_kd':

					// Diffuse texture map

					setMapForType( 'map', value );

					break;

				case 'map_ks':

					// Specular map

					setMapForType( 'specularMap', value );

					break;

				case 'map_ke':

					// Emissive map

					setMapForType( 'emissiveMap', value );

					break;

				case 'norm':

					setMapForType( 'normalMap', value );

					break;

				case 'map_bump':
				case 'bump':

					// Bump texture map

					setMapForType( 'bumpMap', value );

					break;

				case 'map_d':

					// Alpha map

					setMapForType( 'alphaMap', value );
					params.transparent = true;

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params.shininess = parseFloat( value );

					break;

				case 'd':
					n = parseFloat( value );

					if ( n < 1 ) {

						params.opacity = n;
						params.transparent = true;

					}

					break;

				case 'tr':
					n = parseFloat( value );

					if ( this.options && this.options.invertTrProperty ) n = 1 - n;

					if ( n > 0 ) {

						params.opacity = 1 - n;
						params.transparent = true;

					}

					break;

				default:
					break;

			}

		}

		this.materials[ materialName ] = new MeshPhongMaterial( params );
		return this.materials[ materialName ];

	}

	getTextureParams( value, matParams ) {

		const texParams = {

			scale: new Vector2( 1, 1 ),
			offset: new Vector2( 0, 0 )

		 };

		const items = value.split( /\s+/ );
		let pos;

		pos = items.indexOf( '-bm' );

		if ( pos >= 0 ) {

			matParams.bumpScale = parseFloat( items[ pos + 1 ] );
			items.splice( pos, 2 );

		}

		pos = items.indexOf( '-s' );

		if ( pos >= 0 ) {

			texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		pos = items.indexOf( '-o' );

		if ( pos >= 0 ) {

			texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		texParams.url = items.join( ' ' ).trim();
		return texParams;

	}

	loadTexture( url, mapping, onLoad, onProgress, onError ) {

		const manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;
		let loader = manager.getHandler( url );

		if ( loader === null ) {

			loader = new TextureLoader( manager );

		}

		if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );

		const texture = loader.load( url, onLoad, onProgress, onError );

		if ( mapping !== undefined ) texture.mapping = mapping;

		return texture;

	}

}

export { MTLLoader, MaterialCreator };



---
File: /include/OBJLoader.js
---

import {
	BufferGeometry,
	FileLoader,
	Float32BufferAttribute,
	Group,
	LineBasicMaterial,
	LineSegments,
	Loader,
	Material,
	Mesh,
	MeshPhongMaterial,
	Points,
	PointsMaterial,
	Vector3,
	Color
} from 'three';

// o object_name | g group_name
const _object_pattern = /^[og]\s*(.+)?/;
// mtllib file_reference
const _material_library_pattern = /^mtllib /;
// usemtl material_name
const _material_use_pattern = /^usemtl /;
// usemap map_name
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;

const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();

const _ab = new Vector3();
const _cb = new Vector3();

const _color = new Color();

function ParserState() {

	const state = {
		objects: [],
		object: {},

		vertices: [],
		normals: [],
		colors: [],
		uvs: [],

		materials: {},
		materialLibraries: [],

		startObject: function ( name, fromDeclaration ) {

			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {

				this.object.name = name;
				this.object.fromDeclaration = ( fromDeclaration !== false );
				return;

			}

			const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

			this.object = {
				name: name || '',
				fromDeclaration: ( fromDeclaration !== false ),

				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,

				startMaterial: function ( name, libraries ) {

					const previous = this._finalize( false );

					// New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.
					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

						this.materials.splice( previous.index, 1 );

					}

					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
						smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
						groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
						groupEnd: - 1,
						groupCount: - 1,
						inherited: false,

						clone: function ( index ) {

							const cloned = {
								index: ( typeof index === 'number' ? index : this.index ),
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: - 1,
								groupCount: - 1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;

						}
					};

					this.materials.push( material );

					return material;

				},

				currentMaterial: function () {

					if ( this.materials.length > 0 ) {

						return this.materials[ this.materials.length - 1 ];

					}

					return undefined;

				},

				_finalize: function ( end ) {

					const lastMultiMaterial = this.currentMaterial();
					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {

						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;

					}

					// Ignore objects tail materials if no face declarations followed them before a new o/g started.
					if ( end && this.materials.length > 1 ) {

						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {

							if ( this.materials[ mi ].groupCount <= 0 ) {

								this.materials.splice( mi, 1 );

							}

						}

					}

					// Guarantee at least one empty material, this makes the creation later more straight forward.
					if ( end && this.materials.length === 0 ) {

						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );

					}

					return lastMultiMaterial;

				}
			};

			// Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );

			}

			this.objects.push( this.object );

		},

		finalize: function () {

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

		},

		parseVertexIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseNormalIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseUVIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

		},

		addVertex: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addVertexPoint: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addVertexLine: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addNormal: function ( a, b, c ) {

			const src = this.normals;
			const dst = this.object.geometry.normals;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addFaceNormal: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.normals;

			_vA.fromArray( src, a );
			_vB.fromArray( src, b );
			_vC.fromArray( src, c );

			_cb.subVectors( _vC, _vB );
			_ab.subVectors( _vA, _vB );
			_cb.cross( _ab );

			_cb.normalize();

			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );

		},

		addColor: function ( a, b, c ) {

			const src = this.colors;
			const dst = this.object.geometry.colors;

			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addUV: function ( a, b, c ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );

		},

		addDefaultUV: function () {

			const dst = this.object.geometry.uvs;

			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );

		},

		addUVLine: function ( a ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );

		},

		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

			const vLen = this.vertices.length;

			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );

			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic );

			// normals

			if ( na !== undefined && na !== '' ) {

				const nLen = this.normals.length;

				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );

				this.addNormal( ia, ib, ic );

			} else {

				this.addFaceNormal( ia, ib, ic );

			}

			// uvs

			if ( ua !== undefined && ua !== '' ) {

				const uvLen = this.uvs.length;

				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );

				this.addUV( ia, ib, ic );

				this.object.geometry.hasUVIndices = true;

			} else {

				// add placeholder values (for inconsistent face definitions)

				this.addDefaultUV();

			}

		},

		addPointGeometry: function ( vertices ) {

			this.object.geometry.type = 'Points';

			const vLen = this.vertices.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				const index = this.parseVertexIndex( vertices[ vi ], vLen );

				this.addVertexPoint( index );
				this.addColor( index );

			}

		},

		addLineGeometry: function ( vertices, uvs ) {

			this.object.geometry.type = 'Line';

			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

			}

			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

			}

		}

	};

	state.startObject( '', false );

	return state;

}

//

class OBJLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.materials = null;

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterials( materials ) {

		this.materials = materials;

		return this;

	}

	parse( text ) {

		const state = new ParserState();

		if ( text.indexOf( '\r\n' ) !== - 1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== - 1 ) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		const lines = text.split( '\n' );
		let result = [];

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trimStart();

			if ( line.length === 0 ) continue;

			const lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue;

			if ( lineFirstChar === 'v' ) {

				const data = line.split( _face_vertex_data_separator_pattern );

				switch ( data[ 0 ] ) {

					case 'v':
						state.vertices.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						if ( data.length >= 7 ) {

							_color.setRGB(
								parseFloat( data[ 4 ] ),
								parseFloat( data[ 5 ] ),
								parseFloat( data[ 6 ] )
							).convertSRGBToLinear();

							state.colors.push( _color.r, _color.g, _color.b );

						} else {

							// if no colors are defined, add placeholders so color and vertex indices match

							state.colors.push( undefined, undefined, undefined );

						}

						break;
					case 'vn':
						state.normals.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						break;
					case 'vt':
						state.uvs.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] )
						);
						break;

				}

			} else if ( lineFirstChar === 'f' ) {

				const lineData = line.slice( 1 ).trim();
				const vertexData = lineData.split( _face_vertex_data_separator_pattern );
				const faceVertices = [];

				// Parse the face vertex data into an easy to work with format

				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {

					const vertex = vertexData[ j ];

					if ( vertex.length > 0 ) {

						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );

					}

				}

				// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

				const v1 = faceVertices[ 0 ];

				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];

					state.addFace(
						v1[ 0 ], v2[ 0 ], v3[ 0 ],
						v1[ 1 ], v2[ 1 ], v3[ 1 ],
						v1[ 2 ], v2[ 2 ], v3[ 2 ]
					);

				}

			} else if ( lineFirstChar === 'l' ) {

				const lineParts = line.substring( 1 ).trim().split( ' ' );
				let lineVertices = [];
				const lineUVs = [];

				if ( line.indexOf( '/' ) === - 1 ) {

					lineVertices = lineParts;

				} else {

					for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {

						const parts = lineParts[ li ].split( '/' );

						if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

					}

				}

				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( lineFirstChar === 'p' ) {

				const lineData = line.slice( 1 ).trim();
				const pointData = lineData.split( ' ' );

				state.addPointGeometry( pointData );

			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// let name = result[ 0 ].slice( 1 ).trim();
				const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );

				state.startObject( name );

			} else if ( _material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( _material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( _map_use_pattern.test( line ) ) {

				// the line is parsed but ignored since the loader assumes textures are defined MTL files
				// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

				console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

			} else if ( lineFirstChar === 's' ) {

				result = line.split( ' ' );

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				/*
					 * http://paulbourke.net/dataformats/obj/
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
				if ( result.length > 1 ) {

					const value = result[ 1 ].trim().toLowerCase();
					state.object.smooth = ( value !== '0' && value !== 'off' );

				} else {

					// ZBrush can produce "s" lines #11707
					state.object.smooth = true;

				}

				const material = state.object.currentMaterial();
				if ( material ) material.smooth = state.object.smooth;

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

			}

		}

		state.finalize();

		const container = new Group();
		container.materialLibraries = [].concat( state.materialLibraries );

		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

		if ( hasPrimitives === true ) {

			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {

				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = ( geometry.type === 'Line' );
				const isPoints = ( geometry.type === 'Points' );
				let hasVertexColors = false;

				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );

				if ( geometry.normals.length > 0 ) {

					buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );

				}

				if ( geometry.colors.length > 0 ) {

					hasVertexColors = true;
					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );

				}

				if ( geometry.hasUVIndices === true ) {

					buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );

				}

				// Create materials

				const createdMaterials = [];

				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name );

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {

							const materialLine = new LineBasicMaterial();
							Material.prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;

						} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {

							const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );
							Material.prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;

						}

					}

					if ( material === undefined ) {

						if ( isLine ) {

							material = new LineBasicMaterial();

						} else if ( isPoints ) {

							material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

						} else {

							material = new MeshPhongMaterial();

						}

						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;

						state.materials[ materialHash ] = material;

					}

					createdMaterials.push( material );

				}

				// Create mesh

				let mesh;

				if ( createdMaterials.length > 1 ) {

					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						const sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials );

					}

				} else {

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials[ 0 ] );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );

					}

				}

				mesh.name = object.name;

				container.add( mesh );

			}

		} else {

			// if there is only the default parser state object with no geometry data, interpret data as point cloud

			if ( state.vertices.length > 0 ) {

				const material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );

				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );
					material.vertexColors = true;

				}

				const points = new Points( buffergeometry, material );
				container.add( points );

			}

		}

		return container;

	}

}

export { OBJLoader };



---
File: /include/OrbitControls.js
---

/* Nate Koenig made these changes
3d2
<   Matrix4,
186,189d184
<         const oldTheta = spherical.theta;
<         const oldPhi = spherical.phi;
< 
< 
257,283c252
<         if (Math.abs(sphericalDelta.phi - 0) > 0.001 ||
<             Math.abs(sphericalDelta.theta - 0) > 0.001) {
< 
<           let rotateAroundWorldAxis = function (object, axis, radians)
<           {
<             let rotWorldMatrix = new Matrix4();
<             rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
<             rotWorldMatrix.multiply(object.matrix); // pre-multiply
<             rotWorldMatrix.decompose(object.position,
<               object.quaternion, object.scale);
<             object.updateMatrix();
<           }
< 
<           scope.object.position.sub(scope.target);
<           scope.object.updateMatrix();
<           rotateAroundWorldAxis(scope.object, new Vector3(0, 0, 1),
<             spherical.theta - oldTheta);
<           let localPitch = new Vector3(1, 0, 0);
<           localPitch.applyQuaternion(scope.object.quaternion);
<           rotateAroundWorldAxis(scope.object, localPitch,
<                                 spherical.phi - oldPhi);
<           scope.object.position.add(scope.target);
<           scope.object.updateMatrix();
< 
<         } else {
<           position.copy( scope.target ).add( offset );
<         }
---
> 				scope.object.lookAt( scope.target );
*/
import {
	EventDispatcher,
  Matrix4,
	MOUSE,
	Quaternion,
	Spherical,
	TOUCH,
	Vector2,
	Vector3
} from 'three';

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };

class OrbitControls extends EventDispatcher {

	constructor( object, domElement ) {

		super();

		if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
		if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new Vector3();

			// so camera.up is the orbit axis
			const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new Vector3();
			const lastQuaternion = new Quaternion();

			const twoPI = 2 * Math.PI;

			return function update() {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

        const oldTheta = spherical.theta;
        const oldPhi = spherical.phi;


				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

        if (Math.abs(sphericalDelta.phi - 0) > 0.001 ||
            Math.abs(sphericalDelta.theta - 0) > 0.001) {

          let rotateAroundWorldAxis = function (object, axis, radians)
          {
            let rotWorldMatrix = new Matrix4();
            rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
            rotWorldMatrix.multiply(object.matrix); // pre-multiply
            rotWorldMatrix.decompose(object.position,
              object.quaternion, object.scale);
            object.updateMatrix();
          }

          scope.object.position.sub(scope.target);
          scope.object.updateMatrix();
          rotateAroundWorldAxis(scope.object, new Vector3(0, 0, 1),
            spherical.theta - oldTheta);
          let localPitch = new Vector3(1, 0, 0);
          localPitch.applyQuaternion(scope.object.quaternion);
          rotateAroundWorldAxis(scope.object, localPitch,
                                spherical.phi - oldPhi);
          scope.object.position.add(scope.target);
          scope.object.updateMatrix();

        } else {
          position.copy( scope.target ).add( offset );
        }

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				scale = 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		let scale = 1;
		const panOffset = new Vector3();
		let zoomChanged = false;

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();

		const pointers = [];
		const pointerPositions = {};

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly() {

			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

		    removePointer( event );

		    if ( pointers.length === 0 ) {

		        scope.domElement.releasePointerCapture( event.pointerId );

		        scope.domElement.removeEventListener( 'pointermove', onPointerMove );
		        scope.domElement.removeEventListener( 'pointerup', onPointerUp );

		    }

		    scope.dispatchEvent( _endEvent );

		    state = STATE.NONE;

		}

		function onPointerCancel( event ) {

			removePointer( event );

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( _endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// force an update at start

		this.update();

	}

}


// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

class MapControls extends OrbitControls {

	constructor( object, domElement ) {

		super( object, domElement );

		this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

		this.mouseButtons.LEFT = MOUSE.PAN;
		this.mouseButtons.RIGHT = MOUSE.ROTATE;

		this.touches.ONE = TOUCH.PAN;
		this.touches.TWO = TOUCH.DOLLY_ROTATE;

	}

}

export { OrbitControls, MapControls };




---
File: /include/STLLoader.js
---

import {
	BufferAttribute,
	BufferGeometry,
	FileLoader,
	Float32BufferAttribute,
	Loader,
	LoaderUtils,
	Vector3
} from 'three';

/**
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  const loader = new STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });
 *  } else { .... }
 *  const mesh = new THREE.Mesh( geometry, material );
 *
 * For ASCII STLs containing multiple solids, each solid is assigned to a different group.
 * Groups can be used to assign a different color by defining an array of materials with the same length of
 * geometry.groups and passing it to the Mesh constructor:
 *
 * const mesh = new THREE.Mesh( geometry, material );
 *
 * For example:
 *
 *  const materials = [];
 *  const nGeometryGroups = geometry.groups.length;
 *
 *  const colorMap = ...; // Some logic to index colors.
 *
 *  for (let i = 0; i < nGeometryGroups; i++) {
 *
 *		const material = new THREE.MeshPhongMaterial({
 *			color: colorMap[i],
 *			wireframe: false
 *		});
 *
 *  }
 *
 *  materials.push(material);
 *  const mesh = new THREE.Mesh(geometry, materials);
 */


class STLLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( data ) {

		function isBinary( data ) {

			const reader = new DataView( data );
			const face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
			const n_faces = reader.getUint32( 80, true );
			const expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );

			if ( expect === reader.byteLength ) {

				return true;

			}

			// An ASCII STL data must begin with 'solid ' as the first six bytes.
			// However, ASCII STLs lacking the SPACE after the 'd' are known to be
			// plentiful.  So, check the first 5 bytes for 'solid'.

			// Several encodings, such as UTF-8, precede the text with up to 5 bytes:
			// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
			// Search for "solid" to start anywhere after those prefixes.

			// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'

			const solid = [ 115, 111, 108, 105, 100 ];

			for ( let off = 0; off < 5; off ++ ) {

				// If "solid" text is matched to the current offset, declare it to be an ASCII STL.

				if ( matchDataViewAt( solid, reader, off ) ) return false;

			}

			// Couldn't find "solid" text at the beginning; it is binary STL.

			return true;

		}

		function matchDataViewAt( query, reader, offset ) {

			// Check if each byte in query matches the corresponding byte from the current offset

			for ( let i = 0, il = query.length; i < il; i ++ ) {

				if ( query[ i ] !== reader.getUint8( offset + i ) ) return false;

			}

			return true;

		}

		function parseBinary( data ) {

			const reader = new DataView( data );
			const faces = reader.getUint32( 80, true );

			let r, g, b, hasColors = false, colors;
			let defaultR, defaultG, defaultB, alpha;

			// process STL header
			// check for default color in header ("COLOR=rgba" sequence).

			for ( let index = 0; index < 80 - 10; index ++ ) {

				if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
					( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
					( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {

					hasColors = true;
					colors = new Float32Array( faces * 3 * 3 );

					defaultR = reader.getUint8( index + 6 ) / 255;
					defaultG = reader.getUint8( index + 7 ) / 255;
					defaultB = reader.getUint8( index + 8 ) / 255;
					alpha = reader.getUint8( index + 9 ) / 255;

				}

			}

			const dataOffset = 84;
			const faceLength = 12 * 4 + 2;

			const geometry = new BufferGeometry();

			const vertices = new Float32Array( faces * 3 * 3 );
			const normals = new Float32Array( faces * 3 * 3 );

			for ( let face = 0; face < faces; face ++ ) {

				const start = dataOffset + face * faceLength;
				const normalX = reader.getFloat32( start, true );
				const normalY = reader.getFloat32( start + 4, true );
				const normalZ = reader.getFloat32( start + 8, true );

				if ( hasColors ) {

					const packedColor = reader.getUint16( start + 48, true );

					if ( ( packedColor & 0x8000 ) === 0 ) {

						// facet has its own unique color

						r = ( packedColor & 0x1F ) / 31;
						g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
						b = ( ( packedColor >> 10 ) & 0x1F ) / 31;

					} else {

						r = defaultR;
						g = defaultG;
						b = defaultB;

					}

				}

				for ( let i = 1; i <= 3; i ++ ) {

					const vertexstart = start + i * 12;
					const componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );

					vertices[ componentIdx ] = reader.getFloat32( vertexstart, true );
					vertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );
					vertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );

					normals[ componentIdx ] = normalX;
					normals[ componentIdx + 1 ] = normalY;
					normals[ componentIdx + 2 ] = normalZ;

					if ( hasColors ) {

						colors[ componentIdx ] = r;
						colors[ componentIdx + 1 ] = g;
						colors[ componentIdx + 2 ] = b;

					}

				}

			}

			geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );

			if ( hasColors ) {

				geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );
				geometry.hasColors = true;
				geometry.alpha = alpha;

			}

			return geometry;

		}

		function parseASCII( data ) {

			const geometry = new BufferGeometry();
			const patternSolid = /solid([\s\S]*?)endsolid/g;
			const patternFace = /facet([\s\S]*?)endfacet/g;
			let faceCounter = 0;

			const patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
			const patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );
			const patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );

			const vertices = [];
			const normals = [];

			const normal = new Vector3();

			let result;

			let groupCount = 0;
			let startVertex = 0;
			let endVertex = 0;

			while ( ( result = patternSolid.exec( data ) ) !== null ) {

				startVertex = endVertex;

				const solid = result[ 0 ];

				while ( ( result = patternFace.exec( solid ) ) !== null ) {

					let vertexCountPerFace = 0;
					let normalCountPerFace = 0;

					const text = result[ 0 ];

					while ( ( result = patternNormal.exec( text ) ) !== null ) {

						normal.x = parseFloat( result[ 1 ] );
						normal.y = parseFloat( result[ 2 ] );
						normal.z = parseFloat( result[ 3 ] );
						normalCountPerFace ++;

					}

					while ( ( result = patternVertex.exec( text ) ) !== null ) {

						vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );
						normals.push( normal.x, normal.y, normal.z );
						vertexCountPerFace ++;
						endVertex ++;

					}

					// every face have to own ONE valid normal

					if ( normalCountPerFace !== 1 ) {

						console.error( 'THREE.STLLoader: Something isn\'t right with the normal of face number ' + faceCounter );

					}

					// each face have to own THREE valid vertices

					if ( vertexCountPerFace !== 3 ) {

						console.error( 'THREE.STLLoader: Something isn\'t right with the vertices of face number ' + faceCounter );

					}

					faceCounter ++;

				}

				const start = startVertex;
				const count = endVertex - startVertex;

				geometry.addGroup( start, count, groupCount );
				groupCount ++;

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

			return geometry;

		}

		function ensureString( buffer ) {

			if ( typeof buffer !== 'string' ) {

				return LoaderUtils.decodeText( new Uint8Array( buffer ) );

			}

			return buffer;

		}

		function ensureBinary( buffer ) {

			if ( typeof buffer === 'string' ) {

				const array_buffer = new Uint8Array( buffer.length );
				for ( let i = 0; i < buffer.length; i ++ ) {

					array_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian

				}

				return array_buffer.buffer || array_buffer;

			} else {

				return buffer;

			}

		}

		// start

		const binData = ensureBinary( data );

		return isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );

	}

}

export { STLLoader };



---
File: /include/TGALoader.js
---

import {
	DataTextureLoader,
	LinearMipmapLinearFilter
} from 'three';

class TGALoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

	}

	parse( buffer ) {

		// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

		function tgaCheckHeader( header ) {

			switch ( header.image_type ) {

				// check indexed type

				case TGA_TYPE_INDEXED:
				case TGA_TYPE_RLE_INDEXED:
					if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {

						console.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );

					}

					break;

					// check colormap type

				case TGA_TYPE_RGB:
				case TGA_TYPE_GREY:
				case TGA_TYPE_RLE_RGB:
				case TGA_TYPE_RLE_GREY:
					if ( header.colormap_type ) {

						console.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );

					}

					break;

					// What the need of a file without data ?

				case TGA_TYPE_NO_DATA:
					console.error( 'THREE.TGALoader: No data.' );

					// Invalid type ?

				default:
					console.error( 'THREE.TGALoader: Invalid type "%s".', header.image_type );

			}

			// check image width and height

			if ( header.width <= 0 || header.height <= 0 ) {

				console.error( 'THREE.TGALoader: Invalid image size.' );

			}

			// check image pixel size

			if ( header.pixel_size !== 8 && header.pixel_size !== 16 &&
				header.pixel_size !== 24 && header.pixel_size !== 32 ) {

				console.error( 'THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size );

			}

		}

		// parse tga image buffer

		function tgaParse( use_rle, use_pal, header, offset, data ) {

			let pixel_data,
				palettes;

			const pixel_size = header.pixel_size >> 3;
			const pixel_total = header.width * header.height * pixel_size;

			 // read palettes

			 if ( use_pal ) {

				 palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );

			 }

			 // read RLE

			 if ( use_rle ) {

				 pixel_data = new Uint8Array( pixel_total );

				let c, count, i;
				let shift = 0;
				const pixels = new Uint8Array( pixel_size );

				while ( shift < pixel_total ) {

					c = data[ offset ++ ];
					count = ( c & 0x7f ) + 1;

					// RLE pixels

					if ( c & 0x80 ) {

						// bind pixel tmp array

						for ( i = 0; i < pixel_size; ++ i ) {

							pixels[ i ] = data[ offset ++ ];

						}

						// copy pixel array

						for ( i = 0; i < count; ++ i ) {

							pixel_data.set( pixels, shift + i * pixel_size );

						}

						shift += pixel_size * count;

					} else {

						// raw pixels

						count *= pixel_size;

						for ( i = 0; i < count; ++ i ) {

							pixel_data[ shift + i ] = data[ offset ++ ];

						}

						shift += count;

					}

				}

			 } else {

				// raw pixels

				pixel_data = data.subarray(
					 offset, offset += ( use_pal ? header.width * header.height : pixel_total )
				);

			 }

			 return {
				pixel_data: pixel_data,
				palettes: palettes
			 };

		}

		function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {

			const colormap = palettes;
			let color, i = 0, x, y;
			const width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

					color = image[ i ];
					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
					imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];

				}

			}

			return imageData;

		}

		function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			let color, i = 0, x, y;
			const width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

					color = image[ i + 0 ] + ( image[ i + 1 ] << 8 );
					imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;
					imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;
					imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;
					imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;

				}

			}

			return imageData;

		}

		function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			let i = 0, x, y;
			const width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {

					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];

				}

			}

			return imageData;

		}

		function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			let i = 0, x, y;
			const width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {

					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];
					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];

				}

			}

			return imageData;

		}

		function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			let color, i = 0, x, y;
			const width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

					color = image[ i ];
					imageData[ ( x + width * y ) * 4 + 0 ] = color;
					imageData[ ( x + width * y ) * 4 + 1 ] = color;
					imageData[ ( x + width * y ) * 4 + 2 ] = color;
					imageData[ ( x + width * y ) * 4 + 3 ] = 255;

				}

			}

			return imageData;

		}

		function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			let i = 0, x, y;
			const width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];

				}

			}

			return imageData;

		}

		function getTgaRGBA( data, width, height, image, palette ) {

			let x_start,
				y_start,
				x_step,
				y_step,
				x_end,
				y_end;

			switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {

				default:
				case TGA_ORIGIN_UL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = height - 1;
					y_step = - 1;
					y_end = - 1;
					break;

				case TGA_ORIGIN_UR:
					x_start = width - 1;
					x_step = - 1;
					x_end = - 1;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BR:
					x_start = width - 1;
					x_step = - 1;
					x_end = - 1;
					y_start = height - 1;
					y_step = - 1;
					y_end = - 1;
					break;

			}

			if ( use_grey ) {

				switch ( header.pixel_size ) {

					case 8:
						tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 16:
						tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					default:
						console.error( 'THREE.TGALoader: Format not supported.' );
						break;

				}

			} else {

				switch ( header.pixel_size ) {

					case 8:
						tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );
						break;

					case 16:
						tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 24:
						tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 32:
						tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					default:
						console.error( 'THREE.TGALoader: Format not supported.' );
						break;

				}

			}

			// Load image data according to specific method
			// let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
			// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
			return data;

		}

		// TGA constants

		const TGA_TYPE_NO_DATA = 0,
			TGA_TYPE_INDEXED = 1,
			TGA_TYPE_RGB = 2,
			TGA_TYPE_GREY = 3,
			TGA_TYPE_RLE_INDEXED = 9,
			TGA_TYPE_RLE_RGB = 10,
			TGA_TYPE_RLE_GREY = 11,

			TGA_ORIGIN_MASK = 0x30,
			TGA_ORIGIN_SHIFT = 0x04,
			TGA_ORIGIN_BL = 0x00,
			TGA_ORIGIN_BR = 0x01,
			TGA_ORIGIN_UL = 0x02,
			TGA_ORIGIN_UR = 0x03;

		if ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );

		let offset = 0;

		const content = new Uint8Array( buffer ),
			header = {
				id_length: content[ offset ++ ],
				colormap_type: content[ offset ++ ],
				image_type: content[ offset ++ ],
				colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,
				colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,
				colormap_size: content[ offset ++ ],
				origin: [
					content[ offset ++ ] | content[ offset ++ ] << 8,
					content[ offset ++ ] | content[ offset ++ ] << 8
				],
				width: content[ offset ++ ] | content[ offset ++ ] << 8,
				height: content[ offset ++ ] | content[ offset ++ ] << 8,
				pixel_size: content[ offset ++ ],
				flags: content[ offset ++ ]
			};

		// check tga if it is valid format

		tgaCheckHeader( header );

		if ( header.id_length + offset > buffer.length ) {

			console.error( 'THREE.TGALoader: No data.' );

		}

		// skip the needn't data

		offset += header.id_length;

		// get targa information about RLE compression and palette

		let use_rle = false,
			use_pal = false,
			use_grey = false;

		switch ( header.image_type ) {

			case TGA_TYPE_RLE_INDEXED:
				use_rle = true;
				use_pal = true;
				break;

			case TGA_TYPE_INDEXED:
				use_pal = true;
				break;

			case TGA_TYPE_RLE_RGB:
				use_rle = true;
				break;

			case TGA_TYPE_RGB:
				break;

			case TGA_TYPE_RLE_GREY:
				use_rle = true;
				use_grey = true;
				break;

			case TGA_TYPE_GREY:
				use_grey = true;
				break;

		}

		//

		const imageData = new Uint8Array( header.width * header.height * 4 );
		const result = tgaParse( use_rle, use_pal, header, offset, content );
		getTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );

		return {

			data: imageData,
			width: header.width,
			height: header.height,
			flipY: true,
			generateMipmaps: true,
			minFilter: LinearMipmapLinearFilter,

		};

	}

}

export { TGALoader };



---
File: /src/Asset.ts
---

export type AssetCb = (msg: any, error?: any) => void;

export enum AssetError {
  NOT_FOUND = 'asset_not_found',
  URI_MISSING = 'asset_uri_missing',
};

/**
 * Type that represents a simulation asset that needs to be fetched from a websocket server.
 */
export class Asset {
  /**
   * The URI of the asset file to be fetched.
   */
  public uri: string;

  /**
   * Callback that is used when the asset has been fetched.
   * Contains the asset and an error, if found.
   */
  public cb: AssetCb;

  constructor(uri: string, cb: AssetCb) {
    this.uri = uri;
    this.cb = cb;
  }
}



---
File: /src/AssetViewer.ts
---

import { Scene } from "./Scene";
import { Shaders } from "./Shaders";
import { SDFParser } from "./SDFParser";

import { Object3D, Box3, Vector3 } from "three";
import { BehaviorSubject } from "rxjs";

/**
 * Interface used to pass parameters into the AssetViewer's constructor.
 * These should override the default behavior of the AssetViewer.
 */
export interface AssetViewerConfig {
  /**
   * Custom ID of the HTML element that will hold the rendering context.
   */
  elementId?: string;

  /**
   * Whether or not to add model lighting.
   */
  addModelLighting?: boolean;

  /**
   * Whether or not to scale the model into view.
   */
  scaleModel?: boolean;

  /**
   * Whether or not to use PBR materials.
   */
  enablePBR?: boolean;

  /**
   * An optional Fuel Server Bearer Token in case the resource is private.
   */
  token?: string;
}

/**
 * The Asset Viewer class allows clients to render and view simulation resources, such as
 * models and worlds.
 *
 * This requires all of the resource's related URLs, and there is no websocket connection involved
 * in this process.
 */
export class AssetViewer {
  /**
   * Behavior subject used to communicate if a resource has been loaded or not.
   * Note: This will be true when the Object3D is created, not when it's meshes and textures
   * finish loading.
   */
  public resourceLoaded$: BehaviorSubject<boolean> = new BehaviorSubject(false);

  /**
   * ID of the HTML element that will hold the rendering context.
   */
  private elementId: string = 'gz-scene';

  /**
   * The Gzweb Scene.
   */
  private scene: Scene | undefined;

  /**
   * The Gzweb SDF Parser. Allows us to obtain an Object3D out of an SDF file.
   */
  private sdfParser: SDFParser | undefined;

  /**
   * The object being visualized.
   */
  private resource: Object3D | undefined;

  /**
   * For animation purposes. The timestamp of the previous render in milliseconds.
   */
  private previousRenderTimestampMs: number = 0;

  /**
   * For animation purposes. The frame used to cancel the animation.
   */
  private cancelAnimationFrame: number = 0;

  /**
   * The scaling basis used, if the model is scaled.
   */
  private scalingBasis: number = 1;

  /**
   * Whether or not the model should be scaled.
   */
  private shouldScaleModel: boolean = false;

  /**
   * Used to determine if the model is already scaled.
   */
  private isScaled: boolean = false;

  /**
   * Whether or not PBR materials should be used.
   */
  private shouldUsePBR: boolean = false;

  /**
   * Fuel Server Bearer Token used in case the resource is private.
   */
  private token: string | undefined;

  /**
   * The HTML element that holds the scene.
   */
  private sceneElement: HTMLElement | undefined;

  /**
   * Once the Asset Viewer is created, it will setup the scene and start the animation loop.
   *
   * @param config The Asset Viewer configuration options.
   */
  constructor(config: AssetViewerConfig) {
    this.elementId = config.elementId ?? 'gz-scene';
    this.token = config.token;

    this.setupVisualization();

    if (this.scene && config.addModelLighting) {
      this.scene.addModelLighting();
    }

    this.shouldScaleModel = !!config.scaleModel;
    this.shouldUsePBR = !!config.enablePBR;

    this.animate();
  }

  /**
   * Destroy the scene.
   */
  public destroy() {
    if (this.cancelAnimationFrame) {
      cancelAnimationFrame(this.cancelAnimationFrame);
    }

    this.previousRenderTimestampMs = 0;

    if (this.scene) {
      this.scene.cleanup();
    }
  }

  /**
   * Resize the scene, according to its container's size.
   */
  public resize(): void {
    if (this.scene && this.sceneElement) {
      this.scene.setSize(this.sceneElement.clientWidth, this.sceneElement.clientHeight);
    }
  }

  /**
   * Position the camera to start visualizing the asset.
  */
  public resetView() {
    const camera = this.scene?.camera;
    if (camera) {
      camera.position.x = this.scalingBasis * 1.1;
      camera.position.y = -this.scalingBasis * 1.4;
      camera.position.z = this.scalingBasis * 0.6;
      camera.rotation.x = 67 * Math.PI / 180;
      camera.rotation.y = 33 * Math.PI / 180;
      camera.rotation.z = 12 * Math.PI / 180;
    }
  }

  /**
   * Given all the resource URLs, look for its SDF file and render it.
   * The obtained Object3D will be added to the Scene.
   *
   * @param files All the resource's related URLs.
   */
  public renderFromFiles(files: string[]): void {
    if (!this.scene || !this.sdfParser) {
      return;
    }

    this.sdfParser.usingFilesUrls = true;
    this.sdfParser.enablePBR = this.shouldUsePBR;

    // Look for SDF file.
    const sdfFile = files.find((file) => file.endsWith(".sdf"));

    // Add files to the Parser.
    files.forEach((file) => this.sdfParser!.addUrl(file));

    if (sdfFile) {
      this.sdfParser.loadSDF(sdfFile, (obj: Object3D) => {
        // Object has finished loading.
        this.resource = obj;

        this.scene?.add(obj);

        this.resourceLoaded$.next(true);
      });
    }
  }

  /**
   * Auxiliary method to scale the model. We aim to have it's largest dimension
   * scaled to a power of 10 (scaling basis).
   */
  public scaleModel(): void {
    if (!this.resource) {
      return;
    }

    // Create a bounding box for the object and calculate its size and center.
    const boundingBox = new Box3().setFromObject(this.resource);
    if (boundingBox.isEmpty()) {
      return;
    }

    const size = new Vector3();
    const center = new Vector3();
    boundingBox.getSize(size);
    boundingBox.getCenter(center);
    const maxDimension = Math.max(size.x, size.y, size.z);

    // Translate and rescale.
    // The scaling basis is calculated using the maximum dimension. Allows us to scale large models.
    // It is a power of 10.
    this.scalingBasis = Math.pow(10, Math.trunc(maxDimension).toString().length - 1);
    const scale = this.scalingBasis / maxDimension;

    center.multiplyScalar(-scale);
    this.resource.position.x = center.x;
    this.resource.position.y = center.y;
    this.resource.position.z = center.z;

    this.resource.scale.x = scale;
    this.resource.scale.y = scale;
    this.resource.scale.z = scale;

    // Re-center camera and avoid subsequent calls to this method in the animation loop.
    this.isScaled = true;
    this.resetView();
  }

  /**
   * Prepare the Gzweb Scene and SDF Parser before anything is added.
   */
  private setupVisualization(): void {
    this.scene = new Scene({
      shaders: new Shaders(),
    });

    this.sdfParser = new SDFParser(this.scene);

    if (this.token) {
      const header = 'Authorization';
      const value = `Bearer ${this.token}`;

      this.scene.setRequestHeader(header, value);
      this.sdfParser.setRequestHeader(header, value);
    }

    if (window.document.getElementById(this.elementId)) {
      this.sceneElement = window.document.getElementById(this.elementId)!;
      this.sceneElement.appendChild(this.scene.getDomElement());
      this.resize();
    } else {
      console.error('Unable to find HTML element with an id of', this.elementId);
    }
  }

  /**
   * The animation loop.
   */
  private animate(): void {
    if (!this.scene) {
      return;
    }

    // Scale the model on the animation loop.
    // Loading meshes is an asynchronous process, so after loading the SDF file, its bounding box may be empty.
    // This is done only once, after a mesh is loaded and the model's bounding box is not empty.
    if (this.resource !== undefined && this.shouldScaleModel && !this.isScaled) {
      this.scaleModel();
    }

    this.cancelAnimationFrame = requestAnimationFrame((timestampMs: number) => {
      if (this.previousRenderTimestampMs === 0) {
        this.previousRenderTimestampMs = timestampMs;
      }

      this.animate();

      this.scene!.render(timestampMs - this.previousRenderTimestampMs);
      this.previousRenderTimestampMs = timestampMs;
    });
  }
}



---
File: /src/AudioTopic.ts
---

import { binaryToBase64 } from './Globals';
import { Transport } from './Transport';
import { Topic } from './Topic';

export class AudioTopic {

  constructor(name: string, trans: Transport) {
    let audioMap = new Map<string, [HTMLAudioElement, boolean]>;
    let topic = new Topic(
      name,
      (msg) => {
        let playback = false;
        let uri = '';

        // Get the playback and uri information.
        for (var key in msg.params) {
          if (key === 'playback') {
            playback = msg.params[key].bool_value;
          } else if (key === 'uri') {
            uri = msg.params[key].string_value;
          }
        }

        // Control audio playback if the audio file is in the audio map.
        if (uri in audioMap) {
          const tuple = audioMap[uri];
          if (tuple[1]) {
            tuple[0].play();
          } else {
            tuple[0].pause();
          }
          tuple[1] = playback;
        // Otherwise, fetch the audio file
        } else {
          console.log('Getting audio file', uri);
          // Fetching of the asset via getAsset() below is asynchronous, meaning
          // that we could have requests for the same asset come in while we are
          // fetching it.  To prevent multiple downloads and playing of the
          // audio, add the uri to the map immediately with an empty object;
          // we'll replace that dummy object with a fully active one once
          // downloading the asset is complete.
          audioMap[uri] = [new Audio(), playback];
          trans.getAsset(uri, (asset: Uint8Array) => {
            var audioSrc = 'data:audio/mp3;base64,' +
              binaryToBase64(asset);
            let audio = new Audio(audioSrc);
            audio.src = audioSrc;
            audioMap[uri][0] = audio;
            if (audioMap[uri][1]) {
              audio.play();
            }
          });
        }
      }
    );
    trans.subscribe(topic);
  }
}



---
File: /src/Color.ts
---

import * as THREE from 'three'; 

// Color class with alpha. THREE.js has a Color class that lacks an alpha
// channel.
export class Color extends THREE.Color {
  public a: number = 1.0;
  constructor(r?: number, g?: number , b?: number , a?: number) {
    super(r as any, g as any, b as any);

    if (a) {
      this.a = a;
    }
  }
}



---
File: /src/FuelServer.ts
---

export const FUEL_HOST: string = 'fuel.gazebosim.org';
export const FUEL_VERSION: string = '1.0';
export const IGN_FUEL_HOST: string = 'fuel.ignitionrobotics.org';

/**
 * Create a valid URI that points to the Fuel Server given a local filesystem
 * path.
 *
 * A local filesystem path, such as
 * `/home/developer/.ignition/fuel/.../model/1/model.sdf` is typically found
 * when parsing object sent from a websocket server.
 *
 * The provided URI is returned if it does not point to the Fuel Server
 * directly.
 *
 * @param {string} uri - A string to convert to a Fuel Server URI, if able.
 * @return The transformed URI, or the same URI if it couldn't be transformed.
 */
export function createFuelUri(uri: string): string {
  // Check if it's already a Fuel URI.
  if (uri.startsWith(`https://${FUEL_HOST}`) || uri.startsWith(`https://${IGN_FUEL_HOST}`)) {
    return uri;
  }

  // Check to see if the uri has the form similar to
  // `/home/.../fuel.gazebosim.org/...`
  // If so, then we assume that the parts following
  // `fuel.gazebosim.org` can be directly mapped to a valid URL on
  // Fuel server.
  if (uri.indexOf(FUEL_HOST) > 0 || uri.indexOf(IGN_FUEL_HOST) > 0) {
    const uriArray = uri.split('/').filter((element: string) => element !== '');
    if (uri.indexOf(FUEL_HOST) > 0) {
      uriArray.splice(0, uriArray.indexOf(FUEL_HOST));
    } else {
      uriArray.splice(0, uriArray.indexOf(IGN_FUEL_HOST));
    }
    uriArray.splice(1, 0, FUEL_VERSION);
    uriArray.splice(6, 0, 'files');
    return 'https://' + uriArray.join('/');
  }

  return uri;
}

export class FuelServer {
  private host: string;
  private version: string;
  private requestHeader = {};

  /**
  * FuelServer is in charge of making requests to the Fuel servers.
  * @param {string} host - The Server host url.
  * @param {string} version - The version used.
  **/
  constructor() {
    this.host = FUEL_HOST;
    this.version = FUEL_VERSION;
    this.requestHeader = {};
  }

  /**
   * Get the list of files a model or world has.
   * @param {string} uri - The uri of the model or world.
   * @param {function} callback - The callback to use once the files are ready.
   */
  public getFiles(uri: string, callback: any): void {
    // Note: jshint is ignored as we use fetch API here instead of a XMLHttpRequest.
    // We still handle the response in a callback.
    // TODO(germanmas): We should update and use async/await instead throughout the library.
    const filesUrl = `${uri.trim()}/tip/files`;

    // Make the request to get the files.
    fetch(filesUrl, { headers: this.requestHeader })
      .then(res => res.json())
      .then(json => {
        const files = prepareURLs(json['file_tree'], filesUrl);
        callback(files);
      })
      .catch(error => console.error(error));

    // Helper function to parse the file tree of the response into an array of
    // file paths. The file tree from the Server consists of file elements
    // that contain a name, a path and children (if they are a folder).
    function prepareURLs(fileTree: any, baseUrl: string): string[] {
      let parsedFiles: string[] = [];

      for (var i = 0; i < fileTree.length; i++) {
        // Avoid the thumbnails folder.
        if (fileTree[i].name === 'thumbnails') {
          continue;
        }

        // Loop through files to extract files from folders.
        extractFile(fileTree[i]);
      }
      return parsedFiles;

      // Helper function to extract the files from the file tree.
      // Folder elements have children, while files don't.
      function extractFile(el: any): void {
        if (!el.children) {
          // Avoid config files as they are not used.
          if (el.name.endsWith('.config')) {
            return;
          }

          var url = baseUrl + el.path;
          parsedFiles.push(url);
        } else {
          for (var j = 0; j < el.children.length; j++) {
            extractFile(el.children[j]);
          }
        }
      }
    }
  }

  /**
   * Set a request header for internal requests.
   *
   * @param {string} header - The header to send in the request.
   * @param {string} value - The value to set to the header.
   */
  public setRequestHeader(header: string, value: string): void {
    this.requestHeader = { [header]: value };
  }
}



---
File: /src/Gamepad.ts
---

let controllers = {};
let onButtonCb: any = null;
let onAxisCb: any = null;

/**
 * Create a gamepad interface
 * @param {function} onButton - Function callback that accepts a controller
 * object and a button object. This function is called when a button is pressed.
 * @param {function} onAxis - Function callback that accepts a controller
 * object and an axis object. This function is called when a joystick axis is moved.
 */
export class Gamepad {

  constructor(onButton: any, onAxis: any) {
    onButtonCb = onButton;
    onAxisCb = onAxis;

    // Listen for gamepad connections.
    window.addEventListener('gamepadconnected', handleGamepadConnect);
    // Listen for gamepad disconnections.
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnect);

    // Start the main processing event loop
    requestAnimationFrame(updateGamepads);
  }
}

/** Main controller processing function. This function is called every
 * animation frame to poll for controller updates.
 */
function updateGamepads() {
  // Scan for connected gamepads.
  scanGamepads();

  // Process each controller
  for (var c in controllers) {
    let controller = controllers[c];

    // Poll each button
    for (let b = 0; b < controller.gamepad.buttons.length; b++) {
      let button = controller.gamepad.buttons[b];

      if (controller.prevButtons[b] !== button.pressed) {
        // Note that we update the button *before* we call the user callback.
        // That's so that the user callback can, at its option, get the complete
        // current state of the controller by looking at the prevButtons.
        controller.prevButtons[b] = button.pressed;

        onButtonCb(controller, {'index': b, 'pressed': button.pressed});
      }
    }

    // Poll each axis
    for (let i = 0; i < controller.gamepad.axes.length; i++) {
      let axis = controller.gamepad.axes[i];
      if (controller.prevAxes[i] !== axis) {
        // Note that we update the axis *before* we call the user callback.
        controller.prevAxes[i] = axis;
        onAxisCb(controller, {'index': i, 'axis': axis});
      }
    }
  }

  requestAnimationFrame(updateGamepads);
}

/**
 * Poll for controllers. Some browsers use connection events, and others
 * require polling.
 */
function scanGamepads(): void {
  var gamepads = navigator.getGamepads();
  for (var i = 0; i < gamepads.length; i++) {
    addGamepad(gamepads[i]);
  }
}

/** Adds or updates a gamepad to the list of controllers.
 * @param {object} The gamepad to add/update
 */
function addGamepad(gamepad: any): void {
  if (gamepad) {
    if (!(gamepad.index in controllers)) {
      console.log('Adding gamepad', gamepad.id);
      controllers[gamepad.index] = {
        gamepad: gamepad,
        prevButtons: new Array(gamepad.buttons.length),
        prevAxes: new Array(gamepad.axes.length)
      };

      // Set button initial state
      for (var b = 0; b < gamepad.buttons.length; b++) {
        controllers[gamepad.index].prevButtons[b] = false;
      }

      // Set axes initial state
      for (var a = 0; a < gamepad.axes.length; a++) {
        controllers[gamepad.index].prevAxes[a] = 0.0;
      }
    } else {
      controllers[gamepad.index].gamepad = gamepad;
    }
  }
}

/** Removes a gamepad from the list of controllers
 * @param {object} The gamepad to remove
 */
function removeGamepad(gamepad: any) {
  if (gamepad && gamepad.index in controllers) {
    delete controllers[gamepad.index];
  }
}

/** Gamepad connect callback handler
 * @param {event} The gamepad connect event.
 */
function handleGamepadConnect(e: any): void {
  addGamepad(e.gamepad);
}

/** Gamepad disconnect callback handler
 * @param {event} The gamepad disconnect event.
 */
function handleGamepadDisconnect(e: any): void {
  removeGamepad(e.gamepad);
}



---
File: /src/Globals.ts
---

import {Object3D} from 'three';

/**
 * Given a ThreeJS Object, return all its children as an array.
 * Notes:
 * - We are using getDescendants as a way to maintain legacy code. We should use traverse() whenever possible.
 * - We should discourage its use and move towards using traverse().
 * @param obj The ThreeJS Object to get the descendants of.
 * @param array Optional. An array that will store all the children.
 * @returns An array of the children of the given ThreeJS Object (can be dismissed if the array argument is used).
 */
export function getDescendants(obj: Object3D, array: Object3D[] = []): Object3D[] {
  obj.traverse((child) => {
    // Note: This function is called on the obj as well.
    // Since we just need its children, we filter the original object.
    if (child !== obj) {
      array.push(child);
    }
  });
  return array;
};

/**
 * Convert a binary byte array to a base64 string.
 * @param {byte array} buffer - Binary byte array
 * @return Base64 encoded string.
 **/
export function binaryToBase64(buffer: Uint8Array): string {
  var binary = '';
  var len = buffer.byteLength;
  for (var i = 0; i < len; i++) {
    binary += String.fromCharCode(buffer[i]);
  }
  return window.btoa(binary);
};

/**
 * Convert a RGBA encoded uint8array to an image.
 * @param {byte array} array - Binary byte array encoded as RGBA pixels.
 * @param {number} width - Width of the image in pixels
 * @param {number} height - Height of the image in pixels
 */
export function binaryToImage(array: Uint8Array, width: number, height: number): HTMLImageElement {

  // Create the clamped data array
  let imageArray = new Uint8ClampedArray(array.buffer);

  // Create the image data
  let imageData = new ImageData(imageArray, width, height);

  // Create the canvas
  let canvas = document.createElement('canvas');
  let ctx = canvas.getContext('2d');
  canvas.width = imageData.width;
  canvas.height = imageData.height;

  // Draw the image
  ctx!.putImageData(imageData, 0, 0);

  // Create the image, and grabe the URL of the canvas image
  let imageElem = new Image();
  imageElem.src = canvas.toDataURL();

  return imageElem;
}



---
File: /src/GzObjLoader.ts
---

import { getDescendants } from './Globals';
import { Scene } from './Scene';
import { FileLoader, Group, Material, Mesh, Object3D } from 'three';
import { OBJLoader } from '../include/OBJLoader';
import { MTLLoader, MaterialCreator } from '../include/MTLLoader';

export class GzObjLoader {
  private scene: Scene;
  private submesh: string;
  private centerSubmesh: boolean;
  private findResourceCb: any;
  private onLoad: any;
  private uri: string = '';
  private baseUrl: string = '';
  private files: string[] = [];
  private usingRawFiles: boolean = false;
  private objLoader: OBJLoader = new OBJLoader();
  private mtlLoader: MTLLoader = new MTLLoader();
  private container: Group;

  /**
   * Load OBJ meshes
   *
   * @constructor
   *
   * @param {Scene} _scene - The scene to load into
   * @param {string} _uri - mesh uri which is used by mtlloader and the objloader
   * to load both the mesh file and the mtl file using XMLHttpRequests.
   * @param {} _submesh
   * @param {} _centerSubmesh
   * @param {function(resource)} _findResourceCb - A function callback that can be used to help
   * @param {function} _onLoad
   * @param {array} _files -optional- the obj [0] and the mtl [1] files as strings
   * to be parsed by the loaders, if provided the uri will not be used just
   * as a url, no XMLHttpRequest will be made.
   */
  constructor(_scene: Scene, _uri: string, _submesh: string,
    _centerSubmesh: boolean, _findResourceCb: any,
    _onLoad: any, _onError: any, _files?: string[]) {
    // Keep parameters
    this.scene = _scene;
    this.submesh = _submesh;
    this.centerSubmesh = _centerSubmesh;
    this.findResourceCb = _findResourceCb;
    this.onLoad = _onLoad;
    this.uri = _uri;
    if (_files) {
      this.files = _files!;

      // True if raw files were provided
      this.usingRawFiles = this.files.length === 2 &&
                           this.files[0] !== undefined &&
                           this.files[1] !== undefined;
    }
  
 
    // Loaders
    this.mtlLoader.setCrossOrigin('');
  
    if (this.scene.requestHeader) {
      this.objLoader.setRequestHeader(this.scene.requestHeader);
      this.mtlLoader.setRequestHeader(this.scene.requestHeader);
    }
  
    // Assume .mtl is in the same path as .obj
    if (!this.usingRawFiles)
    {
      var baseUrl = this.uri.substr(0, this.uri.lastIndexOf('/') + 1);
      this.mtlLoader.setResourcePath(baseUrl);
      this.mtlLoader.setPath(baseUrl);
    }
  }

  /**
   * Load Obj file
   */
  public load(): void {
    var that = this;
  
    // If no raw files are provided, make HTTP request
    if (!this.usingRawFiles) {
      this.objLoader.load(this.uri,
        // onLoad
        function(_container: Group) {
          that.onObjLoaded(_container);
        },
        // onProgres
        function(_progress: any) {
          // Ignore
        },
        function(_error: any) {
          // Use the find resource callback to get the mesh
          that.findResourceCb(that.uri, function(mesh: any) {
            that.onObjLoaded(that.objLoader.parse(mesh));
          });
        }
      );
    }
    // Otherwise load from raw file
    else
    {
      var container = this.objLoader.parse(this.files[0]);
      this.onObjLoaded(container);
    }
  }

  /**
   * Callback when loading is successfully completed
   */
  private loadComplete()
  {
    let obj: Group = this.container;
    this.scene.meshes[this.uri] = obj;
    obj = obj.clone();
    this.scene.useSubMesh(obj, this.submesh, this.centerSubmesh);
  
    obj.name = this.uri;
    this.onLoad(obj);
  }

  /**
   * Callback when loading is successfully completed
   * @param {MTLLoaderMaterialCreator} _mtlCreator - Returned by MTLLoader.parse
   */
  private applyMaterial(_mtlCreator: MaterialCreator) {
    let allChildren: Object3D[] = [];
    getDescendants(this.container, allChildren);
  
    for (let j = 0; j < allChildren.length; ++j)
    {
      let child: Object3D = allChildren[j];
      if (child && child.hasOwnProperty('material')) {
        let childMesh: Mesh = <Mesh>child;
        if ((<Material>childMesh.material).name) {
          childMesh.material = _mtlCreator.create(
            (<Material>childMesh.material).name);
        } else if (Array.isArray(childMesh.material)) {
          for (var k = 0; k < childMesh.material.length; ++k) {
            childMesh.material[k] = _mtlCreator.create(
              childMesh.material[k].name);
          }
        }
      }
    }
  
    this.loadComplete();
  }

  /**
   * Callback when raw .mtl file has been loaded
   *
   * Assumptions:
   *     * Both .obj and .mtl files are under the /meshes dir
   *     * Textures are under the /materials/textures dir
   *
   * Three texture filename patterns are handled. A single .mtl file may
   * have instances of all of these.
   * 1. Path relative to the meshes folder, which should always start with
   *    ../materials/textures/
   * 2. Gazebo URI in the model:// format, referencing another model
   *    in the same path as the one being loaded
   * 2. Just the image filename without a path
   * @param {string} _text - MTL file as string
   */
  private loadMTL(_text: string) {
    if (!_text) {
      return;
    }
  
    // Handle model:// URI
    if (_text.indexOf('model://') > 0) {
      // If there's no path, remove model://
      if (!this.mtlLoader.path || this.mtlLoader.path.length === 0) {
        _text = _text.replace(/model:\/\//g, '');
      } else if (this.mtlLoader.path.indexOf('/meshes/') < 0) {
        console.error('Failed to resolve texture URI. MTL file directory [' +
            this.mtlLoader.path +
            '] not supported, it should be in a /meshes directory');
        console.error(_text);
        return;
      } else {
        // Get models path from .mtl file path
        // This assumes the referenced model is in the same path as the model
        // being loaded. So this may fail if there are models being loaded
        // from various paths
        var path = this.mtlLoader.path;
        path = path.substr(0, path.lastIndexOf('/meshes'));
        path = path.substr(0, path.lastIndexOf('/') + 1);
  
        // Search and replace
        _text = _text.replace(/model:\/\//g, path);
      }
    }
  
    // Handle case in which the image filename is given without a path
    // We expect the texture to be under /materials/textures
    var lines = _text.split('\n');
  
    if (lines.length === 0) {
      console.error('Empty or no MTL file');
      return;
    }
  
    var newText = '';
    for (var i in lines) {
      var line = lines[i];
  
      if (line === undefined || line.indexOf('#') === 0) {
        continue;
      }
  
      // Skip lines without texture filenames
      if (line.indexOf('map_Ka') < 0 && line.indexOf('map_Kd') < 0) {
        newText += line += '\n';
        continue;
      }
  
      // Skip lines which already have /materials/textures
      if (line.indexOf('/materials/textures') > 0 && !this.usingRawFiles) {
        newText += line += '\n';
        continue;
      }
  
      // Remove ../ from raw files
      if (line.indexOf('../materials/textures') > 0 && this.usingRawFiles) {
        line = line.replace('../', '');
        newText += line += '\n';
        continue;
      }
  
      // Add path to filename
      var p = this.mtlLoader.path || '';
      p = p.substr(0, p.lastIndexOf('meshes'));
  
      line = line.replace('map_Ka ', 'map_Ka ' + p + 'materials/textures/');
      line = line.replace('map_Kd ', 'map_Kd ' + p + 'materials/textures/');
  
      newText += line += '\n';
    }
  
    this.applyMaterial(this.mtlLoader.parse(newText, null));
  }

  /**
   * Callback when OBJ file has been loaded, proceeds to load MTL.
   * @param {obj} _container - Loaded OBJ.
   */
  private onObjLoaded(_container: Group) {
    this.container = _container;
  
    // Callback when MTL has been loaded
    // Linter doesn't like `that` being used inside a loop, so we move it outside
    var that = this;

    if ((this.container as any).materialLibraries.length === 0) {
      // return if there are no materials to be applied
      this.loadComplete();
      return;
    }
  
    // Load all MTL files
    if (!this.usingRawFiles) {
      for (var i=0; i < (this.container as any).materialLibraries.length; ++i) {
        // Load raw .mtl file
        let mtlPath: string = (this.container as any).materialLibraries[i];
  
        var fileLoader = new FileLoader(this.mtlLoader.manager);
        fileLoader.setPath(this.mtlLoader.path);
        fileLoader.setRequestHeader(this.mtlLoader.requestHeader);
        fileLoader.load(mtlPath, 
                        // onLoad
                        function(_text: string | ArrayBuffer) {
                          if (typeof _text === 'string') { 
                            that.loadMTL(_text as string);
                          } else {
                            console.error('Unable to load file', mtlPath);
                          }
                        });
      }
    }
    // Use provided MTL file
    else {
      this.loadMTL(this.files[1]);
    }
  }
}



---
File: /src/gzweb.js
---

export { Asset } from './Asset';
export { AssetViewer, AssetViewerConfig } from './AssetViewer'
export { AudioTopic } from './AudioTopic';
export { Color } from './Color';
export { FuelServer } from './FuelServer';
export { Gamepad } from './Gamepad';
export { Inertia } from './Inertia';
export { Material } from './Material';
export { ModelUserData } from './ModelUserData';
export { PBRMaterial } from './PBRMaterial';
export { Pose } from './Pose';
export { Publisher } from './Publisher';
export { Scene } from './Scene';
export { SceneManager, SceneManagerConfig } from './SceneManager';
export { SDFParser } from './SDFParser';
export { Topic } from './Topic';
export { Transport } from './Transport';
export * from './Globals';

var gzweb = gzweb || {
  REVISION : '2'
};

// Assuming all mobile devices are touch devices.
var isTouchDevice = /Mobi/.test(navigator.userAgent);



---
File: /src/Inertia.ts
---

export class Inertia {
  public ixx: number;
  public ixy: number;
  public ixz: number;
  public iyy: number;
  public iyz: number;
  public izz: number;
}



---
File: /src/Material.ts
---

import {Color} from './Color';
import {PBRMaterial} from './PBRMaterial';

export class Material {
  public texture: string = '';
  public normalMap: string = '';
  public ambient: Color | undefined;
  public diffuse: Color | undefined;
  public specular: Color | undefined;
  public opacity: number = 1.0;
  public scale: number = 1.0;
  public pbr: PBRMaterial;
}



---
File: /src/ModelUserData.ts
---

export class ModelUserData {
  public viewAs: string = 'normal';
}



---
File: /src/PBRMaterial.ts
---

export class PBRMaterial {
  public albedoMap: string = '';
  public normalMap: string = '';
  public metalness: number = 0;
  public metalnessMap: string = '';
  public roughness: number = 0;
  public roughnessMap: string = '';
  public glossiness: number = 0;
  public glossinessMap: string = '';
  public specularMap: string = '';
  public environmentMap: string = '';
  public emissiveMap: string = '';
  public lightMap: string = '';
  public lightMapTexcoordSet: number = 0;
  public ambientOcclusionMap: string = '';
}



---
File: /src/Pose.ts
---

import {Vector3, Quaternion} from 'three'; 

export class Pose {
  public position: Vector3 = new Vector3();
  public orientation: Quaternion = new Quaternion();

  constructor (pos?: Vector3, rot?: Quaternion) {
    if (pos) {
      this.position = pos;
    }

    if (rot) {
      this.orientation = rot;
    }
  }
}



---
File: /src/Publisher.ts
---

import { Message, Type } from 'protobufjs';

/**
 * A Publisher is used to allow clients to publish messages to a particular topic.
 */
export class Publisher {
  /**
   * The name of the topic.
   */
  public topic: string;

  /**
   * Message type name.
   */
  public msgTypeName: string;

  /**
   * The Protobuf message definition.
   */
  private messageDef: Type;

  /**
   * Function used to publish a message. This acts as a pass through to
   * Transport.
   */
  private pubFunc: (topic: string, msgTypeName: string, msg: string) => void;

  /**
   * This constructor should be called by Transport.
   *
   * @param topic The topic name to publish to.
   * @param msgTypeName The message type name to use.
   * @param def The protobuf message definition.
   * @param pub Function set by Transport in order to send the message through the websocket.
   */
  constructor(
    topic: string,
    msgTypeName: string,
    def: Type,
    pub: (topic: string, msgTypeName: string, msg: string) => void
  ) {
    this.topic = topic;
    this.msgTypeName = msgTypeName;
    this.messageDef = def;
    this.pubFunc = pub;
  }

  /**
   * Creates a new message using the specified properties.
   *
   * @param properties The propoerties to be set in the message.
   * @returns The message instance.
   */
  public createMessage(properties: any): Message {
    return this.messageDef.create(properties);
  }

  /**
   * Publish a message.
   *
   * @param msg The message to publish.
   */
  public publish(msg: Message): void {
    // Serialized the message
    let buffer = this.messageDef.encode(msg).finish();
    let strBuf = new TextDecoder().decode(buffer);

    // Publish the message over the websocket
    this.pubFunc(this.topic, this.msgTypeName, strBuf);
  }
}



---
File: /src/Scene.ts
---

import * as THREE from 'three';

// @ts-ignore
import NebulaSystem, { SpriteRenderer } from 'three-nebula';
import { getDescendants, binaryToImage } from './Globals';
import { ColladaLoader } from '../include/ColladaLoader';
import { Color } from './Color';
import { DDSLoader } from '../include/DDSLoader';
import { EventEmitter2 } from 'eventemitter2';
import { GzObjLoader } from './GzObjLoader';
import { ModelUserData } from './ModelUserData';
import { OrbitControls } from '../include/OrbitControls';

import { createFuelUri } from './FuelServer';
import { Pose } from './Pose';
import { SDFParser } from './SDFParser';
import { Shaders } from './Shaders';
import { SpawnModel } from './SpawnModel';
import { STLLoader } from '../include/STLLoader';
import { WsLoadingManager } from './WsLoadingManager';

import * as JSZip from 'jszip';

export type FindResourceCb = (uri: string, cb: any) => void;

enum JointTypes {
  REVOLUTE = 1,
  REVOLUTE2 = 2,
  PRISMATIC = 3,
  UNIVERSAL = 4,
  BALL = 5,
  SCREW = 6,
  GEARBOX = 7,
  FIXED = 8
}

/**
 * Interface of arguments for the Scene's constructor.
 */
export interface SceneConfig {
  shaders: Shaders;
  defaultCameraPosition?: THREE.Vector3;
  defaultCameraLookAt?: THREE.Vector3;
  backgroundColor?: THREE.Color;
  findResourceCb?: FindResourceCb;
}

/**
 * The scene is where everything is placed, from objects, to lights and cameras.
 *
 * Supports radial menu on an orthographic scene when gzradialmenu.js has been
 * included (useful for mobile devices).
 *
 * @param shaders Shaders instance, if not provided, custom shaders will
 *                not be set.
 * @param defaultCameraPosition THREE.Vector3 Default, and starting, camera
 *                              position. A value of [0, -5, 5] will be used
 *                              if this is undefined.
 * @param defaultCameraLookAt THREE.Vector3 Default, and starting, camera
 *                            lookAt position. A value of [0, 0, 0] will
 *                            be used if this is undefined.
 * @param backgroundColor THREE.Color The background color. A value of
 *                        0xb2b2b2 will be used if undefined.
 *
 * @param {function(resource)} findResourceCb - A function callback that can be used to help
 * @constructor
 */
export class Scene {
  public meshes: Map<string, THREE.Mesh> = new Map<string,THREE.Mesh>();
  public showCollisions: boolean = false;
  public textureLoader: THREE.TextureLoader;
  public requestHeader: any;
  public scene: THREE.Scene;
  public camera: THREE.PerspectiveCamera;

  private name: string;
  private emitter: EventEmitter2;
  private shaders: Shaders;
  private findResourceCb: FindResourceCb | undefined;
  private defaultCameraPosition: THREE.Vector3;
  private defaultCameraLookAt: THREE.Vector3;
  private backgroundColor: THREE.Color;
  private selectEntityEvent: string;
  private followEntityEvent: string;
  private moveToEntityEvent: string;
  private thirdPersonFollowEntityEvent: string;
  private firstPersonEntityEvent: string;
  private cameraMode: string;
  private sceneOrtho: THREE.Scene;
  private cameraOrtho: THREE.OrthographicCamera;
  private cameraSlerpStart: THREE.Quaternion;
  private cameraSlerpEnd: THREE.Quaternion;
  private cameraLerpStart: THREE.Vector3;
  private cameraLerpEnd: THREE.Vector3;

  // Object the camera should track.
  private cameraTrackObject: THREE.Object3D;
  private pointerOnMenu: boolean;
  private grid: THREE.GridHelper;
  private renderer: THREE.WebGLRenderer;
  private nebulaSystem: NebulaSystem;
  private nebulaRenderer: SpriteRenderer;
  private cameraMoveToClock: THREE.Clock;
  private colladaLoader: ColladaLoader;
  private ddsLoader: DDSLoader;
  private stlLoader: STLLoader;
  private heightmap: any;
  private selectedEntity: any;
  private manipulationMode: string;
  private ambient: THREE.AmbientLight;
  private jointAxis: THREE.Object3D;
  private boundingBox: THREE.LineSegments;
  private controls: OrbitControls;
  private COMvisual: THREE.Object3D;
  private ray: THREE.Raycaster;
  private simpleShapesMaterial: THREE.MeshPhongMaterial;
  private spawnModel: SpawnModel;
  private COMVisual: THREE.Object3D = new THREE.Object3D;
  private textureCache = new Map<string, THREE.Texture>();
  private currentThirdPersonLookAt = new THREE.Vector3();
  private defaultThirdPersonCameraOffset: THREE.Vector3 = new THREE.Vector3(-6, -2, 1.5);
  private currentThirdPersonCameraOffset: THREE.Vector3 = new THREE.Vector3();
  private mousePointerDown: boolean = false;
  private currentFirstPersonLookAt = new THREE.Vector3();

  constructor(config: SceneConfig) {
    this.emitter = new EventEmitter2({verboseMemoryLeak: true});
    this.shaders = config.shaders;
    if (config.findResourceCb) {
      this.findResourceCb = config.findResourceCb;
    }

    // This matches Gazebo's default camera position
    this.defaultCameraPosition = new THREE.Vector3(-6, 0, 6);
    if (config.defaultCameraPosition) {
      this.defaultCameraPosition.copy(config.defaultCameraPosition);
    }

    this.defaultCameraLookAt = new THREE.Vector3(0, 0, 0);
    if (config.defaultCameraLookAt) {
      this.defaultCameraLookAt.copy(config.defaultCameraLookAt);
    }

    this.backgroundColor = new THREE.Color(0xb2b2b2);
    if (config.backgroundColor) {
      this.backgroundColor.copy(config.backgroundColor);
    }

    this.init();

    /**
     * @member {string} selectEntity
     * The select entity event name.
     */
    this.selectEntityEvent = 'select_entity';

    /**
     * @member {string} followEntity
     * The follow entity event name.
     */
    this.followEntityEvent = 'follow_entity';

    /**
     * @member {string} moveToEntity
     * The move to entity event name.
     */
    this.moveToEntityEvent = 'move_to_entity';

    /**
     * @member {string} thirdPersonFollowEntity
     * The third-person follow entity event name.
     */
    this.thirdPersonFollowEntityEvent = 'third_person_follow_entity';

    /**
     * @member {string} firstPersonEntity
     * The first-person camera entity event name.
     */
    this.firstPersonEntityEvent = 'first_person_entity';

    var that = this;

    /**
     * Handle entity selection signal ('select_entity').
     * @param {string} entityName The name of the entity to select.
     */
    this.emitter.on(this.selectEntityEvent, function(entityName) {
      var object = that.scene.getObjectByName(entityName);
      if (object !== undefined && object !== null) {
        that.selectEntity(object);
      }
    });

    /**
     * Handle the follow entity follow signal ('follow_entity').
     * @param {string} entityName Name of the entity. Pass in null or an empty
     * string to stop following.
     */
    this.emitter.on(this.followEntityEvent, function(entityName) {

      // Turn off following if `entity` is null.
      if (entityName === undefined || entityName === null) {
        that.cameraMode = '';
        return;
      }

      var object = that.scene.getObjectByName(entityName);

      if (object !== undefined && object !== null) {
        // Set the object to track.
        that.cameraTrackObject =  object;

        // Set the camera mode.
        that.cameraMode = that.followEntityEvent;
      }
    });

    /**
     * Handle the third-person follow entity signal ('third_person_follow_entity').
     * @param {string} entityName Name of the entity. Pass in null or an empty
     * string to stop third-person following.
     */
    this.emitter.on(this.thirdPersonFollowEntityEvent, function(entityName) {

      // Turn off following if `entity` is null.
      if (entityName === undefined || entityName === null) {
        that.cameraMode = '';
        return;
      }

      var object = that.scene.getObjectByName(entityName);

      if (object !== undefined && object !== null) {
        // Set the object to track.
        that.cameraTrackObject =  object;

        // Set the camera offset to the default one.
        that.currentThirdPersonCameraOffset.copy(that.defaultThirdPersonCameraOffset);

        // Set the camera mode.
        that.cameraMode = that.thirdPersonFollowEntityEvent;
      }
    });

    /**
     * Handle the first-person entity signal ('first_person_entity').
     * @param {string} entityName Name of the entity. Pass in null or an empty
     * string to stop first-person following.
     */
    this.emitter.on(this.firstPersonEntityEvent, function(entityName) {

      // Turn off following if `entity` is null.
      if (entityName === undefined || entityName === null) {
        that.cameraMode = '';
        return;
      }

      var object = that.scene.getObjectByName(entityName);

      if (object !== undefined && object !== null) {
        // Set the object to track.
        that.cameraTrackObject =  object;

        // Set the camera mode.
        that.cameraMode = that.firstPersonEntityEvent;
      }
    });

    /**
     * Handle move to entity signal ('move_to_entity').
     * @param {string} entityName: Name of the entity.
     */
    this.emitter.on(this.moveToEntityEvent, function(entityName) {
      var obj = that.scene.getObjectByName(entityName);
      if (obj === undefined || obj === null) {
        return;
      }

      // Starting position of the camera.
      var startPos = new THREE.Vector3();
      that.camera.getWorldPosition(startPos);

      // Center of the target to move to.
      var targetCenter = new THREE.Vector3();
      obj.getWorldPosition(targetCenter);

      // Calculate  direction from start to target
      var dir = new THREE.Vector3();
      dir.subVectors(targetCenter, startPos);
      dir.normalize();

      // Distance from start to target.
      var dist = startPos.distanceTo(targetCenter);

      // Get the bounding box size of the target object.
      var bboxSize = new THREE.Vector3();
      var bbox = new THREE.Box3().setFromObject(obj);
      bbox.getSize(bboxSize);
      var max = Math.max(bboxSize.x, bboxSize.y, bboxSize.z);

      // Compute an offset such that the object's bounding box will fix in the
      // view. I've padded this out a bit by multiplying `max` by 0.75 instead
      // of 0.5
      var offset = (max * 0.75) / Math.tan((that.camera.fov * Math.PI/180.0) / 2.0);
      var endPos = dir.clone().multiplyScalar(dist-offset);
      endPos.add(startPos);

      // Make sure that the end position is above the object so that the
      // camera will look down at it.
      if (endPos.z <= (targetCenter.z + max)) {
        endPos.z += max;
      }

      // Compute the end orientation.
      var endRotMat = new THREE.Matrix4();
      endRotMat.lookAt(endPos, targetCenter, new THREE.Vector3(0, 0, 1));

      // Start the camera moving.
      that.cameraMode = that.moveToEntityEvent;
      that.cameraMoveToClock.start();
      that.cameraLerpStart.copy(startPos);
      that.cameraLerpEnd.copy(endPos);
      that.camera.getWorldQuaternion(that.cameraSlerpStart);
      that.cameraSlerpEnd.setFromRotationMatrix(endRotMat);
    });
  }

  /**
   * Initialize scene
   */
  public init(): void {
    THREE.Object3D.DefaultUp.set(0, 0, 1)
    this.name = 'default';
    this.scene = new THREE.Scene();
    // this.scene.name = this.name;

    // only support one heightmap for now.
    this.heightmap = null;

    this.selectedEntity = null;

    this.manipulationMode = 'view';
    this.pointerOnMenu = false;

    // loaders
    this.textureLoader = new THREE.TextureLoader();
    this.textureLoader.crossOrigin = '';
    this.colladaLoader = new ColladaLoader();
    this.stlLoader = new STLLoader();
    this.ddsLoader = new DDSLoader();

    // Progress and Load events.
    const progressEvent = (url: string , items: number, total: number) => {
      this.emitter.emit('load_progress', url, items, total);
    };

    const loadEvent = () => {
      this.emitter.emit('load_finished');
    }

    // Set the right loading manager for handling websocket assets.
    if (this.findResourceCb) {
      const wsLoadingManager = new WsLoadingManager(loadEvent, progressEvent);

      // Collada Loader uses the findResourceCb internally.
      this.colladaLoader.findResourceCb = this.findResourceCb;

      this.textureLoader.manager = wsLoadingManager;
      this.colladaLoader.manager = wsLoadingManager;
      this.stlLoader.manager = wsLoadingManager;
      this.ddsLoader.manager = wsLoadingManager;
    }

    this.textureLoader.manager.onProgress = progressEvent;
    this.colladaLoader.manager.onProgress = progressEvent;
    this.stlLoader.manager.onProgress = progressEvent;
    this.ddsLoader.manager.onProgress = progressEvent;

    this.textureLoader.manager.onLoad = loadEvent;
    this.colladaLoader.manager.onLoad = loadEvent;
    this.stlLoader.manager.onLoad = loadEvent;

    this.renderer = new THREE.WebGLRenderer({antialias: true});
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setClearColor(this.backgroundColor);
    this.renderer.autoClear = false;
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    // Particle group to render.

    // Add a default ambient value. This is equivalent to
    // {r: 0.1, g: 0.1, b: 0.1}.
    this.ambient = new THREE.AmbientLight( 0x191919 );
    this.scene.add(this.ambient);

    // camera
    let width: number = this.getDomElement().width;
    let height: number = this.getDomElement().height;
    this.camera = new THREE.PerspectiveCamera(60, width / height, 0.01, 1000);
    this.resetView();

    // Clock used to time the camera 'move_to' motion.
    this.cameraMoveToClock = new THREE.Clock(false);

    // Start position of the camera's move_to
    this.cameraLerpStart = new THREE.Vector3();
    // End position of the camera's move_to
    this.cameraLerpEnd = new THREE.Vector3();
    // Start orientation of the camera's move_to
    this.cameraSlerpStart = new THREE.Quaternion();
    // End orientation of the camera's move_to
    this.cameraSlerpEnd = new THREE.Quaternion();

    // Current camera mode. Empty indicates standard orbit camera.
    this.cameraMode = '';

    // Ortho camera and scene for rendering sprites
    // Currently only used for the radial menu
    /*if (typeof RadialMenu === 'function')
    {
      this.cameraOrtho = new THREE.OrthographicCamera(-width * 0.5, width * 0.5,
          height*0.5, -height*0.5, 1, 10);
      this.cameraOrtho.position.z = 10;
      this.sceneOrtho = new THREE.Scene();

      // Radial menu (only triggered by touch)
      // this.radialMenu = new RadialMenu(this.getDomElement());
      // this.sceneOrtho.add(this.radialMenu.menu);
    }*/

    // Grid
    this.grid = new THREE.GridHelper(20, 20, 0xCCCCCC, 0x4D4D4D);
    this.grid.name = 'grid';
    this.grid.position.z = 0.05;
    this.grid.rotation.x = Math.PI * 0.5;
    this.grid.castShadow = false;
    (<THREE.Material>this.grid.material).transparent = true;
    (<THREE.Material>this.grid.material).opacity = 0.5;
    this.grid.visible = false;
    this.scene.add(this.grid);

    this.showCollisions = false;

    this.spawnModel = new SpawnModel(this, this.getDomElement());

    this.simpleShapesMaterial = new THREE.MeshPhongMaterial(
        {color:0xffffff, flatShading: false} );

    var that = this;

    // Only capture events inside the webgl div element.
    this.getDomElement().addEventListener( 'mouseup',
        function(event: MouseEvent) {that.onPointerUp(event);}, false );

    this.getDomElement().addEventListener( 'mousedown',
        function(event: MouseEvent) {that.onPointerDown(event);}, false );

    this.getDomElement().addEventListener( 'wheel',
        function(event: MouseEvent) {that.onMouseScroll(event);}, false );

    /*this.getDomElement().addEventListener( 'touchstart',
        function(event: TouchEvent) {that.onPointerDown(event);}, false );

    this.getDomElement().addEventListener( 'touchend',
        function(event: TouchEvent) {that.onPointerUp(event);}, false );
       */

    // Handles for translating and rotating objects
    //this.modelManipulator = new Manipulator(this.camera, false,
    //    this.getDomElement());

    // this.timeDown = null;

    // Create a ray caster
    this.ray = new THREE.Raycaster();

    this.controls = new OrbitControls(this.camera,
        this.getDomElement());
    this.controls.mouseButtons = {
      LEFT: THREE.MOUSE.PAN,
      MIDDLE: THREE.MOUSE.ROTATE,
      RIGHT: THREE.MOUSE.DOLLY
    };
    // an animation loop is required with damping
    this.controls.enableDamping = false;
    this.controls.screenSpacePanning = true;

    // Bounding Box
    var indices = new Uint16Array(
        [ 0, 1, 1, 2, 2, 3, 3, 0,
          4, 5, 5, 6, 6, 7, 7, 4,
          0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array(8 * 3);
    var boxGeometry = new THREE.BufferGeometry();
    boxGeometry.setIndex(new THREE.BufferAttribute( indices, 1 ));
    boxGeometry.setAttribute( 'position',
        new THREE.BufferAttribute(positions, 3));
    this.boundingBox = new THREE.LineSegments(boxGeometry,
        new THREE.LineBasicMaterial({color: 0xffffff}));

    this.boundingBox.visible = false;

    // Joint visuals
    this.jointAxis = new THREE.Object3D();
    this.jointAxis.name = 'JOINT_VISUAL';
    var geometry, material, mesh;

    // XYZ
    var XYZaxes = new THREE.Object3D();

    geometry = new THREE.CylinderGeometry(0.01, 0.01, 0.3, 10, 1, false);

    material = new THREE.MeshBasicMaterial({color: new THREE.Color(0xff0000)});
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0.15;
    mesh.rotation.z = -Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    XYZaxes.add(mesh);

    material = new THREE.MeshBasicMaterial({color: new THREE.Color(0x00ff00)});
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = 0.15;
    mesh.name = 'JOINT_VISUAL';
    XYZaxes.add(mesh);

    material = new THREE.MeshBasicMaterial({color: new THREE.Color(0x0000ff)});
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = 0.15;
    mesh.rotation.x = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    XYZaxes.add(mesh);

    geometry = new THREE.CylinderGeometry(0, 0.03, 0.1, 10, 1, true);

    material = new THREE.MeshBasicMaterial({color: new THREE.Color(0xff0000)});
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0.3;
    mesh.rotation.z = -Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    XYZaxes.add(mesh);

    material = new THREE.MeshBasicMaterial({color: new THREE.Color(0x00ff00)});
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = 0.3;
    mesh.name = 'JOINT_VISUAL';
    XYZaxes.add(mesh);

    material = new THREE.MeshBasicMaterial({color: new THREE.Color(0x0000ff)});
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = 0.3;
    mesh.rotation.x = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    XYZaxes.add(mesh);

    this.jointAxis['XYZaxes'] = XYZaxes;

    var mainAxis = new THREE.Object3D();

    material = new THREE.MeshLambertMaterial();
    material.color = new THREE.Color(0xffff00);

    var mainAxisLen = 0.3;
    geometry = new THREE.CylinderGeometry(0.015, 0.015, mainAxisLen, 36, 1,
        false);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = mainAxisLen * 0.5;
    mesh.rotation.x = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    mainAxis.add(mesh);

    geometry = new THREE.CylinderGeometry(0, 0.035, 0.1, 36, 1, false);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = mainAxisLen;
    mesh.rotation.x = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    mainAxis.add(mesh);

    this.jointAxis['mainAxis'] = mainAxis;

    var rotAxis = new THREE.Object3D();

    geometry = new THREE.TorusGeometry(0.04, 0.006, 10, 36, Math.PI * 3/2);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = mainAxisLen;
    mesh.name = 'JOINT_VISUAL';
    rotAxis.add(mesh);

    geometry = new THREE.CylinderGeometry(0.015, 0, 0.025, 10, 1, false);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = -0.04;
    mesh.position.z = mainAxisLen;
    mesh.rotation.z = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    rotAxis.add(mesh);

    this.jointAxis['rotAxis'] = rotAxis;

    var transAxis = new THREE.Object3D();

    geometry = new THREE.CylinderGeometry(0.01, 0.01, 0.1, 10, 1, true);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0.03;
    mesh.position.y = 0.03;
    mesh.position.z = mainAxisLen * 0.5;
    mesh.rotation.x = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    transAxis.add(mesh);

    geometry = new THREE.CylinderGeometry(0.02, 0, 0.0375, 10, 1, false);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0.03;
    mesh.position.y = 0.03;
    mesh.position.z = mainAxisLen * 0.5 + 0.05;
    mesh.rotation.x = -Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    transAxis.add(mesh);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0.03;
    mesh.position.y = 0.03;
    mesh.position.z = mainAxisLen * 0.5 - 0.05;
    mesh.rotation.x = Math.PI/2;
    mesh.name = 'JOINT_VISUAL';
    transAxis.add(mesh);

    this.jointAxis['transAxis'] = transAxis;

    var screwAxis = new THREE.Object3D();

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = -0.04;
    mesh.position.z = mainAxisLen - 0.11;
    mesh.rotation.z = -Math.PI/4;
    mesh.rotation.x = -Math.PI/10;
    mesh.name = 'JOINT_VISUAL';
    screwAxis.add(mesh);

    var radius = 0.04;
    var length = 0.02;
    var curve = new THREE.CatmullRomCurve3(
        [new THREE.Vector3(radius, 0, 0*length),
        new THREE.Vector3(0, radius, 1*length),
        new THREE.Vector3(-radius, 0, 2*length),
        new THREE.Vector3(0, -radius, 3*length),
        new THREE.Vector3(radius, 0, 4*length),
        new THREE.Vector3(0, radius, 5*length),
        new THREE.Vector3(-radius, 0, 6*length)]);
    geometry = new THREE.TubeGeometry(curve, 36, 0.01, 10, false);

    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = mainAxisLen - 0.23;
    mesh.name = 'JOINT_VISUAL';
    screwAxis.add(mesh);

    this.jointAxis['screwAxis'] = screwAxis;

    var ballVisual = new THREE.Object3D();

    geometry = new THREE.SphereGeometry(0.06);

    mesh = new THREE.Mesh(geometry, material);
    mesh.name = 'JOINT_VISUAL';
    ballVisual.add(mesh);

    this.jointAxis['ballVisual'] = ballVisual;

    // center of mass visual
    this.COMvisual = new THREE.Object3D();
    this.COMvisual.name = 'COM_VISUAL';

    geometry = new THREE.SphereGeometry(1, 32, 32);

    mesh = new THREE.Mesh(geometry);

    // \todo: This should be fixed to point to a correct material.
    /*this.setMaterial(mesh, {'ambient':[0.5,0.5,0.5,1.000000],
      'texture':'assets/media/materials/textures/com.png'});
      */
    mesh.name = 'COM_VISUAL';
    mesh.rotation.z = -Math.PI/2;
    this.COMvisual.add(mesh);
  }

  public addSky(cubemap?: string): void {
    if (cubemap === undefined) {
      const cubeLoader = new THREE.CubeTextureLoader();
      this.scene.background = cubeLoader.load([
        'https://fuel.gazebosim.org/1.0/openrobotics/models/skybox/tip/files/materials/textures/skybox-negx.jpg',
        'https://fuel.gazebosim.org/1.0/openrobotics/models/skybox/tip/files/materials/textures/skybox-posx.jpg',
        'https://fuel.gazebosim.org/1.0/openrobotics/models/skybox/tip/files/materials/textures/skybox-posy.jpg',
        'https://fuel.gazebosim.org/1.0/openrobotics/models/skybox/tip/files/materials/textures/skybox-negy.jpg',
        'https://fuel.gazebosim.org/1.0/openrobotics/models/skybox/tip/files/materials/textures/skybox-negz.jpg',
        'https://fuel.gazebosim.org/1.0/openrobotics/models/skybox/tip/files/materials/textures/skybox-posz.jpg',
      ]);
    } else {
      this.ddsLoader.load(cubemap,
        // OnLoad callback that allows us to manipulate the texture.
        (compressedTexture: THREE.CompressedTexture) => {

          const images: HTMLImageElement[] = [];
          const rawImages: any[] = <any[]><unknown>compressedTexture.image;

          // Convert the binary data arrays to images
          for (let i = 0; i < rawImages.length; i++) {
            const image = rawImages[i]['mipmaps'][0];
            const imageElem = binaryToImage(image['data'],
                                          image['width'],
                                          image['height']);

            images.push(imageElem);
          }

          // Reorder the images to support ThreeJS coordinate system.
          const reorderImages = [images[1], images[0],
                                 images[2], images[3],
                                 images[5], images[4]];

          // Create the cube texture
          this.scene.background = new THREE.CubeTexture(reorderImages,
                                                  compressedTexture.mapping,
                                                  compressedTexture.wrapS,
                                                  compressedTexture.wrapT,
                                                  compressedTexture.magFilter,
                                                  compressedTexture.minFilter,
                                                  compressedTexture.format,
                                                  compressedTexture.type,
                                                  compressedTexture.anisotropy,
                                                  compressedTexture.encoding);
          this.scene.background.needsUpdate = true;
        },

        // OnProgress, do nothing
        ()=>{},

        // OnError
        (error: any) => {
          if (this.findResourceCb) {

            // Get the mesh from the websocket server.
            this.findResourceCb(cubemap, (material: any, error?: string) => {
              if (error !== undefined) {
                // Mark the texture as error in the loading manager.
                const manager = this.ddsLoader.manager as WsLoadingManager;
                manager.markAsError(cubemap);
                return;
              }

              // Parse the DDS data.
              const texDatas = this.ddsLoader.parse(
                material.buffer.slice(material.byteOffset), true);

              const images: HTMLImageElement[] = [];
              let texture: THREE.CubeTexture;

              // This `if` statement was taken from https://github.com/mrdoob/three.js/blob/master/src/loaders/CompressedTextureLoader.js#L83
              if (texDatas['isCubemap']) {
                const faces = texDatas['mipmaps'].length / texDatas['mipmapCount'];
                for (let f = 0; f < faces; f++) {
                  for (let i = 0; i < texDatas['mipmapCount']; i++) {

                    let data: Uint8Array =
                      texDatas['mipmaps'][f * texDatas['mipmapCount'] + i]['data'];
                    // Convert binary data to an image
                    let imageElem = binaryToImage(data,
                                                  texDatas['width'],
                                                  texDatas['height']);
                    images.push(imageElem);
                  }
                }
              } else {
                console.error('Texture is not a cubemap. Sky will not be set.');
                // Mark the texture as error in the loading manager.
                const manager = this.ddsLoader.manager as WsLoadingManager;
                manager.markAsError(cubemap);
                return;
              }

              // Reorder the images to support ThreeJS coordinate system.
              const reorderImages = [images[1], images[0],
                                     images[2], images[3],
                                     images[5], images[4]];

              this.scene.background = new THREE.CubeTexture(reorderImages);
              this.scene.background.format =
                <unknown>(texDatas['format']) as THREE.PixelFormat;

              if (texDatas['mipmapCount'] === 1) {
                this.scene.background.minFilter = THREE.LinearFilter;
              }

              this.scene.background.needsUpdate = true;

              // Mark the texture as done in the loading manager.
              const manager = this.ddsLoader.manager as WsLoadingManager;
              manager.markAsDone(cubemap);
            });
          }
        }
      );
    }
  }

   /**
    * Add Fog to the scene.
    *
    * @param color Color can be a hexadecimal integer (recommended) or a CSS-style string.
    * @param density Defines how fast the fog will grow dense.
    * @param changeBackground Whether or not change the scene's background color accordingly.
    */
  public addFog(color: number | string, density: number, changeBackground?: boolean) {
    this.scene.fog = new THREE.FogExp2(color, density);
    if (changeBackground === true) {
      this.scene.background = new THREE.Color(color);
    }
  }

  public initScene(): void {
    this.emitter.emit('show_grid', 'show');
  }

  public setSDFParser(sdfParser: SDFParser): void {
    this.spawnModel.sdfParser = sdfParser;
  }

  /**
   * Window event callback
   * @param {} event - mousedown or touchdown events
   */
  public onPointerDown(event: MouseEvent): void {
    event.preventDefault();

    this.mousePointerDown = true;

    if (this.spawnModel.active)
    {
      return;
    }

    var mainPointer = true;
    let pos: THREE.Vector2;
    /*if (event.touches)
    {
      if (event.touches.length === 1)
      {
        pos = new THREE.Vector2(
            event.touches[0].clientX, event.touches[0].clientY);
      }
      else if (event.touches.length === 2)
      {
        pos = new THREE.Vector2(
            (event.touches[0].clientX + event.touches[1].clientX)/2,
            (event.touches[0].clientY + event.touches[1].clientY)/2);
      }
      else
      {
        return;
      }
    }
    else
    {*/
      pos = new THREE.Vector2(
            event.clientX, event.clientY);
      if (event.which !== 1)
      {
        mainPointer = false;
      }
    //}

    var intersect = new THREE.Vector3();
    var model = this.getRayCastModel(pos, intersect);

    if (intersect)
    {
      this.controls.target = intersect;
    }

    // Cancel in case of multitouch
    /*if (event.touches && event.touches.length !== 1)
    {
      return;
    }*/

    // Manipulation modes
    // Model found
    if (model)
    {
      // Do nothing to the floor plane
      if (model.name === 'plane')
      {
        // this.timeDown = new Date().getTime();
      }
      /*else if (this.modelManipulator.pickerNames.indexOf(model.name) >= 0)
      {
        // Do not attach manipulator to itself
      }*/
      // Attach manipulator to model
      else if (model.name !== '')
      {
        if (mainPointer && model.parent === this.scene)
        {
          //this.selectEntity(model);
        }
      }
      // Manipulator pickers, for mouse
      /*else if (this.modelManipulator.hovered)
      {
        this.modelManipulator.update();
        this.modelManipulator.object.updateMatrixWorld();
      }*/
      // Sky
      else
      {
        // this.timeDown = new Date().getTime();
      }
    }
    // Plane from below, for example
    else
    {
      // this.timeDown = new Date().getTime();
    }
  }

  /**
   * Window event callback
   * @param {} event - mouseup or touchend events
   */
  public onPointerUp(event: MouseEvent) {
    event.preventDefault();

    this.mousePointerDown = false;

    if (this.cameraMode === this.thirdPersonFollowEntityEvent) {
      // Calculate and store the new relative fixed camera position.
      // The offset we get in this.camera.position is in world coordinates,
      // but we want it relative to the object we are tracking.  Therefore,
      // do the inverse of what we do in render, namely:
      // 1. subtract the position of the tracked object
      // 2. Apply the inverse (conjugate) quaternion of the tracked object
      this.currentThirdPersonCameraOffset = this.camera.position.clone();
      this.currentThirdPersonCameraOffset.sub(this.cameraTrackObject.position);
      this.currentThirdPersonCameraOffset.applyQuaternion(this.cameraTrackObject.quaternion.conjugate());
    }

    // Clicks (<150ms) outside any models trigger view mode
    // var millisecs = new Date().getTime();
    /*if (millisecs - this.timeDown < 150)
    {
      this.setManipulationMode('view');
      // TODO: Remove jquery from scene
      if (typeof Gui === 'function')
      {
        $( '#view-mode' ).click();
        $('input[type="radio"]').checkboxradio('refresh');
      }
    }*/
    // this.timeDown = null;
  }

  /**
   * Window event callback
   * @param {} event - mousescroll event
   */
  public onMouseScroll(event: MouseEvent): void {
    event.preventDefault();

    const pos: THREE.Vector2 = new THREE.Vector2(event.clientX, event.clientY);

    let intersect: THREE.Vector3 = new THREE.Vector3();
    let model: THREE.Object3D = this.getRayCastModel(pos, intersect);

    if (intersect) {
      this.controls.target = intersect;
    }
  }

  /**
   * Window event callback
   * @param {} event - keydown events
   */
  /*public onKeyDown(event: MouseEvent): void {
    if (event.shiftKey)
    {
      // + and - for zooming
      if (event.keyCode === 187 || event.keyCode === 189)
      {
        var pos = new THREE.Vector2(this.getDomElement().width/2.0,
            this.getDomElement().height/2.0);

        var intersect = new THREE.Vector3();
        var model = this.getRayCastModel(pos, intersect);

        if (intersect)
        {
          this.controls.target = intersect;
        }

        if (event.keyCode === 187)
        {
          this.controls.dollyOut();
        }
        else
        {
          this.controls.dollyIn();
        }
      }
    }

    // DEL to delete entities
    if (event.keyCode === 46)
    {
      if (this.selectedEntity)
      {
        this.emitter.emit('delete_entity');
      }
    }

    // F2 for turning on effects
    if (event.keyCode === 113)
    {
      // this.effectsEnabled = !this.effectsEnabled;
    }

    // Esc/R/T for changing manipulation modes
    // TODO: Remove jquery from scene
    if (typeof Gui === 'function')
    {
      if (event.keyCode === 27) // Esc
      {
        $( '#view-mode' ).click();
        $('input[type="radio"]').checkboxradio('refresh');
      }
      if (event.keyCode === 82) // R
      {
        $( '#rotate-mode' ).click();
        $('input[type="radio"]').checkboxradio('refresh');
      }
      if (event.keyCode === 84) // T
      {
        $( '#translate-mode' ).click();
        $('input[type="radio"]').checkboxradio('refresh');
      }
    }
  }*/

  /**
   * Check if there's a model immediately under canvas coordinate 'pos'
   * @param {THREE.Vector2} pos - Canvas coordinates
   * @param {THREE.Vector3} intersect - Empty at input,
   * contains point of intersection in 3D world coordinates at output
   * @returns {THREE.Object3D} model - Intercepted model closest to the camera
   */
  public getRayCastModel(pos: THREE.Vector2, intersect: THREE.Vector3): THREE.Object3D {
    var rect = this.getDomElement().getBoundingClientRect();
    var vector = new THREE.Vector2(
      ((pos.x - rect.x) / rect.width) * 2 - 1,
      -((pos.y - rect.y) / rect.height) * 2 + 1);
    this.ray.setFromCamera(vector, this.camera);

    let allObjects: THREE.Object3D[] = [];
    getDescendants(this.scene, allObjects);
    let objects: any [] = this.ray.intersectObjects(allObjects);

    let model: THREE.Object3D = new THREE.Object3D();
    var point;
    if (objects.length > 0)
    {
      modelsloop:
      for (var i = 0; i < objects.length; ++i)
      {
        model = objects[i].object;
        if (model.name.indexOf('_lightHelper') >= 0) {
          model = model.parent!;
          break;
        }

        /*if (!this.modelManipulator.hovered &&
            (model.name === 'plane'))
        {
          // model = null;
          point = objects[i].point;
          break;
        }*/

        if (model.name === 'grid' || model.name === 'boundingBox' ||
            model.name === 'JOINT_VISUAL' || model.name === 'INERTIA_VISUAL'
          || model.name === 'COM_VISUAL')
        {
          point = objects[i].point;
          continue;
        }

        while (model.parent !== this.scene)
        {
          // Select current mode's handle
          /*if (model.parent.parent === this.modelManipulator.gizmo &&
              ((this.manipulationMode === 'translate' &&
                model.name.indexOf('T') >=0) ||
               (this.manipulationMode === 'rotate' &&
                 model.name.indexOf('R') >=0)))
          {
            break modelsloop;
          }*/
          model = model.parent!;
        }

        /*if (this.radialMenu && model === this.radialMenu.menu)
        {
          continue;
        }*/

        if (model.name.indexOf('COLLISION_VISUAL') >= 0) {
          continue;
        }

        /*if (this.modelManipulator.hovered)
        {
          if (model === this.modelManipulator.gizmo)
          {
            break;
          }
        }*/
        else if (model.name !== '')
        {
          point = objects[i].point;
          break;
        }
      }
    }
    if (point)
    {
      intersect.x = point.x;
      intersect.y = point.y;
      intersect.z = point.z;
    }
    return model;
  }

  /**
   * Get the renderer's DOM element
   * @returns {domElement}
   */
  public getDomElement(): HTMLCanvasElement {
    return this.renderer.domElement;
  }

  /**
   * Render scene
   */
  public render(timeElapsedMs: number): void {
    // Kill camera control when:
    // -manipulating
    // -using radial menu
    // -pointer over menus
    // -spawning
    /* Disabling this for now so that mouse control stays enabled when the
     * mouse leaves the viewport.
     * if (this.modelManipulator.hovered ||
        (this.radialMenu && this.radialMenu.showing) ||
        this.pointerOnMenu ||
        this.spawnModel.active)
    {
      this.controls.enabled = false;
    }
    else
    {
      this.controls.enabled = true;
    }*/
    this.controls.update();

    // If 'follow' mode, then track the specific object.
    if (this.cameraMode === this.followEntityEvent) {
      // Using a hard-coded offset for now.
      var relativeCameraOffset = new THREE.Vector3(-5, 0, 2);
      this.cameraTrackObject.updateMatrixWorld();
      var cameraOffset = relativeCameraOffset.applyMatrix4(
        this.cameraTrackObject.matrixWorld);

      this.camera.position.lerp(cameraOffset, 0.1);
      this.camera.lookAt(this.cameraTrackObject.position);

    } else if (this.cameraMode === this.thirdPersonFollowEntityEvent && !this.mousePointerDown) {
      // Based on https://discoverthreejs.com/book/first-steps/transformations/ ,
      // in THREE.js we have the following coordinate system:
      //
      // +X - Across the camera, to the right
      // -X - Across the camera, to the left
      // +Y - Up relative to the camera
      // -Y - Down relative to the camera
      // +Z - Towards the camera
      // -Z - Away from the camera

      let fixedCameraOffset = this.currentThirdPersonCameraOffset.clone();
      fixedCameraOffset.applyQuaternion(this.cameraTrackObject.quaternion);
      fixedCameraOffset.add(this.cameraTrackObject.position);

      let fixedLookAt = new THREE.Vector3(12, -4, 0);
      fixedLookAt.applyQuaternion(this.cameraTrackObject.quaternion);
      fixedLookAt.add(this.cameraTrackObject.position);

      // The calculation here comes from:
      // https://github.com/simondevyoutube/ThreeJS_Tutorial_ThirdPersonCamera/blob/main/main.js
      const timeElapsedSec = timeElapsedMs * 0.001;
      const timestep = 2.0 * timeElapsedSec;

      this.currentThirdPersonLookAt.lerp(fixedLookAt, timestep);

      this.camera.position.lerp(fixedCameraOffset, timestep);
      this.camera.lookAt(this.currentThirdPersonLookAt);
    } else if (this.cameraMode === this.firstPersonEntityEvent) {
      // Based on https://discoverthreejs.com/book/first-steps/transformations/ ,
      // in THREE.js we have the following coordinate system:
      //
      // +X - Across the camera, to the right
      // -X - Across the camera, to the left
      // +Y - Up relative to the camera
      // -Y - Down relative to the camera
      // +Z - Towards the camera
      // -Z - Away from the camera

      let fixedCameraOffset = new THREE.Vector3(-0.12, 0, 0.6);
      fixedCameraOffset.applyQuaternion(this.cameraTrackObject.quaternion);
      fixedCameraOffset.add(this.cameraTrackObject.position);

      let fixedLookAt = new THREE.Vector3(6, 0, 0);
      fixedLookAt.applyQuaternion(this.cameraTrackObject.quaternion);
      fixedLookAt.add(this.cameraTrackObject.position);

      // This is a pretty aggressive timestamp for lerping that makes the camera
      // bob a lot with the motion of the vehicle.  But I think it is what we want;
      // first-person camera should more-or-less feel like it is tied to the vehicle.
      const timestep = 0.5;

      this.currentFirstPersonLookAt.lerp(fixedLookAt, timestep);

      this.camera.position.lerp(fixedCameraOffset, timestep);
      this.camera.lookAt(this.currentFirstPersonLookAt);
    } else if (this.cameraMode === this.moveToEntityEvent) {
      // Move the camera if "lerping" to an object.
      // Compute the lerp factor.
      var lerp = this.cameraMoveToClock.getElapsedTime() / 2.0;

      // Stop the clock if the camera has reached it's target
      //if (Math.abs(1.0 - lerp) <= 0.005) {
      if (lerp >= 1.0) {
        this.cameraMoveToClock.stop();
        this.cameraMode = '';
      } else {
        // Move the camera's position.
        this.camera.position.lerpVectors(this.cameraLerpStart, this.cameraLerpEnd,
          lerp);

        // Move the camera's orientation.
        THREE.Quaternion.slerp(this.cameraSlerpStart, this.cameraSlerpEnd, this.camera.quaternion, lerp);
      }
    }

    // this.modelManipulator.update();
    /*if (this.radialMenu)
    {
      this.radialMenu.update();
    }*/

    this.renderer.clear();
    this.renderer.render(this.scene, this.camera);

    this.renderer.clearDepth();
    if (this.sceneOrtho && this.cameraOrtho)
    {
      this.renderer.render(this.sceneOrtho, this.cameraOrtho);
    }
  }

  /**
   * Set scene size.
   * @param {double} width
   * @param {double} height
   */
  public setSize(width: number, height: number): void {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();

    if (this.cameraOrtho)
    {
      this.cameraOrtho.left = -width / 2;
      this.cameraOrtho.right = width / 2;
      this.cameraOrtho.top = height / 2;
      this.cameraOrtho.bottom = -height / 2;
      this.cameraOrtho.updateProjectionMatrix();
    }

    this.renderer.setSize(width, height);
    this.render(0);
  }

  /**
   * Add object to the scene
   * @param {THREE.Object3D} model
   */
  public add(model: THREE.Object3D) {
    if (!model.userData) {
      model.userData = new ModelUserData();
    }
    this.scene.add(model);
  }

  /**
   * Remove object from the scene
   * @param {THREE.Object3D} model
   */
  public remove(model: THREE.Object3D): void
  {
    this.scene.remove(model);
  }

  /**
   * Returns the object which has the given name
   * @param {string} name
   * @returns {THREE.Object3D} model
   */
  public getByName(name: string): THREE.Object3D {
    return this.scene.getObjectByName(name)!;
  }

  /**
   * Returns the object which has the given property value
   * @param {string} property name to search for
   * @param {string} value of the given property
   * @returns {THREE.Object3D} model
   */
  public getByProperty(property: string, value: string): THREE.Object3D {
    return this.scene.getObjectByProperty(property, value)!;
  }

  /**
   * Update a model's pose
   * @param {THREE.Object3D} model
   * @param {} position
   * @param {} orientation
   */
  public updatePose(model: THREE.Object3D, position: THREE.Vector3,
                    orientation: THREE.Quaternion): void {
    /*if (this.modelManipulator && this.modelManipulator.object &&
        this.modelManipulator.hovered)
    {
      return;
    }*/

    this.setPose(model, position, orientation);
  }

  /**
   * Set a model's pose
   * @param {THREE.Object3D} model
   * @param {} position
   * @param {} orientation
   */
  public setPose(model: THREE.Object3D, position: THREE.Vector3,
                 orientation: THREE.Quaternion): void
  {
    model.position.x = position.x;
    model.position.y = position.y;
    model.position.z = position.z;
    model.quaternion.w = orientation.w;
    model.quaternion.x = orientation.x;
    model.quaternion.y = orientation.y;
    model.quaternion.z = orientation.z;
  }

  public removeAll(): void {
    while(this.scene.children.length > 0)
    {
      this.scene.remove(this.scene.children[0]);
    }
  }

  /**
   * Create plane
   * @param {THREE.Vector3} normal
   * @param {double} width
   * @param {double} height
   * @returns {THREE.Mesh}
   */
  public createPlane = function(normal: THREE.Vector3, width: number,
                                height:number): THREE.Mesh {
    // Create plane where width is along the x-axis and
    // and height along y-axi
    let geometry: THREE.PlaneGeometry =
      new THREE.PlaneGeometry(width, height, 1, 1);

    // Manually specify the up vector to be along the z-axis since
    // the plane is created on XY plane
    let up: THREE.Vector3 = new THREE.Vector3(0, 0, 1);

    let material:THREE.MeshPhongMaterial = new THREE.MeshPhongMaterial();
    let mesh: THREE.Mesh = new THREE.Mesh(geometry, material);

    // Make sure the normal is normalized.
    normal = normal.normalize();

    // Rotate the plane according to the normal.
    let axis: THREE.Vector3 = new THREE.Vector3();
    axis.crossVectors(up, normal);
    mesh.setRotationFromAxisAngle(axis, normal.angleTo(up));
    mesh.updateMatrix();

    mesh.name = 'plane';
    mesh.receiveShadow = true;
    return mesh;
  }

  /**
   * Create sphere
   * @param {double} radius
   * @returns {THREE.Mesh}
   */
  public createSphere(radius: number): THREE.Mesh {
    var geometry = new THREE.SphereGeometry(radius, 32, 32);
    var mesh = new THREE.Mesh(geometry, this.simpleShapesMaterial);
    return mesh;
  }

  /**
   * Create cylinder
   * @param {double} radius
   * @param {double} length
   * @returns {THREE.Mesh}
   */
  public createCylinder(radius: number, length: number): THREE.Mesh {
    var geometry = new THREE.CylinderGeometry(radius, radius, length, 32, 1,
        false);
    var mesh = new THREE.Mesh(geometry, this.simpleShapesMaterial);
    mesh.rotation.x = Math.PI * 0.5;
    return mesh;
  }

  /**
   * Create capsule
   * @param {double} radius
   * @param {double} length
   * @returns {THREE.Mesh}
   */
  public createCapsule(radius: number, length: number): THREE.Mesh {
    var geometry = new THREE.CapsuleGeometry(radius, length, 32, 16);
    var mesh = new THREE.Mesh(geometry, this.simpleShapesMaterial);
    mesh.rotation.x = Math.PI * 0.5;
    return mesh;
  }

  /**
   * Create cone
   * @param {double} radius
   * @param {double} length
   * @returns {THREE.Mesh}
   */
  public createCone(radius: number, length: number): THREE.Mesh {
    var geometry = new THREE.ConeGeometry(radius, length, 32);
    var mesh = new THREE.Mesh(geometry, this.simpleShapesMaterial);
    mesh.rotation.x = Math.PI * 0.5;
    return mesh;
  }

  /**
   * Create ellipsoid
   * @param {double} radius
   * @param {double} length
   * @returns {THREE.Mesh}
   */
  public createEllipsoid(radius1: number, radius2: number, radius3: number): THREE.Mesh {
    var geometry = new THREE.SphereGeometry(radius1, 32, 32);
    geometry.scale(1, radius3/radius1, radius2/radius1);
    var mesh = new THREE.Mesh(geometry, this.simpleShapesMaterial);
    mesh.rotation.x = Math.PI * 0.5;
    return mesh;
  }

  /**
   * Create box
   * @param {double} width
   * @param {double} height
   * @param {double} depth
   * @returns {THREE.Mesh}
   */
  public createBox(width: number, height: number, depth: number): THREE.Mesh {
    let geometry: THREE.BoxGeometry =
      new THREE.BoxGeometry(width, height, depth, 1, 1, 1);

    // Fix UVs so textures are mapped in a way that is consistent to gazebo
    // Some face uvs need to be rotated clockwise, while others anticlockwise
    // After updating to threejs rev 62, geometries changed from quads (6 faces)
    // to triangles (12 faces).
    var faceUVFixA = [1, 4, 5];
    var faceUVFixB = [0];
    let uvAttribute = geometry.getAttribute('uv');
    /* THREEJS has moved away from faceVertexUvs to BufferGeometry attributes.
     * Need to migrate this code. See https://discourse.threejs.org/t/facevertexuvs-for-buffergeometry/23040
    for (var i = 0; i < faceUVFixA.length; ++i)
    {
      var idx = faceUVFixA[i]*2;
      // Make sure that the index is valid. A threejs box geometry may not
      // have all of the faces if a dimension is sufficiently small.
      if (idx + 1 < geometry.faceVertexUvs.length) {
        var uva = geometry.faceVertexUvs[0][idx][0];
        geometry.faceVertexUvs[0][idx][0] = geometry.faceVertexUvs[0][idx][1];
        geometry.faceVertexUvs[0][idx][1] = geometry.faceVertexUvs[0][idx+1][1];
        geometry.faceVertexUvs[0][idx][2] = uva;

        geometry.faceVertexUvs[0][idx+1][0] = geometry.faceVertexUvs[0][idx+1][1];
        geometry.faceVertexUvs[0][idx+1][1] = geometry.faceVertexUvs[0][idx+1][2];
        geometry.faceVertexUvs[0][idx+1][2] = geometry.faceVertexUvs[0][idx][2];
      }
    }
    for (var ii = 0; ii < faceUVFixB.length; ++ii)
    {
      var idxB = faceUVFixB[ii]*2;

      // Make sure that the index is valid. A threejs box geometry may not
      // have all of the faces if a dimension is sufficiently small.
      if (idxB+1 < geometry.faceVertexUvs.length) {
        var uvc = geometry.faceVertexUvs[0][idxB][0];
        geometry.faceVertexUvs[0][idxB][0] = geometry.faceVertexUvs[0][idxB][2];
        geometry.faceVertexUvs[0][idxB][1] = uvc;
        geometry.faceVertexUvs[0][idxB][2] = geometry.faceVertexUvs[0][idxB+1][1];

        geometry.faceVertexUvs[0][idxB+1][2] = geometry.faceVertexUvs[0][idxB][2];
        geometry.faceVertexUvs[0][idxB+1][1] = geometry.faceVertexUvs[0][idxB+1][0];
        geometry.faceVertexUvs[0][idxB+1][0] = geometry.faceVertexUvs[0][idxB][1];
      }
    }
   */
    uvAttribute.needsUpdate = true;

    var mesh = new THREE.Mesh(geometry, this.simpleShapesMaterial);
    mesh.castShadow = true;
    return mesh;
  }

  /**
   * Create light
   * @param {} type - 1: point, 2: spot, 3: directional
   * @param {} diffuse
   * @param {} intensity
   * @param {} pose
   * @param {} distance
   * @param {} cast_shadows
   * @param {} name
   * @param {} direction
   * @param {} specular
   * @param {} attenuation_constant
   * @param {} attenuation_linear
   * @param {} attenuation_quadratic
   * @returns {THREE.Object3D}
   */
  public createLight(type: number, diffuse?: Color, intensity?: number,
    pose?: Pose, distance?: number, cast_shadows?: boolean,
    name?: string, direction?: THREE.Vector3,
    specular?: Color, attenuation_constant?: number,
    attenuation_linear?: number, attenuation_quadratic?: number,
    inner_angle?: number, outer_angle?: number, falloff?: number): THREE.Object3D
  {
    let obj: THREE.Object3D = new THREE.Object3D();

    if (typeof(diffuse) === 'undefined') {
      diffuse = new Color();
      diffuse.r = 1;
      diffuse.g = 1;
      diffuse.b = 1;
      diffuse.a = 1;
    }

    if (pose) {
      this.setPose(obj, pose.position, pose.orientation);
      obj.matrixWorldNeedsUpdate = true;
    }

    let lightObj: THREE.Light;

    if (type === 1) {
      lightObj = this.createPointLight(obj, diffuse, intensity,
          distance, cast_shadows);
    } else if (type === 2) {
      lightObj = this.createSpotLight(obj, diffuse, intensity,
          distance, cast_shadows, inner_angle, outer_angle, falloff, direction);
    } else if (type === 3) {
      lightObj = this.createDirectionalLight(obj, diffuse, intensity,
          cast_shadows, direction);
    } else {
      console.error('Unknown light type', type);
      return obj;
    }

    if (name) {
      lightObj.name = name;
      obj.name = name;
    }

    obj.add(lightObj);

    return obj;
  }

  /**
   * Create point light - called by createLight
   * @param {} obj - light object
   * @param {} color
   * @param {} intensity
   * @param {} distance
   * @param {} cast_shadows
   * @returns {Object.<THREE.Light, THREE.Mesh>}
   */
  public createPointLight(obj: THREE.Object3D, color: THREE.Color,
                          intensity?: number, distance?: number,
                          cast_shadows?: boolean): THREE.Light {
    if (typeof(intensity) === 'undefined') {
      intensity = 0.5;
    }

    var lightObj = new THREE.PointLight(color, intensity);

    if (distance) {
      lightObj.distance = distance;
    }
    if (cast_shadows) {
      lightObj.castShadow = cast_shadows;
    }

    return lightObj;
  }

  /**
   * Create spot light - called by createLight
   * @param {} obj - light object
   * @param {} color
   * @param {} intensity
   * @param {} distance
   * @param {} cast_shadows
   * @returns {Object.<THREE.Light, THREE.Mesh>}
   */
  public createSpotLight(obj: THREE.Object3D, color: THREE.Color,
                         intensity?: number, distance?: number,
                         cast_shadows?: boolean, inner_angle?: number,
                         outer_angle?: number, falloff?: number,
                        direction?: THREE.Vector3): THREE.Light {
    if (typeof(intensity) === 'undefined') {
      intensity = 1;
    }
    if (typeof(distance) === 'undefined') {
      distance = 20;
    }

    let lightObj: THREE.SpotLight =
      new THREE.SpotLight(color, intensity, distance);
    lightObj.position.set(0,0,0);

    if (inner_angle !== null && outer_angle !== null) {
      lightObj.angle = outer_angle!;
      lightObj.penumbra = Math.max(1,
        (outer_angle! - inner_angle!) / ((inner_angle! + outer_angle!) / 2.0));
    }

    if (falloff !== null) {
      lightObj.decay = falloff!;
    }

    if (cast_shadows) {
      lightObj.castShadow = cast_shadows!;
    }

    // Set the target
    let dir: THREE.Vector3 = new THREE.Vector3(0, 0, -1);
    if (direction) {
        dir.x = direction!.x;
        dir.y = direction!.y;
        dir.z = direction!.z;
    }
    let targetObj: THREE.Object3D = new THREE.Object3D();
    lightObj.add(targetObj);

    targetObj.position.copy(dir);
    targetObj.matrixWorldNeedsUpdate = true;
    lightObj.target = targetObj;

    return lightObj;
  }

  /**
   * Create directional light - called by createLight
   * @param {} obj - light object
   * @param {} color
   * @param {} intensity
   * @param {} cast_shadows
   * @returns {Object.<THREE.Light, THREE.Mesh>}
   */
  public createDirectionalLight(obj: THREE.Object3D, color: THREE.Color,
                                intensity?: number,
                                cast_shadows?: boolean,
                                direction?: THREE.Vector3): THREE.Light
  {
    if (typeof(intensity) === 'undefined') {
      intensity = 1;
    }

    var lightObj = new THREE.DirectionalLight(color, intensity);
    lightObj.shadow.camera.near = 1;
    lightObj.shadow.camera.far = 50;
    lightObj.shadow.mapSize.width = 4094;
    lightObj.shadow.mapSize.height = 4094;
    lightObj.shadow.camera.bottom = -100;
    lightObj.shadow.camera.right = 100;
    lightObj.shadow.camera.top = 100;
    lightObj.shadow.bias = 0.0001;
    lightObj.position.set(0,0,0);

    if (cast_shadows) {
      lightObj.castShadow = cast_shadows;
    }

    // Set the target
    let dir: THREE.Vector3 = new THREE.Vector3(0, 0, -1);
    if (direction) {
        dir.x = direction.x;
        dir.y = direction.y;
        dir.z = direction.z;
    }
    let targetObj: THREE.Object3D = new THREE.Object3D();
    lightObj.add(targetObj);

    targetObj.position.copy(dir);
    targetObj.matrixWorldNeedsUpdate = true;
    lightObj.target = targetObj;

    return lightObj;
  }

  /**
   * Load heightmap
   * @param {} heights Lookup table of heights
   * @param {} width Width of the heightmap in meters
   * @param {} height Height of the heightmap in meters
   * @param {} segmentWidth Size of lookup table
   * @param {} segmentHeight Size of lookup table
   * @param {} origin Heightmap position in the world
   * @param {} textures
   * @param {} blends
   * @param {} parent
   */
  public loadHeightmap(heights: Float32Array, width: number, height: number,
      segmentWidth: number, segmentHeight: number, origin: THREE.Vector3,
      textures: any[], blends: any[], parent: THREE.Object3D): void {
    if (this.heightmap) {
      console.error('Only one heightmap can be loaded at a time');
      return;
    }

    if (parent === undefined) {
      console.error('Missing parent, heightmap won\'t be loaded.');
      return;
    }

    // unfortunately large heightmaps kill the fps and freeze everything so
    // we have to scale it down
    let scale = 1;
    const maxHeightmapWidth = 256;
    const maxHeightmapHeight = 256;

    if ((segmentWidth - 1) > maxHeightmapWidth) {
      scale = maxHeightmapWidth / (segmentWidth - 1);
    }

    let geometry: THREE.PlaneGeometry = new THREE.PlaneGeometry(width, height,
      (segmentWidth - 1) * scale, (segmentHeight - 1) * scale);

    let posAttribute = geometry.getAttribute('position');

    // Sub-sample
    let col: number = (segmentWidth - 1) * scale;
    let row: number = (segmentHeight - 1) * scale;
    for (let r = 0; r < row; ++r) {
      for (let c = 0; c < col; ++c) {
        let index: number = (r * col * 1/(scale*scale)) + (c * (1/scale));
        posAttribute.setZ(r*col + c, heights[index]);
      }
    }
    posAttribute.needsUpdate = true;

    // Compute normals
    geometry.normalizeNormals();
    geometry.computeVertexNormals();

    let material: THREE.MeshStandardMaterial | THREE.MeshPhongMaterial;

    // NOTE: Texture might be an array of textures, that need to blend in between.
    // For now, it only uses one texture.
    if (textures && textures.length > 0) {
      const texturesLoaded = [];
      const normalsLoaded = [];

      // Auxiliar method to configurate a texture's repeat and wrapping.
      function configTexture(texture: THREE.Texture, repeat: THREE.Vector2) {
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.copy(repeat);
      }

      for (let t = 0; t < textures.length; ++t) {
        const diffuseUri = createFuelUri(textures[t].diffuse);
        texturesLoaded[t] = this.loadTexture(diffuseUri);
        configTexture(texturesLoaded[t], new THREE.Vector2(
          width/textures[t].size, height/textures[t].size)
        );

        let normalUri;
        if (textures[t].normal) {
          normalUri = createFuelUri(textures[t].normal);
          normalsLoaded[t] = this.loadTexture(normalUri);
          configTexture(normalsLoaded[t], new THREE.Vector2(
            width/textures[t].size, height/textures[t].size)
          );
        }
      }

      const materialOptions: THREE.MeshStandardMaterialParameters = {}
      if (texturesLoaded[0]) {
        materialOptions.map = texturesLoaded[0];
      }
      if (normalsLoaded[0]) {
        materialOptions.normalMap = normalsLoaded[0];
      }

      material = new THREE.MeshStandardMaterial(materialOptions);
    } else {
      material = new THREE.MeshPhongMaterial( { color: 0x555555 } );
    }

    const mesh = new THREE.Mesh(geometry, material);

    mesh.receiveShadow = true;
    mesh.castShadow = false;

    mesh.position.x = origin.x;
    mesh.position.y = origin.y;
    mesh.position.z = origin.z;
    parent.add(mesh);

    this.heightmap = parent;
  }

  /**
   * Load mesh
   * @example
   * // loading using URI
   * // callback(mesh)
   * loadMeshFromUri('assets/house_1/meshes/house_1.dae', undefined, undefined, function(mesh)
              {
                // use the mesh
              });
   * @param {string} uri
   * @param {} submesh
   * @param {} centerSubmesh
   * find a resource.
   * @param {function} onLoad
   * @param {function} onError
   */
  public loadMeshFromUri(uri: string, submesh: string, centerSubmesh: boolean,
    onLoad: any, onError: any): void {
    var uriPath = uri.substring(0, uri.lastIndexOf('/'));
    var uriFile = uri.substring(uri.lastIndexOf('/') + 1);

    // Check if the mesh has already been loaded.
    // Use it in that case.
    if (this.meshes.has(uri))
    {
      let mesh: THREE.Mesh = this.meshes.get(uri)!.clone();
      if (submesh && this.useSubMesh(mesh, submesh, centerSubmesh)) {
        onLoad(mesh);
      } else if (!submesh) {
        onLoad(mesh);
      }
      return;
    }

    // load meshes
    if (uriFile.substr(-4).toLowerCase() === '.dae') {
      return this.loadCollada(uri, submesh, centerSubmesh, onLoad, onError);
    }
    else if (uriFile.substr(-4).toLowerCase() === '.obj') {
      return this.loadOBJ(uri, submesh, centerSubmesh, onLoad, onError);
    }
    else if (uriFile.substr(-4).toLowerCase() === '.stl') {
      return this.loadSTL(uri, submesh, centerSubmesh, onLoad, onError);
    }
    else if (uriFile.substr(-5).toLowerCase() === '.urdf') {
      console.error('Attempting to load URDF file, but it\'s not supported.');
    }
  }

  /**
   * Load mesh
   * @example
   * // loading using URI
   * // callback(mesh)
   * @example
   * // loading using file string
   * // callback(mesh)
   * loadMeshFromString('assets/house_1/meshes/house_1.dae', undefined, undefined, function(mesh)
              {
                // use the mesh
              }, ['<?xml version="1.0" encoding="utf-8"?>
      <COLLADA xmlns="http://www.collada.org/2005/11/COLLADASchema" version="1.4.1">
        <asset>
          <contributor>
            <author>Cole</author>
            <authoring_tool>OpenCOLLADA for 3ds Max;  Ver.....']);
   * @param {string} uri
   * @param {} submesh
   * @param {} centerSubmesh
   * @param {function} onLoad
   * @param {function} onError
   * @param {array} files - files needed by the loaders[dae] in case of a collada
   * mesh, [obj, mtl] in case of object mesh, all as strings
   */
  public loadMeshFromString(uri: string, submesh: string,
                            centerSubmesh: boolean, onLoad: any,
                            onError: any, files: string[]): void {
    var uriPath = uri.substring(0, uri.lastIndexOf('/'));
    var uriFile = uri.substring(uri.lastIndexOf('/') + 1);

    if (this.meshes.has(uri))
    {
      let mesh: THREE.Mesh = this.meshes.get(uri)!.clone();
      if (submesh && this.useSubMesh(mesh, submesh, centerSubmesh)) {
        onLoad(mesh);
      } else if (!submesh) {
        onLoad(mesh);
      }
      return;
    }

    // load mesh
    if (uriFile.substr(-4).toLowerCase() === '.dae')
    {
      // loadCollada just accepts one file, which is the dae file as string
      if (files.length < 1 || !files[0]) {
        console.error('Missing DAE file');
        return;
      }
      this.loadCollada(uri, submesh, centerSubmesh, onLoad, onError, files[0]);
    }
    else if (uriFile.substr(-4).toLowerCase() === '.obj')
    {
      if (files.length < 2 || !files[0] || !files[1]) {
        console.error('Missing either OBJ or MTL file');
        return;
      }
      this.loadOBJ(uri, submesh, centerSubmesh, onLoad, onError, files);
    }
  }

  /**
   * Load collada file
   * @param {string} uri - mesh uri which is used by colldaloader to load
   * the mesh file using an XMLHttpRequest.
   * @param {} submesh
   * @param {} centerSubmesh
   * @param {function} onLoad - Callback when the mesh is loaded.
   * @param {function} onError - Callback when an error occurs.
   * @param {string} filestring -optional- the mesh file as a string to be
   * parsed
   * if provided the uri will not be used just as a url, no XMLHttpRequest will
   * be made.
   */
  public loadCollada(uri: string, submesh: string, centerSubmesh: boolean,
    onLoad: any, onError: any, filestring?: string): void
  {
    let dae: THREE.Mesh;
    var mesh = null;
    var that = this;

    /*
    // Crashes: issue #36
    if (this.meshes.has(uri))
    {
      dae = this.meshes.get(uri);
      dae = dae.clone();
      this.useColladaSubMesh(dae, submesh, centerSubmesh);
      onLoad(dae);
      return;
    }
    */
    function meshReady(collada: any): void {
      // check for a scale factor
      /*if(collada.dae.asset.unit)
      {
        var scale = collada.dae.asset.unit;
        collada.scene.scale = new THREE.Vector3(scale, scale, scale);
      }*/

      dae = collada.scene;
      dae.updateMatrix();
      that.prepareColladaMesh(dae);
      that.meshes.set(uri, dae);
      dae = dae.clone();
      dae.name = uri;
      if (submesh && that.useSubMesh(dae, submesh, centerSubmesh)) {
        onLoad(dae);
      } else if (!submesh) {
        onLoad(dae);
      }
    }

    if (!filestring) {
      this.colladaLoader.load(uri,
        // onLoad callback
        function(collada: any) {
          meshReady(collada);
        },
        // onProgress callback
        function(progress: any) {
        },
        // onError callback
        (error: any) => {
          if (this.findResourceCb) {
            // Get the mesh from the websocket server.
            this.findResourceCb(uri, (mesh: any, error?: string) => {
              if (error !== undefined) {
                // Mark the mesh as error in the loading manager.
                const manager = this.colladaLoader.manager as WsLoadingManager;
                manager.markAsError(uri);
                return;
              }

              meshReady(
                this.colladaLoader.parse(new TextDecoder().decode(mesh), uri)
              );

              // Mark the mesh as done in the loading manager.
              const manager = this.colladaLoader.manager as WsLoadingManager;
              manager.markAsDone(uri);
            });
          }
        });
    } else {
      meshReady(this.colladaLoader.parse(filestring, undefined));
    }
  }

  /**
   * Prepare collada by removing other non-mesh entities such as lights
   * @param {} dae
   */
  public prepareColladaMesh(dae: THREE.Object3D): void {
    let allChildren: THREE.Object3D[] = [];
    getDescendants(dae, allChildren);
    for (let i = 0; i < allChildren.length; ++i) {
      if (allChildren[1] && allChildren[i] instanceof THREE.Light &&
          allChildren[i].parent) {
        allChildren[i].parent!.remove(allChildren[i]);
      }
    }
  }

  /**
   * Prepare mesh by handling submesh-only loading
   * @param {THREE.Mesh} mesh
   * @param {} submesh
   * @param {} centerSubmesh
   * @returns {THREE.Mesh} mesh
   */
  public useSubMesh(mesh: THREE.Object3D, submesh: string,
                    centerSubmesh: boolean): THREE.Mesh | THREE.Group | null {

    if (!submesh) {
      return null;
    }

    let result: THREE.Mesh;

    // The mesh has children for every submesh. Those children are either
    // meshes or groups that contain meshes. We need to modify the mesh, so
    // only the required submesh is contained in it. Note: If a submesh is
    // contained in a group, we need to preserve that group, as it may apply
    // matrix transformations required by the submesh.

    // Auxiliary function used to look for the required submesh.
    // Checks if the given submesh is the one we look for. If it's a Group, look for it within its children.
    // It returns the submesh, if found.
    function lookForSubmesh(obj: THREE.Mesh | THREE.Group,
                            parent: THREE.Object3D): [boolean, THREE.Mesh | THREE.Group] {

      if (obj instanceof THREE.Mesh) {
        // Check if the mesh has the correct name and has geometry.
        if (obj.name === submesh && obj.hasOwnProperty('geometry')) {

          // Center the submesh.
          if (centerSubmesh) {
            // obj file
            if (obj.geometry instanceof THREE.BufferGeometry) {
              let geomPosition = obj.geometry.getAttribute('position');
              let minPos: THREE.Vector3 = new THREE.Vector3();
              let maxPos: THREE.Vector3 = new THREE.Vector3();
              let centerPos: THREE.Vector3 = new THREE.Vector3();

              minPos.fromBufferAttribute(geomPosition, 0);
              maxPos.fromBufferAttribute(geomPosition, 0);

              // Get the min and max values.
              for (let i = 0; i < geomPosition.count; i++) {
                minPos.x = Math.min(minPos.x, geomPosition.getX(i));
                minPos.y = Math.min(minPos.y, geomPosition.getY(i));
                minPos.z = Math.min(minPos.z, geomPosition.getZ(i));

                maxPos.x = Math.max(maxPos.x, geomPosition.getX(i));
                maxPos.y = Math.max(maxPos.y, geomPosition.getY(i));
                maxPos.z = Math.max(maxPos.z, geomPosition.getZ(i));
              }

              // Compute center position
              centerPos = minPos.add((maxPos.sub(minPos)).multiplyScalar(0.5));

              // Update geometry position
              for (let i = 0; i < geomPosition.count; i++) {
                let origPos: THREE.Vector3 = new THREE.Vector3();
                origPos.fromBufferAttribute(geomPosition, i);
                let newPos = origPos.sub(centerPos);
                geomPosition.setXYZ(i, newPos.x, newPos.y, newPos.z);
              }
              geomPosition.needsUpdate = true;

              // Center the position.
              obj.position.set(0, 0, 0);
              var childParent = obj.parent;
              while (childParent) {
                childParent.position.set(0, 0, 0);
                childParent = childParent.parent;
              }
            }
          }

          // Filter the children of the parent. Only the required submesh
          // needs to be there.
          parent.children = [obj];
          return [true, obj];
        }
      } else {
        for (let i: number = 0; i < obj.children.length; i++) {
          if (obj.children[i] instanceof THREE.Mesh ||
              obj.children[i] instanceof THREE.Group) {
            const [found, result] = lookForSubmesh(obj.children[i] as any, obj);
            if (found) {
              // This keeps the Group (obj), and modifies it's children to
              // contain only the submesh.
              obj.children = [result];
              return [true, obj];
            }
          }
        }
      }

      return [false, obj];
    }

    // Look for the submesh in the children of the mesh.
    for (var i = 0; i < mesh.children.length; i++) {
      if (mesh.children[i] instanceof THREE.Mesh ||
          mesh.children[i] instanceof THREE.Group) {
        const [found, result] = lookForSubmesh(mesh.children[i] as any, mesh);
        if (found) {
          return result;
        }
      }
    }

    return null;
  }

  /**
   * Load obj file.
   * Loads obj mesh given using it's uri
   * @param {string} uri
   * @param {} submesh
   * @param {} centerSubmesh
   * @param {function} onLoad
   * @param {function} onError
   */
  public loadOBJ(uri: string, submesh: string, centerSubmesh: boolean,
                 onLoad: any, onError: any, files?: string[]): void
  {
    let objLoader = new GzObjLoader(this, uri, submesh, centerSubmesh,
                                  this.findResourceCb, onLoad, onError, files);
    objLoader.load();
  }

  /**
   * Load stl file.
   * Loads stl mesh given using it's uri
   * @param {string} uri
   * @param {} submesh
   * @param {} centerSubmesh
   * @param {function} onLoad
   */
  public loadSTL(uri: string, submesh: string, centerSubmesh: boolean,
                 onLoad: any, onError: any): void
  {
    var mesh = null;
    var that = this;
    this.stlLoader.load(uri,
      // onLoad
      function(geometry: THREE.BufferGeometry) {
        mesh = new THREE.Mesh(geometry);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        that.meshes.set(uri, mesh);
        mesh = mesh.clone();
        mesh.name = uri;
        if (submesh && that.useSubMesh(mesh, submesh, centerSubmesh)) {
          onLoad(mesh);
        } else if (!submesh) {
          onLoad(mesh);
        }
      },
      // onProgress
      function (progress: any) {
      },
      // onError
      function (error: any) {
        if (that.findResourceCb) {
          // Get the mesh from the websocket server.
          that.findResourceCb(uri, (mesh: any, error?: string) => {
            if (error !== undefined) {
              // Mark the mesh as error in the loading manager.
              const manager = that.stlLoader.manager as WsLoadingManager;
              manager.markAsError(uri);
              return;
            }

            onLoad(that.stlLoader.parse(new TextDecoder().decode(mesh)));

            // Mark the mesh as done in the loading manager.
            const manager = that.stlLoader.manager as WsLoadingManager;
            manager.markAsDone(uri);
          });
        }
      }
    );
  }

  /**
   * Set material for an object
   * @param {} obj
   * @param {} material
   */
  public setMaterial(obj: THREE.Mesh, material: any): void
  {
    var scope = this;



    if (obj)
    {
      if (material)
      {


        // If the material has a PBR tag, use a MeshStandardMaterial,
        // which can have albedo, normal, emissive, roughness and metalness
        // maps. Otherwise use a Phong material.
        if (material.pbr) {
          obj.material = new THREE.MeshStandardMaterial();
          // Array of maps in order to facilitate the repetition and scaling process.
          var maps = [];

          if (material.pbr.albedoMap) {
            let albedoMap = this.loadTexture(material.pbr.albedoMap);
            (obj.material as any).map = albedoMap;
            maps.push(albedoMap);

            // enable alpha test for textures with alpha transparency
            if (albedoMap.format === THREE.RGBAFormat) {
              obj.material.alphaTest = 0.5;
            }
          }

          if (material.pbr.normalMap) {
            let normalMap = this.loadTexture(material.pbr.normalMap);
            (obj.material as any).normalMap = normalMap;
            maps.push(normalMap);
          }

          if (material.pbr.emissiveMap) {
            let emissiveMap = this.loadTexture(material.pbr.emissiveMap);
            (obj.material as any).emissiveMap = emissiveMap;
            maps.push(emissiveMap);
          }

          if (material.pbr.roughnessMap) {
            let roughnessMap = this.loadTexture(material.pbr.roughnessMap);
            (obj.material as any).roughnessMap = roughnessMap;
            maps.push(roughnessMap);
          }

          if (material.pbr.metalnessMap) {
            let metalnessMap = this.loadTexture(material.pbr.metalnessMap);
            (obj.material as any).metalnessMap = metalnessMap;
            maps.push(metalnessMap);
          }

          maps.forEach(function(map) {
            map.wrapS = map.wrapT = THREE.RepeatWrapping;
            map.repeat.x = 1.0;
            map.repeat.y = 1.0;
            if (material.scale) {
              map.repeat.x = 1.0 / material.scale[0];
              map.repeat.y = 1.0 / material.scale[1];
            }
          });
        } else {
          obj.material = new THREE.MeshPhongMaterial();

          const specular = material.specular;
          if (specular) {
            (obj.material as any).specular.copy(specular);
          }

          if (material.texture)
          {
            let texture = this.loadTexture(material.texture);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.x = 1.0;
            texture.repeat.y = 1.0;
            if (material.scale) {
              texture.repeat.x = 1.0 / material.scale[0];
              texture.repeat.y = 1.0 / material.scale[1];
            }
            (obj.material as any).map = texture;

            // enable alpha test for textures with alpha transparency
            if (texture.format === THREE.RGBAFormat) {
              obj.material.alphaTest = 0.5;
            }
          }

          if (material.normalMap) {
            (obj.material as any).normalMap =
              this.loadTexture(material.normalMap);
          }
        }

        var ambient = material.ambient;
        var diffuse = material.diffuse;
        if (diffuse)
        {
          // threejs removed ambient from phong and lambert materials so
          // aproximate the resulting color by mixing ambient and diffuse
          var dc = [];
          dc[0] = diffuse.r;
          dc[1] = diffuse.g;
          dc[2] = diffuse.b;
          if (ambient)
          {
            var a = 0.4;
            var d = 0.6;
            dc[0] = ambient.r*a + diffuse.r*d;
            dc[1] = ambient.g*a + diffuse.g*d;
            dc[2] = ambient.b*a + diffuse.b*d;
          }
          (obj.material as any).color.setRGB(dc[0], dc[1], dc[2]);
        }
        var opacity = material.opacity;
        if (opacity)
        {
          if (opacity < 1)
          {
            obj.material.transparent = true;
            obj.material.opacity = opacity;
          }
        }
      }
    }
  }

  /**
   * Set manipulation mode (view/translate/rotate)
   * @param {string} mode
   */
  public setManipulationMode(mode: string): void {
    this.manipulationMode = mode;

    if (mode === 'view')
    {
      /*if (this.modelManipulator.object)
      {
        this.emitter.emit('entityChanged', this.modelManipulator.object);
      }*/
      this.selectEntity(null);
    }
    else
    {
      // Toggle manipulaion space (world / local)
      /*if (this.modelManipulator.mode === this.manipulationMode)
      {
        this.modelManipulator.space =
          (this.modelManipulator.space === 'world') ? 'local' : 'world';
      }
      this.modelManipulator.mode = this.manipulationMode;
      this.modelManipulator.setMode(this.modelManipulator.mode);
     */
      // model was selected during view mode
      if (this.selectedEntity)
      {
        this.selectEntity(this.selectedEntity);
      }
    }
  }

  /**
   * Show collision visuals
   * @param {boolean} show
   */
  public showCollision(show: boolean): void {
    if (show === this.showCollisions)
    {
      return;
    }

    let allObjects: THREE.Object3D[] = [];
    getDescendants(this.scene, allObjects);
    for (let i = 0; i < allObjects.length; ++i)
    {
      if (allObjects[i] instanceof THREE.Object3D &&
          allObjects[i].name.indexOf('COLLISION_VISUAL') >=0)
      {
        let allChildren: THREE.Object3D[] = [];
        getDescendants(allObjects[i], allChildren);
        for (var j =0; j < allChildren.length; ++j)
        {
          if (allChildren[j] instanceof THREE.Mesh)
          {
            allChildren[j].visible = show;
          }
        }
      }
    }
    this.showCollisions = show;
  }

  /**
   * Attach manipulator to an object
   * @param {THREE.Object3D} model
   * @param {string} mode (translate/rotate)
   */
  public attachManipulator(model: THREE.Object3D, mode: string): void {
    /*if (this.modelManipulator.object)
    {
      this.emitter.emit('entityChanged', this.modelManipulator.object);
    }

    if (mode !== 'view')
    {
      this.modelManipulator.attach(model);
      this.modelManipulator.mode = mode;
      this.modelManipulator.setMode( this.modelManipulator.mode );
      this.scene.add(this.modelManipulator.gizmo);
    }*/
  }

  /**
   * Toggle light visibility for the given entity. This will turn on/off
   * all lights that are children of the provided entity.
   * @param {string} Name of a THREE.Object3D.
   */
  public toggleLights(entityName: string): void
  {
    // Turn off following if `entity` is null.
    if (entityName === undefined || entityName === null) {
      return;
    }

    /* Helper function to enable all child lights */
    function enableLightsHelper(obj: any) {
      if (obj === null || obj === undefined) {
        return;
      }

      if (obj.userData.hasOwnProperty('type') &&
          obj.userData.type === 'light') {
        obj.visible = !obj.visible;
      }
    }

    // Find the object and set the lights.
    var object = this.scene.getObjectByName(entityName);
    if (object !== null && object !== undefined) {
      object.traverse(enableLightsHelper);
    }
  }

  /**
   * Reset view
   */
  public resetView(): void
  {
    this.camera.position.copy(this.defaultCameraPosition);
    this.camera.up = new THREE.Vector3(0, 0, 1);
    this.camera.lookAt(this.defaultCameraLookAt);
    this.camera.updateMatrix();
  }

  /**
   * Take a screenshot of the canvas and save it.
   *
   * @param {string} filename - The filename of the screenshot. PNG extension is appended to it.
   */
  public saveScreenshot(filename: string): void
  {
    // An explicit call to render is required. Otherwise the obtained image will be black.
    // See https://threejsfundamentals.org/threejs/lessons/threejs-tips.html, "Taking A Screenshot of the Canvas"
    this.render(0);

    this.getDomElement().toBlob(function(blob: any) {
      let url = URL.createObjectURL(blob);
      let linkElement = document.createElement('a');
      linkElement.href = url;
      linkElement.download = filename + '.png';
      document.body.appendChild(linkElement);
      linkElement.dispatchEvent(new MouseEvent('click'));
      document.body.removeChild(linkElement);
      URL.revokeObjectURL(url);
    });
  }

  /**
   * Generate thumbnails of the scene.
   *
   * The models on the scene should be previously scaled so that their maximum dimension equals 1.
   *
   * @param {string} filename - The filename of the generated zip file.
   * @param {THREE.Vector3} center - The point where the camera will point to.
   */
  public createThumbnails(filename: string, center: THREE.Vector3): void {
    // Auxiliary method to return the canvas as a Promise.
    // This allows us to download all the images when they are ready.
    function getCanvasBlob(canvas: HTMLCanvasElement) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(function(blob: Blob | null) {
          resolve(blob);
        });
      });
    }

    let zip: JSZip = new JSZip();
    const canvas = this.getDomElement();
    const promises = [];

    // Directional light and target.
    const lightTarget = new THREE.Object3D();
    lightTarget.name = 'thumbnails_light_target';
    lightTarget.position.copy(center);
    this.scene.add(lightTarget);

    const light = new THREE.DirectionalLight( 0xffffff, 1.0 );
    light.name = 'thumbnails_light';
    this.scene.add(light);
    light.target = lightTarget;

    // Note: An explicit call to render is required for each image. Otherwise the obtained image will be black.
    // See https://threejsfundamentals.org/threejs/lessons/threejs-tips.html, "Taking A Screenshot of the Canvas"

    // Perspective
    this.camera.position.copy(center);
    this.camera.position.add(new THREE.Vector3(1.6, -1.6, 1.2));
    this.camera.lookAt(center);
    light.position.copy(this.camera.position);
    this.render(0);
    const perspective = getCanvasBlob(canvas);
    perspective.then(function(blob) {
      zip.file('thumbnails/1.png', <Blob>(blob));
    });
    promises.push(perspective);

    // Top
    this.camera.position.copy(center);
    this.camera.position.add(new THREE.Vector3(0, 0, 2.2));
    this.camera.rotation.copy(new THREE.Euler(0, 0, -90 * Math.PI / 180));
    light.position.copy(this.camera.position);
    this.render(0);
    const top = getCanvasBlob(canvas);
    top.then(function(blob) {
      zip.file('thumbnails/2.png', <Blob>(blob));
    });
    promises.push(top);

    // Front
    this.camera.position.copy(center);
    this.camera.position.add(new THREE.Vector3(2.2, 0, 0));
    this.camera.rotation.copy(new THREE.Euler(0, 90 * Math.PI / 180, 90 * Math.PI / 180));
    light.position.copy(this.camera.position);
    this.render(0);
    const front = getCanvasBlob(canvas);
    front.then(function(blob) {
      zip.file('thumbnails/3.png', <Blob>(blob));
    });
    promises.push(front);

    // Side
    this.camera.position.copy(center);
    this.camera.position.add(new THREE.Vector3(0, 2.2, 0));
    this.camera.rotation.copy(new THREE.Euler(-90 * Math.PI / 180, 0, 180 * Math.PI / 180));
    light.position.copy(this.camera.position);
    this.render(0);
    const side = getCanvasBlob(canvas);
    side.then(function(blob) {
      zip.file('thumbnails/4.png', <Blob>(blob));
    });
    promises.push(side);

    // Back
    this.camera.position.copy(center);
    this.camera.position.add(new THREE.Vector3(-2.2, 0, 0));
    this.camera.rotation.copy(new THREE.Euler(90 * Math.PI / 180, -90 * Math.PI / 180, 0));
    light.position.copy(this.camera.position);
    light.position.add(new THREE.Vector3(-2000, 0, 0));
    this.render(0);
    const back = getCanvasBlob(canvas);
    back.then(function(blob) {
      zip.file('thumbnails/5.png', <Blob>(blob));
    });
    promises.push(back);

    Promise.all(promises).then(() => {
      zip.generateAsync({type: 'blob'}).then(function(content: any) {
        const url = URL.createObjectURL(content);
        const linkElement = document.createElement('a');
        linkElement.href = url;
        linkElement.download = filename + '.zip';
        document.body.appendChild(linkElement);
        linkElement.dispatchEvent(new MouseEvent('click'));
        document.body.removeChild(linkElement);
        URL.revokeObjectURL(url);
      });

      this.scene.remove(light);
      this.scene.remove(lightTarget);
    });
  }

  /**
   * Show radial menu
   * @param {} event
   */
  public showRadialMenu(e: any): void {
    /*if (!this.radialMenu)
    {
      return;
    }

    var event = e.originalEvent;

    var pointer = event.touches ? event.touches[ 0 ] : event;
    var pos = new THREE.Vector2(pointer.clientX, pointer.clientY);

    var intersect = new THREE.Vector3();
    var model = this.getRayCastModel(pos, intersect);

    if (model && model.name !== '' && model.name !== 'plane'
        && this.modelManipulator.pickerNames.indexOf(model.name) === -1)
    {
      this.radialMenu.show(event,model);
      this.selectEntity(model);
    }*/
  }

  /**
   * Sets the bounding box of an object while ignoring the addtional visuals.
   * @param {THREE.Box3} - box
   * @param {THREE.Object3D} - object
   */
  public setFromObject(box: THREE.Box3, object: THREE.Object3D): void {
    box.min.x = box.min.y = box.min.z = + Infinity;
    box.max.x = box.max.y = box.max.z = - Infinity;
    var v = new THREE.Vector3();
    object.updateMatrixWorld( true );

    object.traverse( function (node: THREE.Object3D) {
      let i, l;
      if (node instanceof THREE.Mesh)
      {
        let geometry = (node as THREE.Mesh).geometry;

        if (node.name !== 'INERTIA_VISUAL' && node.name !== 'COM_VISUAL')
        {
          if (geometry.isBufferGeometry) {
            let attribute = geometry.getAttribute('position');

            if (attribute !== undefined) {
              for (i = 0, l = attribute.count; i < l; i++) {

                v.fromBufferAttribute(attribute, i).applyMatrix4(
                  node.matrixWorld);

                expandByPoint(v);

              }
            }
          } else {
            console.error('Unable to setFromObject');
          }
        }
      }
    });

    function expandByPoint(point: THREE.Vector3) {
      box.min.min( point );
      box.max.max( point );
    }
  }

  /**
   * Show bounding box for a model. The box is aligned with the world.
   * @param {THREE.Object3D} model
   */
  public showBoundingBox(model: THREE.Object3D): void {
    if (typeof model === 'string') {
      model = this.scene.getObjectByName(model)!;
    }

    if (this.boundingBox.visible) {
      if (this.boundingBox.parent === model) {
        return;
      } else {
        this.hideBoundingBox();
      }
    }

    var box = new THREE.Box3();
    // w.r.t. world
    this.setFromObject(box, model);
    // center vertices with object
    box.min.x = box.min.x - model.position.x;
    box.min.y = box.min.y - model.position.y;
    box.min.z = box.min.z - model.position.z;
    box.max.x = box.max.x - model.position.x;
    box.max.y = box.max.y - model.position.y;
    box.max.z = box.max.z - model.position.z;

    let position = this.boundingBox.geometry.getAttribute('position');
    //var array = position.array;
    position.setXYZ(0, box.max.x, box.max.y, box.max.z);
    position.setXYZ(1, box.min.x, box.max.y, box.max.z);
    position.setXYZ(2, box.min.x, box.min.y, box.max.z);
    position.setXYZ(3, box.max.x, box.min.y, box.max.z);
    position.setXYZ(4, box.max.x, box.max.y, box.min.z);
    position.setXYZ(5, box.min.x, box.max.y, box.min.z);
    position.setXYZ(6, box.min.x, box.min.y, box.min.z);
    position.setXYZ(7, box.max.x, box.min.y, box.min.z);
    position.needsUpdate = true;
    this.boundingBox.geometry.computeBoundingSphere();

    // rotate the box back to the world
    var modelRotation = new THREE.Matrix4();
    modelRotation.extractRotation(model.matrixWorld);
    var modelInverse = new THREE.Matrix4();
    modelInverse.getInverse(modelRotation);
    this.boundingBox.quaternion.setFromRotationMatrix(modelInverse);
    this.boundingBox.name = 'boundingBox';
    this.boundingBox.visible = true;

    // Add box as model's child
    model.add(this.boundingBox);
  }

  /**
   * Hide bounding box
   */
  public hideBoundingBox(): void {
    if(this.boundingBox.parent)
    {
      this.boundingBox.parent.remove(this.boundingBox);
    }
    this.boundingBox.visible = false;
  };

  /**
   * Mouse right click
   * @param {} event
   * @param {} callback - function to be executed to the clicked model
   */
  public onRightClick(event: any, callback: any): void {
    var pos = new THREE.Vector2(event.clientX, event.clientY);
    var model = this.getRayCastModel(pos, new THREE.Vector3());

    if(model && model.name !== '' && model.name !== 'plane'/* &&
        this.modelManipulator.pickerNames.indexOf(model.name) === -1*/)
    {
      callback(model);
    }
  }

  /**
   * Set model's view mode
   * @param {} model
   * @param {} viewAs (normal/transparent/wireframe)
   */
  public setViewAs(model: THREE.Object3D, viewAs: string): void {
    // Toggle
    if ((<ModelUserData>model.userData).viewAs === viewAs) {
      viewAs = 'normal';
    }

    var showWireframe = (viewAs === 'wireframe');
    function materialViewAs(material: THREE.Material)
    {
      if (materials.indexOf(material.id) === -1)
      {
        materials.push(material.id);
        if (viewAs === 'transparent') {
          if (material.opacity) {
            (material as any).originalOpacity = material.opacity;
          }
          else {
            (material as any).originalOpacity = 1.0;
          }
          material.opacity = 0.25;
          material.transparent = true;
        }
        else {
          material.opacity = (material as any).originalOpacity ?
              (material as any).originalOpacity : 1.0;
          if (material.opacity >= 1.0) {
            material.transparent = false;
          }
        }
        // wireframe handling
        (material as any).wireframe = showWireframe;
      }
    }

    let wireframe;
    let descendants: THREE.Object3D[] = [];
    let materials: number[] = [];
    getDescendants(model, descendants);
    for (var i = 0; i < descendants.length; ++i)
    {
      if ((descendants[i] as any).material &&
          descendants[i].name.indexOf('boundingBox') === -1 &&
          descendants[i].name.indexOf('COLLISION_VISUAL') === -1 &&
          !this.getParentByPartialName(descendants[i], 'COLLISION_VISUAL') &&
          descendants[i].name.indexOf('wireframe') === -1 &&
          descendants[i].name.indexOf('JOINT_VISUAL') === -1 &&
          descendants[i].name.indexOf('COM_VISUAL') === -1 &&
          descendants[i].name.indexOf('INERTIA_VISUAL') === -1)
      {
        if (Array.isArray((descendants[i] as any).material)) {
          for (var k = 0; k < (descendants[i] as any).material.length; ++k) {
            materialViewAs((descendants[i] as any).material[k]);
          }
        } else {
          materialViewAs((descendants[i] as any).material);
        }
      }
    }
    if (!model.userData) {
      model.userData = new ModelUserData();
    }
    (<ModelUserData>model.userData).viewAs = viewAs;
  }

  /**
   * Returns the closest parent whose name contains the given string
   * @param {} object
   * @param {} name
   */
  public getParentByPartialName(object: THREE.Object3D, name: string): THREE.Object3D | null {
    var parent = object.parent;
    while (parent && parent !== this.scene) {
      if (parent.name.indexOf(name) !== -1) {
        return parent;
      }

      parent = parent.parent;
    }
    return null;
  }

  /**
   * Select entity
   * @param {} object
   */
  public selectEntity(object: THREE.Object3D | null): void
  {
    if (object)
    {
      if (object !== this.selectedEntity)
      {
        this.showBoundingBox(object);
        this.selectedEntity = object;
      }
      this.attachManipulator(object, this.manipulationMode);
      this.emitter.emit('setTreeSelected', object.name);
    }
    else
    {
      /*if (this.modelManipulator.object)
      {
        this.modelManipulator.detach();
        this.scene.remove(this.modelManipulator.gizmo);
      }*/
      this.hideBoundingBox();
      this.selectedEntity = null;
      this.emitter.emit('setTreeDeselected');
    }
  }

  /**
   * View joints
   * Toggle: if there are joints, hide, otherwise, show.
   * @param {} model
   */
  public viewJoints(model: any): void {
    if (model.joint === undefined || model.joint.length === 0)
    {
      return;
    }

    var child;

    // Visuals already exist
    if (model.jointVisuals)
    {
      // Hide = remove from parent
      if (model.jointVisuals[0].parent !== undefined &&
        model.jointVisuals[0].parent !== null)
      {
        for (var v = 0; v < model.jointVisuals.length; ++v)
        {
          model.jointVisuals[v].parent.remove(model.jointVisuals[v]);
        }
      }
      // Show: attach to parent
      else
      {
        for (var s = 0; s < model.joint.length; ++s)
        {
          child = model.getObjectByName(model.joint[s].child);

          if (!child)
          {
            continue;
          }

          child.add(model.jointVisuals[s]);
        }
      }
    }
    // Create visuals
    else
    {
      model.jointVisuals = [];
      for (var j = 0; j < model.joint.length; ++j)
      {
        child = model.getObjectByName(model.joint[j].child);

        if (!child)
        {
          continue;
        }

        // XYZ expressed w.r.t. child
        var jointVisual = this.jointAxis['XYZaxes'].clone();
        child.add(jointVisual);
        model.jointVisuals.push(jointVisual);
        jointVisual.scale.set(0.7, 0.7, 0.7);

        this.setPose(jointVisual, model.joint[j].pose.position,
            model.joint[j].pose.orientation);

        var mainAxis = null;
        if (model.joint[j].type !== JointTypes.BALL &&
            model.joint[j].type !== JointTypes.FIXED)
        {
          mainAxis = this.jointAxis['mainAxis'].clone();
          jointVisual.add(mainAxis);
        }

        var secondAxis = null;
        if (model.joint[j].type === JointTypes.REVOLUTE2 ||
            model.joint[j].type === JointTypes.UNIVERSAL)
        {
          secondAxis = this.jointAxis['mainAxis'].clone();
          jointVisual.add(secondAxis);
        }

        if (model.joint[j].type === JointTypes.REVOLUTE ||
            model.joint[j].type === JointTypes.GEARBOX)
        {
          mainAxis.add(this.jointAxis['rotAxis'].clone());
        }
        else if (model.joint[j].type === JointTypes.REVOLUTE2 ||
                 model.joint[j].type === JointTypes.UNIVERSAL)
        {
          mainAxis.add(this.jointAxis['rotAxis'].clone());
          secondAxis.add(this.jointAxis['rotAxis'].clone());
        }
        else if (model.joint[j].type === JointTypes.BALL)
        {
          jointVisual.add(this.jointAxis['ballVisual'].clone());
        }
        else if (model.joint[j].type === JointTypes.PRISMATIC)
        {
          mainAxis.add(this.jointAxis['transAxis'].clone());
        }
        else if (model.joint[j].type === JointTypes.SCREW)
        {
          mainAxis.add(this.jointAxis['screwAxis'].clone());
        }

        var direction, tempMatrix, rotMatrix;
        if (mainAxis)
        {
          // main axis expressed w.r.t. parent model or joint frame
          if (!model.joint[j].axis1)
          {
            console.error('no joint axis ' +  model.joint[j].type + 'vs '
              + JointTypes.FIXED);
          }
          if (model.joint[j].axis1.use_parent_model_frame === undefined)
          {
            model.joint[j].axis1.use_parent_model_frame = true;
          }

          direction = new THREE.Vector3(
              model.joint[j].axis1.xyz.x,
              model.joint[j].axis1.xyz.y,
              model.joint[j].axis1.xyz.z);
          direction.normalize();

          tempMatrix = new THREE.Matrix4();
          if (model.joint[j].axis1.use_parent_model_frame)
          {
            tempMatrix.extractRotation(jointVisual.matrix);
            tempMatrix.getInverse(tempMatrix);
            direction.applyMatrix4(tempMatrix);
            tempMatrix.extractRotation(child.matrix);
            tempMatrix.getInverse(tempMatrix);
            direction.applyMatrix4(tempMatrix);
          }

          rotMatrix = new THREE.Matrix4();
          rotMatrix.lookAt(direction, new THREE.Vector3(0, 0, 0), mainAxis.up);
          mainAxis.quaternion.setFromRotationMatrix(rotMatrix);
        }

        if (secondAxis)
        {
          if (model.joint[j].axis2.use_parent_model_frame === undefined)
          {
            model.joint[j].axis2.use_parent_model_frame = true;
          }

          direction = new THREE.Vector3(
              model.joint[j].axis2.xyz.x,
              model.joint[j].axis2.xyz.y,
              model.joint[j].axis2.xyz.z);
          direction.normalize();

          tempMatrix = new THREE.Matrix4();
          if (model.joint[j].axis2.use_parent_model_frame)
          {
            tempMatrix.extractRotation(jointVisual.matrix);
            tempMatrix.getInverse(tempMatrix);
            direction.applyMatrix4(tempMatrix);
            tempMatrix.extractRotation(child.matrix);
            tempMatrix.getInverse(tempMatrix);
            direction.applyMatrix4(tempMatrix);
          }

          secondAxis.position =  direction.multiplyScalar(0.3);
          rotMatrix = new THREE.Matrix4();
          rotMatrix.lookAt(direction, new THREE.Vector3(0, 0, 0), secondAxis.up);
          secondAxis.quaternion.setFromRotationMatrix(rotMatrix);
        }
      }
    }
  }

  /**
   * View Center Of Mass
   * Toggle: if there are COM visuals, hide, otherwise, show.
   * @param {} model
   */
  // This function needs to be migrated to ES6 and the latest THREE
  /*public viewCOM(model: any): void {
    if (model === undefined || model === null)
    {
      return;
    }
    if (model.children.length === 0)
    {
      return;
    }

    var child;

    // Visuals already exist
    if (model.COMVisuals)
    {
      // Hide = remove from parent
      if (model.COMVisuals[0].parent !== undefined &&
        model.COMVisuals[0].parent !== null)
      {
        for (var v = 0; v < model.COMVisuals.length; ++v)
        {
          for (var k = 0; k < 3; k++)
          {
            model.COMVisuals[v].parent.remove(model.COMVisuals[v].crossLines[k]);
          }
          model.COMVisuals[v].parent.remove(model.COMVisuals[v]);
        }
      }
      // Show: attach to parent
      else
      {
        for (var s = 0; s < model.children.length; ++s)
        {
          child = model.getObjectByName(model.children[s].name);

          if (!child || child.name === 'boundingBox')
          {
            continue;
          }

          child.add(model.COMVisuals[s].crossLines[0]);
          child.add(model.COMVisuals[s].crossLines[1]);
          child.add(model.COMVisuals[s].crossLines[2]);
          child.add(model.COMVisuals[s]);
        }
      }
    }
    // Create visuals
    else
    {
      model.COMVisuals = [];
      let COMVisual: THREE.Object3D;
      let helperGeometry_1: THREE.BufferGeometry;
      let helperGeometry_2: THREE.BufferGeometry;
      let helperGeometry_3: THREE.BufferGeometry;

      var box, line_1, line_2, line_3, helperMaterial, points = new Array(6);
      for (var j = 0; j < model.children.length; ++j)
      {
        child = model.getObjectByName(model.children[j].name);

        if (!child) {
          continue;
        }

        if (child.userData.inertial)
        {
          let inertialPose: Pose = new Pose();
          let userdatapose: Pose = new Pose();
          let inertialMass: number = 0;
          let radius: number = 0;
          var mesh = {};
          var inertial = child.userData.inertial;

          userdatapose = child.userData.inertial.pose;
          inertialMass = inertial.mass;

          // calculate the radius using lead density
          radius = Math.cbrt((0.75 * inertialMass ) / (Math.PI * 11340));

          COMVisual = this.COMvisual.clone();
          child.add(COMVisual);
          model.COMVisuals.push(COMVisual);
          COMVisual.scale.set(radius, radius, radius);

          var position = new THREE.Vector3(0, 0, 0);

          // get euler rotation and convert it to Quaternion
          var quaternion = new THREE.Quaternion();
          var euler = new THREE.Euler(0, 0, 0, 'XYZ');
          quaternion.setFromEuler(euler);

          inertialPose = {
            position: position,
            orientation: quaternion
          };

          if (userdatapose !== undefined) {
            this.setPose(COMVisual, userdatapose.position,
              userdatapose.orientation);
              inertialPose = userdatapose;
          }

          (COMVisual as any).crossLines = [];

          // Store link's original rotation (w.r.t. the model)
          var originalRotation = new THREE.Euler();
          originalRotation.copy(child.rotation);

          // Align link with world (reverse parent rotation w.r.t. the world)
          child.setRotationFromMatrix(
            new THREE.Matrix4().getInverse(child.parent.matrixWorld));

          // Get its bounding box
          box = new THREE.Box3();

          box.setFromObject(child);

          // Rotate link back to its original rotation
          child.setRotationFromEuler(originalRotation);

          // w.r.t child
          var worldToLocal = new THREE.Matrix4();
          worldToLocal.getInverse(child.matrixWorld);
          box.applyMatrix4(worldToLocal);

          // X
          points[0] = new THREE.Vector3(box.min.x, inertialPose.position.y,
            inertialPose.position.z);
          points[1] = new THREE.Vector3(box.max.x, inertialPose.position.y,
              inertialPose.position.z);
          // Y
          points[2] = new THREE.Vector3(inertialPose.position.x, box.min.y,
                inertialPose.position.z);
          points[3] = new THREE.Vector3(inertialPose.position.x, box.max.y,
                  inertialPose.position.z);
          // Z
          points[4] = new THREE.Vector3(inertialPose.position.x,
            inertialPose.position.y, box.min.z);
          points[5] = new THREE.Vector3(inertialPose.position.x,
            inertialPose.position.y, box.max.z);

          helperGeometry_1 = new THREE.BufferGeometry();
          helperGeometry_1.vertices.push(points[0]);
          helperGeometry_1.vertices.push(points[1]);

          helperGeometry_2 = new THREE.BufferGeometry();
          helperGeometry_2.vertices.push(points[2]);
          helperGeometry_2.vertices.push(points[3]);

          helperGeometry_3 = new THREE.Geometry();
          helperGeometry_3.vertices.push(points[4]);
          helperGeometry_3.vertices.push(points[5]);

          helperMaterial = new THREE.LineBasicMaterial({color: 0x00ff00});

          line_1 = new THREE.Line(helperGeometry_1, helperMaterial,
              THREE.LineSegments);
          line_2 = new THREE.Line(helperGeometry_2, helperMaterial,
              THREE.LineSegments);
          line_3 = new THREE.Line(helperGeometry_3, helperMaterial,
              THREE.LineSegments);

          line_1.name = 'COM_VISUAL';
          line_2.name = 'COM_VISUAL';
          line_3.name = 'COM_VISUAL';
          COMVisual.crossLines.push(line_1);
          COMVisual.crossLines.push(line_2);
          COMVisual.crossLines.push(line_3);

          // show lines
          child.add(line_1);
          child.add(line_2);
          child.add(line_3);
         }
      }
    }
  }*/

  // TODO: Issue https://bitbucket.org/osrf/gzweb/issues/138
  /**
   * View inertia
   * Toggle: if there are inertia visuals, hide, otherwise, show.
   * @param {} model
   */
  // This function needs to be migrated to ES6 and the latest THREE
  /*public viewInertia(model: any): void {
    if (model === undefined || model === null)
    {
      return;
    }

    if (model.children.length === 0)
    {
      return;
    }

    var child;

    // Visuals already exist
    if (model.inertiaVisuals)
    {
      // Hide = remove from parent
      if (model.inertiaVisuals[0].parent !== undefined &&
        model.inertiaVisuals[0].parent !== null)
      {
        for (var v = 0; v < model.inertiaVisuals.length; ++v)
        {
          for (var k = 0; k < 3; k++)
          {
            model.inertiaVisuals[v].parent.remove(
              model.inertiaVisuals[v].crossLines[k]);
          }
          model.inertiaVisuals[v].parent.remove(model.inertiaVisuals[v]);
        }
      }
      // Show: attach to parent
      else
      {
        for (var s = 0; s < model.children.length; ++s)
        {
          child = model.getObjectByName(model.children[s].name);

          if (!child || child.name === 'boundingBox')
          {
            continue;
          }
          child.add(model.inertiaVisuals[s].crossLines[0]);
          child.add(model.inertiaVisuals[s].crossLines[1]);
          child.add(model.inertiaVisuals[s].crossLines[2]);
          child.add(model.inertiaVisuals[s]);
        }
      }
    }
    // Create visuals
    else
    {
      model.inertiaVisuals = [];
      var box , line_1, line_2, line_3, helperGeometry_1, helperGeometry_2,
      helperGeometry_3, helperMaterial, inertial, inertiabox,
      points = new Array(6);
      for (var j = 0; j < model.children.length; ++j)
      {
        child = model.getObjectByName(model.children[j].name);

        if (!child)
        {
          continue;
        }

        inertial = child.userData.inertial;
        if (inertial)
        {
          var mesh, boxScale, Ixx, Iyy, Izz, mass, inertia, material = {};
          let inertialPose: Pose;

          if (inertial.pose)
          {
            inertialPose = child.userData.inertial.pose;
          }
          else if (child.position)
          {
            inertialPose.position = child.position;
            inertialPose.orientation = child.quaternion;
          }
          else
          {
            console.warn('Link pose not found!');
            continue;
          }

          mass = inertial.mass;
          inertia = inertial.inertia;
          Ixx = inertia.ixx;
          Iyy = inertia.iyy;
          Izz = inertia.izz;
          boxScale = new THREE.Vector3();

          if (mass < 0 || Ixx < 0 || Iyy < 0 || Izz < 0 ||
            Ixx + Iyy < Izz || Iyy + Izz < Ixx || Izz + Ixx < Iyy)
          {
            // Unrealistic inertia, load with default scale
            console.warn('The link ' + child.name + ' has unrealistic inertia, '
                  +'unable to visualize box of equivalent inertia.');
          }
          else
          {
            // Compute dimensions of box with uniform density
            // and equivalent inertia.
            boxScale.x = Math.sqrt(6*(Izz +  Iyy - Ixx) / mass);
            boxScale.y = Math.sqrt(6*(Izz +  Ixx - Iyy) / mass);
            boxScale.z = Math.sqrt(6*(Ixx  + Iyy - Izz) / mass);

            inertiabox = new THREE.Object3D();
            inertiabox.name = 'INERTIA_VISUAL';

            // Inertia indicator: equivalent box of uniform density
            mesh = this.createBox(1, 1, 1);
            mesh.name = 'INERTIA_VISUAL';
            material = {'ambient':[1,0.0,1,1],'diffuse':[1,0.0,1,1],
              'depth_write':false,'opacity':0.5};
            this.setMaterial(mesh, material);
            inertiabox.add(mesh);
            inertiabox.name = 'INERTIA_VISUAL';
            child.add(inertiabox);

            model.inertiaVisuals.push(inertiabox);
            inertiabox.scale.set(boxScale.x, boxScale.y, boxScale.z);
            inertiabox.crossLines = [];

            this.setPose(inertiabox, inertialPose.position,
              inertialPose.orientation);
            // show lines
            box = new THREE.Box3();
            // w.r.t. world
            box.setFromObject(child);
            points[0] = new THREE.Vector3(inertialPose.position.x,
              inertialPose.position.y,
              -2 * boxScale.z + inertialPose.position.z);
            points[1] = new THREE.Vector3(inertialPose.position.x,
              inertialPose.position.y, 2 * boxScale.z + inertialPose.position.z);
            points[2] = new THREE.Vector3(inertialPose.position.x,
              -2 * boxScale.y + inertialPose.position.y ,
              inertialPose.position.z);
            points[3] = new THREE.Vector3(inertialPose.position.x,
              2 * boxScale.y + inertialPose.position.y, inertialPose.position.z);
            points[4] = new THREE.Vector3(
              -2 * boxScale.x + inertialPose.position.x,
              inertialPose.position.y, inertialPose.position.z);
            points[5] = new THREE.Vector3(
              2 * boxScale.x + inertialPose.position.x,
              inertialPose.position.y, inertialPose.position.z);

            helperGeometry_1 = new THREE.Geometry();
            helperGeometry_1.vertices.push(points[0]);
            helperGeometry_1.vertices.push(points[1]);

            helperGeometry_2 = new THREE.Geometry();
            helperGeometry_2.vertices.push(points[2]);
            helperGeometry_2.vertices.push(points[3]);

            helperGeometry_3 = new THREE.Geometry();
            helperGeometry_3.vertices.push(points[4]);
            helperGeometry_3.vertices.push(points[5]);

            helperMaterial = new THREE.LineBasicMaterial({color: 0x00ff00});
            line_1 = new THREE.Line(helperGeometry_1, helperMaterial,
                THREE.LineSegments);
            line_2 = new THREE.Line(helperGeometry_2, helperMaterial,
              THREE.LineSegments);
            line_3 = new THREE.Line(helperGeometry_3, helperMaterial,
              THREE.LineSegments);

            line_1.name = 'INERTIA_VISUAL';
            line_2.name = 'INERTIA_VISUAL';
            line_3.name = 'INERTIA_VISUAL';
            inertiabox.crossLines.push(line_1);
            inertiabox.crossLines.push(line_2);
            inertiabox.crossLines.push(line_3);

            // attach lines
            child.add(line_1);
            child.add(line_2);
            child.add(line_3);
          }
        }
      }
    }
  }*/

  /**
   * Update a light entity from a message
   * @param {} entity
   * @param {} msg
   */
  // This function needs to be migrated to ES6 and the latest THREE
  /*public updateLight(entity: any, msg: any): void {
    // TODO: Generalize this and createLight
    var lightObj = entity.children[0];
    var dir;

    var color = new THREE.Color();

    if (msg.diffuse)
    {
      color.r = msg.diffuse.r;
      color.g = msg.diffuse.g;
      color.b = msg.diffuse.b;
      lightObj.color = color.clone();
    }
    if (msg.specular)
    {
      color.r = msg.specular.r;
      color.g = msg.specular.g;
      color.b = msg.specular.b;
    }

    var matrixWorld;
    if (msg.pose)
    {
      // needed to update light's direction
      this.setPose(entity, msg.pose.position, msg.pose.orientation);
      entity.matrixWorldNeedsUpdate = true;
    }

    if (msg.range)
    {
      // THREE.js's light distance impacts the attenuation factor defined in the
      // shader:
      // attenuation factor = 1.0 - distance-to-enlighted-point / light.distance
      // Gazebo's range (taken from OGRE 3D API) does not contribute to
      // attenuation; it is a hard limit for light scope.
      // Nevertheless, we identify them for sake of simplicity.
      lightObj.distance = msg.range;
    }

    if (msg.cast_shadows)
    {
      lightObj.castShadow = msg.cast_shadows;
    }

    if (msg.attenuation_constant)
    {
      // no-op
    }
    if (msg.attenuation_linear)
    {
      lightObj.intensity = lightObj.intensity/(1+msg.attenuation_linear);
    }
    if (msg.attenuation_quadratic)
    {
      lightObj.intensity = lightObj.intensity/(1+msg.attenuation_quadratic);
    }

  //  Not handling these on gzweb for now
  //
  //  if (lightObj instanceof THREE.SpotLight) {
  //    if (msg.spot_outer_angle) {
  //      lightObj.angle = msg.spot_outer_angle;
  //    }
  //    if (msg.spot_falloff) {
  //      lightObj.exponent = msg.spot_falloff;
  //    }
  //  }

    if (msg.direction)
    {
      dir = new THREE.Vector3(msg.direction.x, msg.direction.y,
          msg.direction.z);

      entity.direction = new THREE.Vector3();
      entity.direction.copy(dir);

      if (lightObj.target)
      {
        lightObj.target.position.copy(dir);
      }
    }
  }*/

  /**
   * Adds an sdf model to the scene.
   * @param {object} sdf - It is either SDF XML string or SDF XML DOM object
   * @returns {THREE.Object3D}
   */
  // This function needs to be migrated to ES6 and the latest THREE
  /*public createFromSdf(sdf: any): THREE.Object3D {
    if (sdf === undefined)
    {
      console.error(' No argument provided ');
      return;
    }

    var obj = new THREE.Object3D();

    var sdfXml = this.spawnModel.sdfParser.parseXML(sdf);
    // sdfXML is always undefined, the XML parser doesn't work while testing
    // while it does work during normal usage.
    var myjson = xmlParser.xml2json(sdfXml, '\t');
    var sdfObj = JSON.parse(myjson).sdf;

    var mesh = this.spawnModel.sdfParser.spawnFromSDF(sdf);
    if (!mesh)
    {
      return;
    }

    obj.name = mesh.name;
    obj.add(mesh);

    return obj;
  }*/

  /**
   * Adds a lighting setup that is great for single model visualization. This
   * will not alter existing lights.
   */
  public addModelLighting(): void {
    this.ambient.color = new THREE.Color(0x666666);

    // And light1. Upper back fill light.
    var light1 = this.createLight(3,
      // Diffuse
      new Color(0.2, 0.2, 0.2, 1.0),
      // Intensity
      0.5,
      // Pose
      new Pose(new THREE.Vector3(0, 10, 10), new THREE.Quaternion(0, 0, 0, 1)),
      // Distance
      undefined,
      // Cast shadows
      true,
      // Name
      '__model_light1__',
      // Direction
      new THREE.Vector3(0, -0.707, -0.707),
      // Specular
      new Color(0.3, 0.3, 0.3, 1.0));
    this.add(light1);

    // And light2. Lower back fill light
    var light2 = this.createLight(3,
      // Diffuse
      new Color(0.4, 0.4, 0.4, 1.0),
      // Intensity
      0.5,
      // Pose
      new Pose(new THREE.Vector3(0, 10, -10), new THREE.Quaternion(0, 0, 0, -1)),
      // Distance
      undefined,
      // Cast shadows
      true,
      // Name
      '__model_light2__',
      // Direction
      new THREE.Vector3(0, -0.707, 0.707),
      // Specular
      new Color(0.3, 0.3, 0.3, 1.0));
    this.add(light2);

    // And light3. Front fill light.
    var light3 = this.createLight(3,
      // Diffuse
      new Color(0.5, 0.5, 0.5, 1.0),
      // Intensity
      0.4,
      // Pose
      new Pose(new THREE.Vector3(-10, -10, 10), new THREE.Quaternion(0, 0, 0, 1)),
      // Distance
      undefined,
      // Cast shadows
      true,
      // Name
      '__model_light2__',
      // Direction
      new THREE.Vector3(0.707, 0.707, 0),
      // Specular
      new Color(0.3, 0.3, 0.3, 1.0));
    this.add(light3);

    // And light4. Front key light.
    var light4 = this.createLight(3,
      // Diffuse
      new Color(1, 1, 1, 1.0),
      // Intensity
      0.8,
      // Pose
      new Pose(new THREE.Vector3(10, -10, 10), new THREE.Quaternion(0, 0, 0, 1)),
      // Distance
      undefined,
      // Cast shadows
      true,
      // Name
      '__model_light2__',
      // Direction
      new THREE.Vector3(-0.707, 0.707,  0),
      // Specular
      new Color(0.8, 0.8, 0.8, 1.0));
    this.add(light4);
  }

  /**
   * Dispose all the resources used by the scene.
   *
   * This should be called whenever the visualization stops, in order to free resources.
   * See: https://threejs.org/docs/index.html#manual/en/introduction/How-to-dispose-of-objects
   */
  public cleanup(): void {
    let objects: THREE.Object3D[] = [];
    getDescendants(this.scene, objects);

    var that = this;
    objects.forEach(function(obj: THREE.Object3D) {
      that.scene.remove(obj);

      // Dispose geometries.
      if ((obj as any).geometry) {
        (obj as any).geometry.dispose();
      }

      // Dispose materials and their textures.
      if ((obj as any).material) {
        // Materials can be an array. If there is only one, convert it to an array for easier handling.
        if (!((obj as any).material instanceof Array)) {
          (obj as any).material = [(obj as any).material];
        }

        // Materials can have different texture maps, depending on their type.
        // We check each property of the Material and dispose them if they are Textures.
        (obj as any).material.forEach(function(material: any) {
          Object.keys(material).forEach(function(property: any) {
            if (material[property] instanceof THREE.Texture) {
              material[property].dispose();
            }
          });

          material.dispose();
        });
      }
    });

    // Destroy particles.
    if (this.nebulaSystem) {
      this.nebulaSystem.destroy();
    }

    // Clean scene and renderer.
    this.renderer.renderLists.dispose();
    this.renderer.dispose();
  }

  /**
   * Set a request header for internal requests.
   *
   * @param {string} header - The header to send in the request.
   * @param {string} value - The value to set to the header.
   */
  public setRequestHeader(header: string, value: string): void {
    // ES6 syntax for computed object keys.
    const headerObject = { [header]: value };

    this.textureLoader.requestHeader = headerObject;
    this.colladaLoader.requestHeader = headerObject;
    this.stlLoader.requestHeader = headerObject;

    this.requestHeader = headerObject;

    // Change the texture loader, if the requestHeader is present.
    // Texture Loaders use an Image Loader internally, instead of a File Loader.
    // Image Loader uses an img tag, and their src request doesn't accept
    // custom headers.
    // See https://github.com/mrdoob/three.js/issues/10439
    if (this.requestHeader) {
      this.textureLoader.load = function(url, onLoad, onProgress, onError) {
        var fileLoader = new THREE.FileLoader();
        fileLoader.setResponseType('blob');
        fileLoader.setRequestHeader(this.requestHeader);
        let texture: THREE.Texture = new THREE.Texture();
        let image: HTMLImageElement =
          <HTMLImageElement>(document.createElementNS(
            'http://www.w3.org/1999/xhtml', 'img'));

        // Once the image is loaded, we need to revoke the ObjectURL.
        image.onload = function () {
          image.onload = null;
          URL.revokeObjectURL( image.src );
          texture.image = image;
          texture.needsUpdate = true;

          if (onLoad) {
            onLoad(texture);
          }
        };

        image.onerror = onError as any;

        // Once the image is loaded, we need to revoke the ObjectURL.
        fileLoader.load(
          url,
          function(blob: any) {
            image.src = URL.createObjectURL(blob);
          },
          onProgress,
          onError
        );

        return texture;
      };
    }
  };

  /**
   * Get the Nebula System.
   *
   * The System is usually required by render loops in order to be updated.
   *
   * @returns The Nebula System, or undefined if it wasn't set.
   */
  public getParticleSystem(): NebulaSystem | undefined {
    return this.nebulaSystem;
  }

  /**
   * Get the Nebula Renderer.
   *
   * Used by emitters to render particles.
   *
   * @returns The Nebula Renderer, or undefined if it wasn't set.
   */
  public getParticleRenderer(): SpriteRenderer | undefined {
    return this.nebulaRenderer;
  }

  /**
   * Set the Nebula System in order to use particles.
   *
   * @param system The Nebula System.
   * @param renderer The renderer the Nebula System will use.
   */
  public setupParticleSystem(system: NebulaSystem, renderer: SpriteRenderer) {
    this.nebulaSystem = system;
    this.nebulaRenderer = renderer;
  }

 /**
  * Print out the scene graph with position of each node.
  */
  public printScene(): void {
    const printGraph = (obj: THREE.Object3D): void => {
      console.group(
        `<${obj.type}> ${obj.name} pos: ${obj.position.x}, ${obj.position.y}, ${obj.position.z}`
      );
      obj.children.forEach(printGraph);
      console.groupEnd();
    }
    printGraph(this.scene);
  }

  public loadTexture(url: string, onLoad?: any, onProgress?:any): THREE.Texture {
    // Return the cached texture if it exists.
    if (this.textureCache.has(url)) {
      return this.textureCache.get(url)!;
    }

    let fallbackLoader = (map: string, texture: THREE.Texture) => {
      if (this.findResourceCb) {
        // Get the image using the find resource callback.
        this.findResourceCb(map, (image: any, error?: string) => {
          if (error !== undefined) {
            // Mark the texture as error in the loading manager.
            const manager = this.textureLoader.manager as WsLoadingManager;
            manager.markAsError(map);
            return;
          }

          // Create the image element
          let imageElem: HTMLImageElement = <HTMLImageElement>(
            document.createElementNS('http://www.w3.org/1999/xhtml', 'img'));

          const isJPEG = map.search( /\.jpe?g($|\?)/i ) > 0 || map.search( /^data\:image\/jpeg/ ) === 0;

          let binary = '';
          const len = image.byteLength;
          for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(image[i]);
          }

          // Set the image source using base64 encoding
          imageElem.src = isJPEG ? 'data:image/jpg;base64,' :
            'data:image/png;base64,';
          imageElem.src += window.btoa(binary);

          texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
          texture.needsUpdate = true;
          texture.image = imageElem;

          // Mark the texture as done in the loading manager.
          const manager = this.textureLoader.manager as WsLoadingManager;
          manager.markAsDone(map);
        });
      }
    }

    let result = this.textureLoader.load(
      url,
      onLoad,
      onProgress,
      (_error) => {
        let scopeTexture = result;
        fallbackLoader(url, scopeTexture);
    });

    // Cache the texture so that we don't try to load it multiple times.
    this.textureCache.set(url, result);

    return result;
  }
}



---
File: /src/SceneManager.ts
---

import * as THREE from 'three';
import { AudioTopic } from './AudioTopic';
import { Publisher } from './Publisher';
import { Scene } from './Scene';
import { SDFParser } from './SDFParser';
import { Shaders } from './Shaders';
import { map, Observable, Subscription } from 'rxjs';
import { Topic } from './Topic';
import { Transport } from './Transport';

/**
 * Interface used to pass arguments to the SceneManager constructor.
 */
export interface SceneManagerConfig {
  /**
   * ElementId is the id of the HTML element that will hold the rendering
   * context. If not specified, the id gz-scene will be used.
   */
  elementId?: string;

  /**
   * A websocket url that points to a Gazebo server.
   */
  websocketUrl?: string;

  /**
   * An authentication key for the websocket server.
   */
  websocketKey?: string;

  /**
   * The name of a an audio control topic, used to play audio files.
   */
  audioTopic?: string;

  /**
   * Name of the topic to advertise.
   */
  topicName?: string;

  /**
   * Message type of the topic to advertise.
   */
  msgType?: string;

  /**
   * Message data of the topic to advertise.
   */
  msgData?: any;

  /**
   * Whether or not lights in models are visible.
   */
  enableLights?: boolean;
}

/**
 * SceneManager handles the interface between a Gazebo server and the
 * rendering scene. A user of gzweb will typically create a SceneManager and
 * then connect the SceneManager to a Gazebo server's websocket.
 *
 * This example will connect to a Gazebo server's websocket at WS_URL, and
 * start the rendering process. Rendering output will be placed in the HTML
 * element with the id ELEMENT_ID
 *
 * ```
 * let sceneMgr = new SceneManager(ELEMENT_ID, WS_URL, WS_KEY);
 * ```
 */
export class SceneManager {
  /**
   * Particle emitter updates.
   */
  private particleEmittersSubscription: Subscription;

  /**
   * Subscription for status updates.
   */
  private statusSubscription: Subscription;

  /**
   * Connection status from the Websocket.
   */
  private connectionStatus: string = 'disconnected';

  /**
   * Scene Information updates.
   */
  private sceneInfoSubscription: Subscription;

  /**
   * Scene information obtained from the Websocket.
   */
  private sceneInfo: object;

  /**
   * Gz3D Scene.
   */
  private scene: any;

  /**
   * List of 3d models.
   */
  private models: any[] = [];

  /**
   * A sun directional light for global illumination
   */
  private sunLight: object;

  /**
   * A Transport interface used to connect to a Gazebo server.
   */
  private transport = new Transport();

  /**
   * ID of the Request Animation Frame method. Required to cancel the animation.
   */
  private cancelAnimation: number;

  /**
   *
   */
  private previousRenderTimestampMs: number = 0;

  /**
   * The container of the Scene.
   */
  private sceneElement: HTMLElement;

  /**
   * Gz3D SDF parser.
   */
  private sdfParser: any;

  /**
   * Name of the HTML element that will hold the rendering scene.
   */
  private elementId: string = 'gz-scene';

  /**
   * Name of an audio topic, which can be used to playback audio files.
   */
  private audioTopic: string;

  /*
   * Name of the topic to advertise.
   */
  private topicName: string;

  /*
   * Message type of the topic to advertise.
   */
  private msgType: string;

  /*
   * Message data of the topic to advertise.
   */
  private msgData: any

  /*
   * Publisher object to publish to a topic
   */
  private publisher: Publisher;

  /*
   * Whether or not lights in models are visible. Enabled by default.
   */
  private enableLights: boolean = true;

  /**
   * Constructor. If a url is specified, then then SceneManager will connect
   * to the specified websocket server. Otherwise, the `connect` function
   * should be called after construction.
   * @param params Optional. The scene manager configuration options
   *
   */
  constructor( config: SceneManagerConfig = {}) {
    this.elementId = config.elementId ?? 'gz-scene';

    if (config.audioTopic) {
      this.audioTopic = config.audioTopic;
    }

    if (
      config.topicName &&
      config.msgType &&
      config.msgData
    ) {
      this.topicName = config.topicName;
      this.msgType = config.msgType;
      this.msgData = config.msgData;
    }

    if (config.websocketUrl) {
      this.connect(config.websocketUrl, config.websocketKey);
    }

    if (config.enableLights !== undefined) {
      this.enableLights = config.enableLights;
    }
  }

  /**
   * Destrory the scene
   */
  public destroy(): void {
    this.disconnect();

    if (this.cancelAnimation) {
      cancelAnimationFrame(this.cancelAnimation);
    }

    this.previousRenderTimestampMs = 0;

    if (this.scene) {
      this.scene.cleanup();
    }
  }

  /**
   * Get the current connection status to a Gazebo server.
   */
  public getConnectionStatus(): string {
    return this.connectionStatus;
  }

  /**
   * Get the connection status as an observable.
   * Allows clients to subscribe to this stream, to let them know when the connection to Gazebo
   * is ready for communication.
   *
   * @returns An Observable of a boolean: Whether the connection status is ready or not.
   */
  public getConnectionStatusAsObservable(): Observable<boolean> {
    return this.transport.getConnectionStatus().pipe(
      map((status) => status === 'ready'),
    );
  }

  /**
   * Change the width and height of the visualization upon a resize event.
   */
  public resize(): void {
    if (this.scene) {
      this.scene.setSize(this.sceneElement.clientWidth,
                         this.sceneElement.clientHeight);
    }
  }

  public snapshot(): void {
    if (this.scene) {
      this.scene.saveScreenshot(this.transport.getWorld());
    }
  }

  public resetView(): void {
    if (this.scene) {
      this.scene.resetView();
    }
  }

  public follow(entityName: string): void {
    if (this.scene) {
      this.scene.emitter.emit('follow_entity', entityName);
    }
  }

  public thirdPersonFollow(entityName: string): void {
    if (this.scene) {
      this.scene.emitter.emit('third_person_follow_entity', entityName);
    }
  }

  public firstPerson(entityName: string): void {
    if (this.scene) {
      this.scene.emitter.emit('first_person_entity', entityName);
    }
  }

  public moveTo(entityName: string): void {
    if (this.scene) {
      this.scene.emitter.emit('move_to_entity', entityName);
    }
  }

  public select(entityName: string): void {
    if (this.scene) {
      this.scene.emitter.emit('select_entity', entityName);
    }
  }

  /**
   * Publishes a message to an advertised topic.
   */
  public publish(): void {
    if (this.scene && this.publisher) {
      let msg = this.publisher.createMessage(this.msgData);
      this.publisher.publish(msg);
    }
  }

  /**
   * Get the list of models in the scene
   * @return The list of available models.
   */
  public getModels(): any[] {
    return this.models;
  }

  /**
   * Disconnect from the Gazebo server
   */
  public disconnect(): void {
    // Remove the canvas. Helpful to disconnect and connect several times.
    if (this.sceneElement?.childElementCount > 0 && this.scene.scene.renderer?.domElement) {
      this.sceneElement.removeChild(this.scene.scene.renderer.domElement);
    }

    this.transport.disconnect();
    this.sceneInfo = {};
    this.connectionStatus = 'disconnected';

    // Unsubscribe from observables.
    if (this.sceneInfoSubscription) {
      this.sceneInfoSubscription.unsubscribe();
    }
    if (this.particleEmittersSubscription) {
      this.particleEmittersSubscription.unsubscribe();
    }

    if (this.statusSubscription) {
      this.statusSubscription.unsubscribe();
    }
  }

  /**
   * Connect to a Gazebo server
   * @param url A websocket url that points to a Gazebo server.
   * @param key An optional authentication key.
   */
  public connect(url: string, key?: string): void {
    this.transport.connect(url, key);

    this.statusSubscription = this.transport.getConnectionStatus().subscribe((response) => {
      if (response === 'error') {
        // TODO: Return an error so the caller can open a snackbar
        console.log('Connection failed. Please contact an administrator.');
        // this.snackBar.open('Connection failed. Please contact an administrator.', 'Got it');
      }

      this.connectionStatus = response;

      // We can start setting up the visualization after we are Connected.
      // We still don't have scene and world information at this step.
      if (response === 'connected') {
        this.setupVisualization();
      }

      // Once the status is ready, we have the world and scene information
      // available.
      if (response === 'ready') {
        this.subscribeToTopics();
        if (this.topicName) {
          this.publisher = this.advertise(this.topicName, this.msgType);
          console.log(`Advertised ${this.topicName} with msg type of
                      ${this.msgType}`);
        }
      }
    });

    // Scene information.
    this.sceneInfoSubscription = this.transport.sceneInfo$.subscribe((sceneInfo) => {
      if (!sceneInfo) {
        return;
      }

      if ('sky' in sceneInfo && sceneInfo['sky']) {
        const sky = sceneInfo['sky'];

        // Check to see if a cubemap has been specified in the header.
        if ('header' in sky && sky['header'] && sky['header']['data']) {
          const data = sky['header']['data'];
          for (let i = 0; i < data.length; ++i) {
            if (data[i]['key'] === 'cubemap_uri' &&
                data[i]['value'] !== undefined) {
              this.scene.addSky(data[i]['value'][0]);
            }
          }
        } else {
          this.scene.addSky();
        }
      }
      this.sceneInfo = sceneInfo;
      this.startVisualization();

      sceneInfo['model'].forEach((model: any) => {
        const modelObj = this.sdfParser.spawnFromObj(
          { model }, { enableLights: this.enableLights });

        model['gz3dName'] = modelObj.name;
        this.models.push(model);
        this.scene.add(modelObj);
      });

      sceneInfo['light'].forEach((light: any) => {
        const lightObj = this.sdfParser.spawnLight(light);
        this.scene.add(lightObj);
      });

      // Set the ambient color, if present
      if (sceneInfo['ambient'] !== undefined &&
          sceneInfo['ambient'] !== null) {
        this.scene.ambient.color = new THREE.Color(
          sceneInfo['ambient']['r'],
          sceneInfo['ambient']['g'],
          sceneInfo['ambient']['b']);
      }
    });
  }

  /**
   * Advertise a topic.
   *
   * @param topic The topic to advertise.
   */
  public advertise(topic: string, msgTypeName: string): Publisher {
    return this.transport.advertise(topic, msgTypeName);
  }

  /**
   * Allows clients to subscribe to a custom topic.
   *
   * @param topic The topic to subscribe to.
   */
  public subscribeToTopic(topic: Topic): void {
    this.transport.subscribe(topic);
  }

  /**
   * Allows clients to unsubscribe from topics.
   *
   * @param name The name of the topic to unsubscribe from.
   */
  public unsubscribeFromTopic(name: string): void {
    this.transport.unsubscribe(name);
  }

  /**
   * Play the Simulation.
   */
  public play(): void {
    this.transport.requestService(
      `/world/${this.transport.getWorld()}/control`,
      'ignition.msgs.WorldControl',
      {pause: false}
    );
  }

  /**
   * Pause the Simulation.
   */
  public pause(): void {
    this.transport.requestService(
      `/world/${this.transport.getWorld()}/control`,
      'ignition.msgs.WorldControl',
      {pause: true}
    );
  }

  /**
   * Stop the Simulation.
   */
  public stop(): void {
    this.transport.requestService(
      '/server_control',
      'ignition.msgs.ServerControl',
      {stop: true}
    );
  }

  /**
   * Subscribe to Gazebo topics required to render a scene.
   *
   * This includes:
   * - /world/WORLD_NAME/dynamic_pose/info
   * - /world/WORLD_NAME/scene/info
   */
  private subscribeToTopics(): void {
    // Subscribe to the pose topic and modify the models' poses.
    const poseTopic = new Topic(
      `/world/${this.transport.getWorld()}/dynamic_pose/info`,
      (msg) => {
        msg['pose'].forEach((pose: any) => {
          let entityName = pose['name'];
          // Objects created by Gz3D have an unique name, which is the
          // name plus the id.
          const entity = this.scene.getByName(entityName);

          if (entity) {
            this.scene.setPose(entity, pose.position, pose.orientation);
          } else {
            console.warn('Unable to find entity with name ', entityName, entity);
          }
        });
      }
    );
    this.transport.subscribe(poseTopic);

    // Subscribe to the audio control topic.
    if (this.audioTopic) {
      const audioTopic = new AudioTopic(this.audioTopic, this.transport);
    }

    // Subscribe to the 'scene/info' topic which sends scene changes.
    const sceneTopic = new Topic(
      `/world/${this.transport.getWorld()}/scene/info`,
      (sceneInfo) => {
        if (!sceneInfo) {
          return;
        }

        // Process each model in the scene.
        sceneInfo['model'].forEach((model: any) => {

          // Check to see if the model already exists in the scene. This
          // could happen when a simulation level is loaded multiple times.
          let foundIndex = this.getModelIndex(model['name']);

          // If the model was not found, then add the new model. Otherwise
          // update the models ID.
          if (foundIndex < 0) {
            const modelObj = this.sdfParser.spawnFromObj(
              { model }, { enableLights: this.enableLights });
            this.models.push(model);
            this.scene.add(modelObj);
          } else {
            // Make sure to update the exisiting models so that future pose
            // messages can update the model.
            this.models[foundIndex]['id'] = model['id'];
          }
        });
      }
    );
    this.transport.subscribe(sceneTopic);
  }

  /**
   * Get the index into the model array of a model based on a name
   */
  private getModelIndex(name: string): number {
    let foundIndex = -1;
    for (let i = 0; i < this.models.length; ++i) {
      // Simulation enforces unique names between models. The ID
      // of a model may change. This occurs when levels are loaded,
      // unloaded, and then reloaded.
      if (this.models[i]['name'] === name) {
          foundIndex = i;
          break;
      }
    }
    return foundIndex;
  }

  /**
   * Setup the visualization scene.
   */
  private setupVisualization(): void {
    var that = this;

    // Create a find asset helper
    function findAsset(_uri: string, _cb: any) {
      that.transport.getAsset(_uri, _cb);
    }

    this.scene = new Scene({
      shaders: new Shaders(),
      findResourceCb: findAsset,
    });
    this.sdfParser = new SDFParser(this.scene);
    this.sdfParser.usingFilesUrls = true;

    if (window.document.getElementById(this.elementId)) {
      this.sceneElement = window.document.getElementById(this.elementId)!;
    } else {
      console.error('Unable to find HTML element with an id of',
                    this.elementId);
    }
    this.sceneElement.appendChild(this.scene.renderer.domElement);

    this.scene.setSize(this.sceneElement.clientWidth, this.sceneElement.clientHeight);
  }

  /**
   * Animation loop.
   *
   * Renders the scene and updates any system and time-related variables.
   */
  private animate(): void {
    this.cancelAnimation = requestAnimationFrame((timestampMs) => {
      if (this.previousRenderTimestampMs === 0) {
        this.previousRenderTimestampMs = timestampMs;
      }

      this.animate();

      if (this.scene.getParticleSystem()) {
        this.scene.getParticleSystem().update();
      }

      this.scene.render(timestampMs - this.previousRenderTimestampMs);
      this.previousRenderTimestampMs = timestampMs;
    });
  }

  /**
   * Start the visualization rendering loop.
   */
  private startVisualization(): void {
    this.animate();
  }
}



---
File: /src/SDFParser.ts
---

import * as THREE from 'three';
import { EventEmitter2 } from 'eventemitter2';
import { X2jOptions, XMLParser, XMLValidator } from 'fast-xml-parser';

import { getDescendants } from './Globals';
import { FuelServer,
         createFuelUri } from './FuelServer';
import { Color } from './Color';
import { Inertia } from './Inertia';
import { Material } from './Material';
import { PBRMaterial } from './PBRMaterial';
import { Pose } from './Pose';
import { Scene } from './Scene';

import System, {
  Body,
  BoxZone,
  Emitter,
  Life,
  Position,
  Radius,
  Rate,
  Scale,
  Span,
  SpriteRenderer,
  VectorVelocity,
  // @ts-ignore
} from 'three-nebula';

import { Message } from 'protobufjs';

class PendingMesh {
  public meshUri: string = '';
  public submesh: string = '';
  public parent: THREE.Object3D;
  public material: Material | undefined;
  public centerSubmesh: boolean = false;
}

export class SDFParser {
  // true for using URLs to load files.
  // false for using the files loaded in the memory.
  public usingFilesUrls: boolean = false;

  // Flag to control the usage of PBR materials (enabled by default).
  public enablePBR: boolean = true;

  private scene: Scene;
  private SDF_VERSION: number = 1.5;
  private MATERIAL_ROOT: string = 'assets';
  private emitter: EventEmitter2 = new EventEmitter2({verboseMemoryLeak: true});
  // cache materials if more than one model needs them
  private materials = {};
  private entityMaterial = {};

  // store meshes when loading meshes from memory.
  private meshes = {};
  // Used to avoid loading meshes multiple times. An array that contains:
  // meshUri, submesh, material and the parent visual Object of the mesh.
  private pendingMeshes: PendingMesh[] = [];

  // This map is used to handle included models and avoid duplicated requests.
  // The key is the model's URI.
  // The value is an object that has a models array, which contains the pending models,
  // and it also contains the sdf, if it was read.
  // The value is an array of objects that contain the models that use the same uri and
  // their parents.
  // Models have a different name and pose that needs to be set once the model files resolve.
  // Map is not available in es5, so we need to suppress the linter warnings.
  private pendingModels = new Map();

  private mtls = {};
  private textures = {};

  // Should contain model files URLs if not using gzweb model files hierarchy.
  private customUrls: string[] = [];

  // Used for communication with Fuel Servers.
  private fuelServer: FuelServer;
  private requestHeaderKey: string
  private requestHeaderValue: string;

  /**
  * SDF parser constructor initializes SDF parser with the given parameters
  * and defines a DOM parser function to parse SDF XML files
  * @param {Scene} scene - the gz3d scene object
  **/
  constructor(scene: Scene) {
    this.scene = scene;
    this.scene.setSDFParser(this);
    this.scene.initScene();

    var that = this;
    this.emitter.on('material', function(mat) {
      that.materials = Object.assign(that.materials, mat);
    });

    this.fuelServer = new FuelServer();
  }

  /**
   * Pushes Urls into the customUrls array where the parser looks for assets.
   * If `usingFilesUrls` is true, resources will only be taken from this array.
   * TODO: Find a less intrusive way to support custom URLs (issue #147)
   */
  public addUrl(url: string): void {
    var trimmedUrl = url && url.trim();
    if (trimmedUrl === undefined || trimmedUrl.indexOf('http') !== 0)
    {
      console.warn('Trying to add invalid URL: ' + url);
      return;
    }

    // Avoid duplicated URLs.
    if (this.customUrls.indexOf(trimmedUrl) === -1) {
      this.customUrls.push(trimmedUrl);
    }
  }

  /**
   * Parses a color, which may come from an object or string.
   * @param {string|object} colorInput - A string which denotes the color where every value
   * should be separated with single white space, or an object containing rgba values
   * @returns {object} color - color object having r, g, b and alpha values
   */
  public parseColor(colorInput: string | object): Color {
    let color: Color = new Color();
    var values = [];
    if (typeof colorInput === 'string') {
      values = colorInput.split(/\s+/);
    } else {
      values = [
        colorInput['r'] || 0,
        colorInput['g'] || 0,
        colorInput['b'] || 0,
        colorInput['a'] || 1
      ];
    }

    color.r = parseFloat(values[0]);
    color.g = parseFloat(values[1]);
    color.b = parseFloat(values[2]);
    color.a = parseFloat(values[3]);

    return color;
  }

  /**
   * Parses string which is a 3D vector
   * @param {string|object} vectorInput - string which denotes the vector where every value
   * should be separated with single white space, or an object containing x, y, z values.
   * @returns {object} vector3D - vector having x, y, z values
   */
  public parse3DVector(vectorInput: string | object): THREE.Vector3 {
    let vector3D: THREE.Vector3 = new THREE.Vector3();
    var values = [];
    if (typeof vectorInput === 'string') {
      values = vectorInput.split(/\s+/);
    } else {
      values = [
        vectorInput['x'] || 0,
        vectorInput['y'] || 0,
        vectorInput['z'] || 0
      ];
    }
    vector3D.x = parseFloat(values[0]);
    vector3D.y = parseFloat(values[1]);
    vector3D.z = parseFloat(values[2]);
    return new THREE.Vector3(vector3D.x, vector3D.y, vector3D.z);
  }

  /**
   * Creates a light from either a protobuf object or SDF object.
   * @param {object} light - A light represented by a Protobuf or SDF object.
   * @returns {THREE.Light} lightObj - THREE light object created
   * according to given properties. The type of light object is determined
   * according to light type
   */
  public spawnLight(light: any): THREE.Object3D {
    if (light.type !== undefined && !(light.type instanceof String)) {
      return this.spawnLightFromProto(light);
    } else {
      return this.spawnLightFromSDF({light: light});
    }
  }

  /**
   * Creates THREE light object according to properties of sdf object
   * which is parsed from sdf model of the light
   * @param {object} sdfObj - object which is parsed from the sdf string
   * @returns {THREE.Object3D} lightObj - THREE.Object3D that holds the
   * THREE.Light created according to given properties. The type of light
   * object is determined according to light type
   */
  public spawnLightFromSDF(sdfObj: any): THREE.Object3D {
    let light = sdfObj.light;
    let name: string = light['@name'] || light['name'];
    let diffuse: Color = this.parseColor(light.diffuse);
    let specular: Color = this.parseColor(light.specular);
    let pose = this.parsePose(light.pose);
    let castShadows: boolean = this.parseBool(light.cast_shadows);
    let distance: number = 0.0;
    let attConst: number = 0.0;
    let attLin: number = 0.0;
    let attQuad: number = 0.0;
    let direction: THREE.Vector3 | undefined;
    let innerAngle: number = 0.0;
    let outerAngle: number = 0.0;
    let falloff: number = 0.0;
    let type: number = 1;

    if (light.attenuation)
    {
      if (light.attenuation.range)
      {
        distance = parseFloat(light.attenuation.range);
      }
      if (light.attenuation.constant)
      {
        attConst = parseFloat(light.attenuation.constant);
      }
      if (light.attenuation.linear)
      {
        attLin = parseFloat(light.attenuation.linear);
      }
      if (light.attenuation.quadratic)
      {
        attQuad = parseFloat(light.attenuation.quadratic);
      }
    }
    if (light.spot)
    {
      if (light.spot.inner_angle)
      {
        innerAngle = parseFloat(light.spot.inner_angle);
      }
      if (light.spot.outer_angle)
      {
        outerAngle = parseFloat(light.spot.outer_angle);
      }
      if (light.spot.falloff)
      {
        falloff = parseFloat(light.spot.falloff);
      }
    }
    // equation taken from
    // eslint-disable-next-line
    // https://docs.blender.org/manual/en/dev/render/blender_render/lighting/lights/light_attenuation.html
    var E = 1;
    var D = 1;
    var r = 1;
    var L = attLin;
    var Q = attQuad;
    var intensity = E*(D/(D+L*r))*(Math.pow(D,2)/(Math.pow(D,2)+Q*Math.pow(r,2)));

    if (light['@type'] === 'point')
    {
      type = 1;
    }
    if (light['@type'] === 'spot')
    {
      type = 2;
    }
    else if (light['@type'] === 'directional')
    {
      type = 3;
      direction = this.parse3DVector(light.direction);
    }
    let lightObj: THREE.Object3D = this.scene.createLight(type, diffuse, intensity, pose,
        distance, castShadows, name, direction, specular,
        attConst, attLin, attQuad, innerAngle, outerAngle, falloff);

    return lightObj;
  }

  /**
   * Creates THREE light object according to properties of protobuf object
   * @param {object} pbObj - object which is parsed from a Protobuf string
   * @returns {THREE.Light} lightObj - THREE.Object3d that holds the
   * THREE.Light object created according to given properties. The type of
   * light object is determined according to light type
   */
  public spawnLightFromProto(light: any): THREE.Object3D {
    // equation taken from
    // eslint-disable-next-line
    // https://docs.blender.org/manual/en/dev/render/blender_render/lighting/lights/light_attenuation.html
    let E = 1;
    let D = 1;
    let r = 1;
    let L = light.attenuation_linear;
    let Q = light.attenuation_quadratic;
    let intensity = E*(D/(D+L*r))*(Math.pow(D,2)/(Math.pow(D,2)+Q*Math.pow(r,2)));

    let lightObj: THREE.Object3D = this.scene.createLight(
      // Protobuf light type starts at zero.
      light.type + 1,
      light.diffuse,
      intensity,
      light.pose,
      light.range,
      light.cast_shadows,
      light.name,
      light.direction,
      light.specular,
      light.attenuation_constant,
      light.attenuation_linear,
      light.attenuation_quadratic,
      light.spot_inner_angle,
      light.spot_outer_angle,
      light.spot_falloff);

    return lightObj;
  }

  /**
   * Parses a string which is a 3D vector
   * @param {string|object} poseInput - string which denotes the pose of the object
   * where every value should be separated with single white space and
   * first three denotes x,y,z and values of the pose,
   * and following three denotes euler rotation around x,y,z, or an object
   * containing pose and orientation.
   * @returns {object} pose - pose object having position (x,y,z)(THREE.Vector3)
   * and orientation (THREE.Quaternion) properties
   */
  public parsePose(poseInput: string | object): Pose {
    const pose: Pose = new Pose();

    // Short circuit if poseInput is undefined
    if (poseInput === undefined) {
      return pose;
    }

    if (poseInput.hasOwnProperty('position') &&
        poseInput.hasOwnProperty('orientation')) {
      pose.position.x = poseInput['position']['x'];
      pose.position.y = poseInput['position']['y'];
      pose.position.z = poseInput['position']['z'];
      pose.orientation.x = poseInput['orientation']['x'];
      pose.orientation.y = poseInput['orientation']['y'];
      pose.orientation.z = poseInput['orientation']['z'];
      pose.orientation.w = poseInput['orientation']['w'];
      return pose;
    }

    let poseStr: string = '';
    if (typeof poseInput === 'object') {
      // Note: The pose might have an empty frame attribute. This is a valid XML
      // element though. In this case, the parser outputs
      // {@frame: "frame", #text: "pose value"}
      if (poseInput.hasOwnProperty('@frame')) {
        console.warn('SDFParser does not support frame semantics.');
      }
      poseStr = poseInput['#text'];
    } else {
      poseStr = poseInput;
    }

    const values = poseStr.trim().split(/\s+/);

    pose.position.x = parseFloat(values[0]);
    pose.position.y = parseFloat(values[1]);
    pose.position.z = parseFloat(values[2]);

    // get euler rotation and convert it to Quaternion
    var euler = new THREE.Euler(parseFloat(values[3]),
                                parseFloat(values[4]),
                                parseFloat(values[5]), 'ZYX');
    pose.orientation.setFromEuler(euler);

    return pose;
  }

  /**
   * Parses a string which is a 3D vector
   * @param {string|object} scaleInput - string which denotes scaling in x,y,z
   * where every value should be separated with single white space, or an object
   * containing x, y, z values.
   * @returns {THREE.Vector3} scale - THREE Vector3 object
   * which denotes scaling of an object in x,y,z
   */
  public parseScale(scaleInput: string | object): THREE.Vector3 {
    var values = [];
    if (typeof scaleInput === 'string') {
      values = scaleInput.split(/\s+/);
    } else {
      values = [
        scaleInput['x'] || 1,
        scaleInput['y'] || 1,
        scaleInput['z'] || 1
      ];
    }
    var scale = new THREE.Vector3(parseFloat(values[0]), parseFloat(values[1]),
            parseFloat(values[2]));
    return scale;
  }

  /**
   * Parses a string which is a boolean
   * @param {string} boolStr - string which denotes a boolean value
   * where the values can be true, false, 1, or 0.
   * @returns {bool} bool - bool value
   */
  public parseBool(boolStr: string): boolean {
    if (boolStr !== undefined) {
      return JSON.parse(boolStr);
    }

    return false;
  }

  /**
   * Parses SDF material element which is going to be used by THREE library
   * It matches material scripts with the material objects which are
   * already parsed by gzbridge and saved by SDFParser.
   * If `usingFilesUrls` is true, the texture URLs will be loaded from the
   * to the customUrls array.
   * @param {object} material - SDF or Protobuf material object
   * @returns {object} material - material object which has the followings:
   * texture, normalMap, ambient, diffuse, specular, opacity
   */
  public createMaterial(srcMaterial: any): Material | undefined {
    var texture, mat;
    let material: Material = new Material();

    if (!srcMaterial) {
      return undefined;
    }

    if (srcMaterial.ambient) {
      material.ambient = this.parseColor(srcMaterial.ambient);
    }

    if (srcMaterial.diffuse) {
      material.diffuse = this.parseColor(srcMaterial.diffuse);
    }

    if (srcMaterial.specular) {
      material.specular = this.parseColor(srcMaterial.specular);
    }

    material.opacity = srcMaterial.opacity;
    material.normalMap = srcMaterial.normalMap;
    material.scale = srcMaterial.scale;

    // normal map
    if (srcMaterial.normal_map)
    {
      let mapUri: string = '';
      if (srcMaterial.normal_map.indexOf('://') > 0)
      {
        mapUri = srcMaterial.normal_map.substring(
                srcMaterial.normal_map.indexOf('://') + 3,
                srcMaterial.normal_map.lastIndexOf('/'));
      }

      if (mapUri != '')
      {
        var startIndex = srcMaterial.normal_map.lastIndexOf('/') + 1;
        if (startIndex < 0) {
          startIndex = 0;
        }

        var normalMapName = srcMaterial.normal_map.substr(startIndex,
          srcMaterial.normal_map.lastIndexOf('.') - startIndex);
        // Map texture name to the corresponding texture.
        if (!this.usingFilesUrls) {
          material.normalMap = this.textures[normalMapName + '.png'];
        } else {
          if (this.customUrls.length !== 0) {
            for (var j = 0; j < this.customUrls.length; j++) {
              if (this.customUrls[j].indexOf(normalMapName + '.png') > -1) {
                material.normalMap = this.customUrls[j];
                break;
              }
            }
          } else {
            material.normalMap = this.MATERIAL_ROOT + '/' + mapUri + '/' +
              normalMapName + '.png';
          }
        }
      }
    }

    // Material properties received via a protobuf message are formatted
    // differently from SDF. This will map protobuf format onto sdf.
    if (srcMaterial.pbr && this.enablePBR) {
      material.pbr = new PBRMaterial();
      if (srcMaterial.pbr.metal) {
        // Must be SDF with metal properties.
        material.pbr.albedoMap = srcMaterial.pbr.metal.albedo_map;
        material.pbr.metalness = srcMaterial.pbr.metal.metalness;
        material.pbr.metalnessMap = srcMaterial.pbr.metal.metalness_map;
        material.pbr.normalMap = srcMaterial.pbr.metal.normal_map;
        material.pbr.roughness = srcMaterial.pbr.metal.roughness;
        material.pbr.roughnessMap = srcMaterial.pbr.metal.roughness_map;
        material.pbr.emissiveMap = srcMaterial.pbr.metal.emissive_map;
        material.pbr.lightMap = srcMaterial.pbr.metal.light_map;
        material.pbr.environmentMap = srcMaterial.pbr.metal.environment_map;
        material.pbr.ambientOcclusionMap = srcMaterial.pbr.metal.ambient_occlusion_map;
      } else if (srcMaterial.pbr.specular) {
        // Must be SDF with specular properties.
        material.pbr.albedoMap = srcMaterial.pbr.specular.albedo_map;
        material.pbr.specularMap = srcMaterial.pbr.specular.specular_map;
        material.pbr.glossinessMap = srcMaterial.pbr.specular.glossiness_map;
        material.pbr.glossiness = srcMaterial.pbr.specular.glossiness;
        material.pbr.environmentMap = srcMaterial.pbr.specular.environment_map;
        material.pbr.ambientOcclusionMap = srcMaterial.pbr.specular.ambient_occlusion_map;
        material.pbr.normalMap = srcMaterial.pbr.specular.normal_map;
        material.pbr.emissiveMap = srcMaterial.pbr.specular.emissive_map;
        material.pbr.lightMap = srcMaterial.pbr.specular.light_map;
      } else {
        // Must be a protobuf message.
        material.pbr.albedoMap = srcMaterial.pbr.albedo_map;
        material.pbr.normalMap = srcMaterial.pbr.normal_map;
        material.pbr.metalness = srcMaterial.pbr.metalness;
        material.pbr.metalnessMap = srcMaterial.pbr.metalness_map;
        material.pbr.roughness = srcMaterial.pbr.roughness;
        material.pbr.roughnessMap = srcMaterial.pbr.roughness_map;
        material.pbr.glossiness = srcMaterial.pbr.glossiness;
        material.pbr.glossinessMap = srcMaterial.pbr.glossiness_map;
        material.pbr.specularMap = srcMaterial.pbr.specular_map;
        material.pbr.environmentMap = srcMaterial.pbr.environment_map;
        material.pbr.emissiveMap = srcMaterial.pbr.emissive_map;
        material.pbr.lightMap = srcMaterial.pbr.light_map;
        material.pbr.ambientOcclusionMap = srcMaterial.pbr.ambient_occlusion_map;
      }
    }

    // Set the correct URLs of the PBR-related textures, if available.
    if (material.pbr && this.enablePBR) {
      // Iterator for the subsequent for loops. Used to avoid a linter warning.
      // Loops (and all variables in general) should use let/const when ported to ES6.
      var u;
      if (material.pbr.albedoMap) {
        let albedoMap: string = '';
        let albedoMapName: string = material.pbr.albedoMap.split('/').pop()!;

        if (material.pbr.albedoMap.startsWith('https://')) {
          this.addUrl(material.pbr.albedoMap);
        }

        if (this.usingFilesUrls && this.customUrls.length !== 0) {
          for (let u = 0; u < this.customUrls.length; u++) {
            if (this.customUrls[u].indexOf(albedoMapName) > -1) {
              albedoMap = this.customUrls[u];
              break;
            }
          }
          if (albedoMap) {
            material.pbr.albedoMap = albedoMap;
          } else {
            console.error('Missing Albedo Map file [' + material.pbr.albedoMap + ']');
            // Prevent the map from loading, as it hasn't been found.
            material.pbr.albedoMap = '';
          }
        }
      }

      if (material.pbr.emissiveMap) {
        let emissiveMap: string = '';
        let emissiveMapName: string =
          material.pbr.emissiveMap.split('/').pop()!;

        if (material.pbr.emissiveMap.startsWith('https://')) {
          this.addUrl(material.pbr.emissiveMap);
        }

        if (this.usingFilesUrls && this.customUrls.length !== 0) {
          for (u = 0; u < this.customUrls.length; u++) {
            if (this.customUrls[u].indexOf(emissiveMapName) > -1) {
              emissiveMap = this.customUrls[u];
              break;
            }
          }
          if (emissiveMap) {
            material.pbr.emissiveMap = emissiveMap;
          } else {
            console.error('Missing Emissive Map file [' + material.pbr.emissiveMap + ']');
            // Prevent the map from loading, as it hasn't been found.
            material.pbr.emissiveMap = '';
          }
        }
      }

      if (material.pbr.normalMap) {
        let pbrNormalMap: string = '';
        let pbrNormalMapName: string = material.pbr.normalMap.split('/').pop()!;

        if (material.pbr.normalMap.startsWith('https://')) {
          this.addUrl(material.pbr.normalMap);
        }

        if (this.usingFilesUrls && this.customUrls.length !== 0) {
          for (u = 0; u < this.customUrls.length; u++) {
            if (this.customUrls[u].indexOf(pbrNormalMapName) > -1) {
              pbrNormalMap = this.customUrls[u];
              break;
            }
          }
          if (pbrNormalMap) {
            material.pbr.normalMap = pbrNormalMap;
          } else {
            console.error('Missing Normal Map file [' + material.pbr.normalMap + ']');
            // Prevent the map from loading, as it hasn't been found.
            material.pbr.normalMap = '';
          }
        }
      }

      if (material.pbr.roughnessMap) {
        let roughnessMap: string = '';
        let roughnessMapName: string = material.pbr.roughnessMap.split('/').pop()!;

        if (material.pbr.roughnessMap.startsWith('https://')) {
          this.addUrl(material.pbr.roughnessMap);
        }

        if (this.usingFilesUrls && this.customUrls.length !== 0) {
          for (u = 0; u < this.customUrls.length; u++) {
            if (this.customUrls[u].indexOf(roughnessMapName) > -1) {
              roughnessMap = this.customUrls[u];
              break;
            }
          }
          if (roughnessMap) {
            material.pbr.roughnessMap = roughnessMap;
          } else {
            console.error('Missing Roughness Map file [' + material.pbr.roughnessMap + ']');
            // Prevent the map from loading, as it hasn't been found.
            material.pbr.roughnessMap = '';
          }
        }
      }

      if (material.pbr.metalnessMap) {
        let metalnessMap: string = '';
        let metalnessMapName: string =
          material.pbr.metalnessMap.split('/').pop()!;

        if (material.pbr.metalnessMap.startsWith('https://')) {
          this.addUrl(material.pbr.metalnessMap);
        }

        if (this.usingFilesUrls && this.customUrls.length !== 0) {
          for (u = 0; u < this.customUrls.length; u++) {
            if (this.customUrls[u].indexOf(metalnessMapName) > -1) {
              metalnessMap = this.customUrls[u];
              break;
            }
          }
          if (metalnessMap) {
            material.pbr.metalnessMap = metalnessMap;
          } else {
            console.error('Missing Metalness Map file [' + material.pbr.metalnessMap + ']');
            // Prevent the map from loading, as it hasn't been found.
            material.pbr.metalnessMap = '';
          }
        }
      }
    }

    return material;
  }

  /**
   * Parses a string which is a size of an object
   * @param {string|object} sizeInput - string which denotes size in x,y,z
   * where every value should be separated with single white space, or an object
   * containing x, y, z values.
   * @returns {object} size - size object which denotes
   * size of an object in x,y,z
   */
  public parseSize(sizeInput: string | THREE.Vector3): THREE.Vector3 {
    if (typeof sizeInput === 'string') {
      let values: string[] = sizeInput.split(/\s+/);
      return new THREE.Vector3(
        parseFloat(values[0]),
        parseFloat(values[1]),
        parseFloat(values[2]));
    }

    return new THREE.Vector3(sizeInput.x, sizeInput.y, sizeInput.z);
  }

  /**
   * Parses SDF geometry element and creates corresponding mesh,
   * when it creates the THREE.Mesh object it directly add it to the parent
   * object.
   * @param {object} geom - SDF geometry object which determines the geometry
   *  of the object and can have following properties: box, cylinder, sphere,
   *  plane, mesh, capsule.
   *  Note that in case of using custom URLs for the meshes, the URLs should be
   *  added to the array customUrls to be used instead of the default URL.
   * @param {object} mat - SDF material object which is going to be parsed
   * by createMaterial function
   * @param {object} parent - parent 3D object
   * @param {object} options - Options to send to the creation process. It can include:
   *                 - enableLights - True to have lights visible when the object is created.
   *                                  False to create the lights, but set them to invisible (off).
   *                 - fuelName - Name of the resource in Fuel. Helps to match URLs to the correct path. Requires 'fuelOwner'.
   *                 - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs to the correct path. Requires 'fuelName'.
   */
  public createGeom(geom: any, mat: any, parent: THREE.Object3D, options: any): void {
    let that = this;
    let obj: THREE.Mesh | undefined = undefined;
    let size;
    let normal: THREE.Vector3 = new THREE.Vector3(0, 0, 1);

    var material = this.createMaterial(mat);

    if (geom.box)
    {
      if (geom.box.size) {
        size = this.parseSize(geom.box.size);
      } else {
        size = {x: 1, y: 1, z: 1};
      }
      obj = this.scene.createBox(size.x, size.y, size.z);
    }
    else if (geom.cylinder)
    {
      var radius = parseFloat(geom.cylinder.radius);
      var length = parseFloat(geom.cylinder.length);
      obj = this.scene.createCylinder(radius, length);
    }
    else if (geom.capsule)
    {
      var radius = parseFloat(geom.capsule.radius);
      var length = parseFloat(geom.capsule.length);
      obj = this.scene.createCapsule(radius, length);
    }
    else if (geom.cone)
    {
      var radius = parseFloat(geom.cone.radius);
      var length = parseFloat(geom.cone.length);
      obj = this.scene.createCone(radius, length);
    }
    else if (geom.ellipsoid)
    {
      var radii = this.parseSize(geom.ellipsoid.radii);
      obj = this.scene.createEllipsoid(radii.x, radii.y, radii.z);
    }
    else if (geom.sphere)
    {
      obj = this.scene.createSphere(parseFloat(geom.sphere.radius));
    }
    else if (geom.plane)
    {
      if (geom.plane.normal) {
        normal = this.parseSize(geom.plane.normal);
      }

      if (geom.plane.size) {
        size = this.parseSize(geom.plane.size);
      } else {
        size = {x: 1, y: 1};
      }
      obj = this.scene.createPlane(normal, size.x, size.y);
    }
    else if (geom.mesh)
    {
      let meshUri: string = geom.mesh.uri || geom.mesh.filename;
      let submesh: string = '';
      let centerSubmesh: boolean = false;
      let modelName: string = '';

      if (geom.mesh.submesh)
      {
        // Submesh information coming from protobuf messages is slightly
        // different than submesh information coming from an SDF file.
        //
        // * protobuf message has 'submesh' and 'center_submesh'
        // * SDF file has 'submesh.name' and 'submesh.center'
        if (geom.mesh.center_submesh !== undefined) {
          submesh = geom.mesh.submesh;
          centerSubmesh = this.parseBool(geom.mesh.center_submesh);
        } else {
          submesh = geom.mesh.submesh.name;
          centerSubmesh = this.parseBool(geom.mesh.submesh.center);
        }
      }

      var uriType = meshUri.substring(0, meshUri.indexOf('://'));
      if (uriType === 'file' || uriType === 'model') {
        modelName = meshUri.substring(meshUri.indexOf('://') + 3);
      } else {
        modelName = meshUri;
      }

      if (geom.mesh.scale) {
        var scale = this.parseScale(geom.mesh.scale);
        parent.scale.x = scale.x;
        parent.scale.y = scale.y;
        parent.scale.z = scale.z;
      }

      // Create a valid Fuel URI from the model name
      let modelUri: string = createFuelUri(modelName);

      let ext: string = modelUri.substr(-4).toLowerCase();
      let materialName: string = parent.name + '::' + modelUri;
      this.entityMaterial[materialName] = material;
      let meshFileName: string = meshUri.substring(meshUri.lastIndexOf('/'));

      if (!this.usingFilesUrls) {
        var meshFile = this.meshes[meshFileName];
        if (!meshFile) {
          console.error('Missing mesh file [' + meshFileName + ']');
          return;
        }

        if (ext === '.obj') {
          var mtlFileName = meshFileName.split('.')[0]+'.mtl';
          var mtlFile = this.mtls[mtlFileName];
          if (!mtlFile) {
            console.error('Missing MTL file [' + mtlFileName + ']');
            return;
          }

          that.scene.loadMeshFromString(modelUri, submesh, centerSubmesh,
            function(obj: any): void {
              if (!obj) {
                console.error('Failed to load mesh.');
                return;
              }

              parent.add(obj);
              loadGeom(parent);
            },

            // onError callback
            function(error: any): void {
              console.error(error);
            },
            [meshFile, mtlFile]);
        }
        else if (ext === '.dae') {
          that.scene.loadMeshFromString(modelUri, submesh, centerSubmesh,
            function(dae: THREE.Object3D): void {
              if (!dae) {
                console.error('Failed to load mesh.');
                return;
              }

              if (material) {
                let allChildren: THREE.Object3D[] = [];
                getDescendants(dae, allChildren);
                for (var c = 0; c < allChildren.length; ++c) {
                  if (allChildren[c] instanceof THREE.Mesh) {
                    that.scene.setMaterial(allChildren[c] as THREE.Mesh,
                                           material);
                    break;
                  }
                }
              }
              parent.add(dae);
              loadGeom(parent);
            },
            // onError callback
            function(error: any): void {
              console.error(error);
            },
            [meshFile]);
        }
      } else {
        if (this.customUrls.length !== 0) {
          for (var k = 0; k < this.customUrls.length; k++) {
            if (this.customUrls[k].indexOf(meshFileName) > -1) {
              // If we have Fuel name and owner information, make sure the
              // path includes them.
              if (options && options.fuelName && options.fuelOwner) {
                if (this.customUrls[k].indexOf(options.fuelName) > -1 &&
                    this.customUrls[k].indexOf(options.fuelOwner) > -1) {
                  modelUri = this.customUrls[k];
                  break;
                }
              } else {
                // No Fuel name and owner provided. Use the filename.
                modelUri = this.customUrls[k];
                break;
              }
            }
          }
        }

        // Avoid loading the mesh multiple times.
        for (var i = 0; i < this.pendingMeshes.length; i++) {
          if (this.pendingMeshes[i].meshUri === modelUri) {
            // The mesh is already pending, but submesh and the visual object
            // parent are different.
            this.pendingMeshes.push({
              meshUri: modelUri,
              submesh: submesh,
              parent: parent,
              material: material,
              centerSubmesh: centerSubmesh
            });

            // If the mesh exists, then create another version and add it to
            // the parent object.
            if (this.scene.meshes.has(modelUri)) {
              let mesh: THREE.Mesh = this.scene.meshes.get(modelUri)!;
              if (parent.getObjectByName(mesh.name) === undefined) {
                mesh = mesh.clone();
                this.scene.useSubMesh(mesh, submesh, centerSubmesh);
                parent.add(mesh);
                loadGeom(parent);
              }
            }
            return;
          }
        }
        this.pendingMeshes.push({
          meshUri: modelUri,
          submesh: submesh,
          parent: parent,
          material: material,
          centerSubmesh: centerSubmesh
        });

        // Load the mesh.
        // Once the mesh is loaded, it will be stored on Gz3D.Scene.
        this.scene.loadMeshFromUri(modelUri, submesh, centerSubmesh,
          // onLoad
          function (mesh: THREE.Mesh)
          {
            // Check for the pending meshes.
            for (var i = 0; i < that.pendingMeshes.length; i++) {
              if (that.pendingMeshes[i].meshUri === mesh.name) {

                // No submesh: Load the result.
                if (!that.pendingMeshes[i].submesh) {
                  loadMesh(mesh, that.pendingMeshes[i].material,
                           that.pendingMeshes[i].parent, ext);
                } else {
                  // Check if the mesh belongs to a submesh.
                  let allChildren: THREE.Object3D[] = [];
                  getDescendants(mesh, allChildren);
                  for (var c = 0; c < allChildren.length; ++c) {
                    if (allChildren[c] instanceof THREE.Mesh) {
                      if (allChildren[c].name === that.pendingMeshes[i].submesh) {
                        loadMesh(mesh, that.pendingMeshes[i].material,
                                 that.pendingMeshes[i].parent, ext);
                      } else {
                        // The mesh is already stored in Scene.
                        // The new submesh will be parsed.
                        that.scene.loadMeshFromUri(mesh.name,
                          that.pendingMeshes[i].submesh,
                          that.pendingMeshes[i].centerSubmesh,
                          // on load
                          function(mesh: THREE.Mesh): void {
                            loadMesh(mesh, that.pendingMeshes[i].material,
                              that.pendingMeshes[i].parent, ext);
                          },
                          // on error
                          function(error: any): void {
                            console.error('Mesh loading error', error);
                          });
                      }
                    }
                  }
                }
              }
            }
          },
          // onError
          function(error: any) {
            console.error('Mesh loading error', modelUri);
          });
      }
    }
    else if (geom.heightmap) {
      this.scene.loadHeightmap(geom.heightmap.heights,
                               geom.heightmap.size.x,
                               geom.heightmap.size.y,
                               geom.heightmap.width,
                               geom.heightmap.height,
                               new THREE.Vector3(geom.heightmap.origin.x,
                                                 geom.heightmap.origin.y,
                                                 geom.heightmap.origin.z),
                              geom.heightmap.texture,
                              geom.heightmap.blend,
                              parent);

    }

    if (obj) {
      if (material) {
        // texture mapping for simple shapes and planes only,
        // not used by mesh and terrain
        this.scene.setMaterial(obj, material);
      }
      obj.updateMatrix();
      parent.add(obj);
      loadGeom(parent);
    }

    // Callback function when the mesh is ready.
    function loadMesh(mesh: THREE.Mesh, material: Material | undefined,
                      parent: THREE.Object3D, ext: string) {
      if (!mesh) {
        console.error('Failed to load mesh.');
        return;
      }

      // Note: This material is the one created by the createMaterial method,
      // which is the material defined by the SDF file or the material script.
      if (material) {
        // Because the stl mesh doesn't have any children we cannot set
        // the materials like other mesh types.
        if (ext !== '.stl') {
          let allChildren: THREE.Object3D[] = [];
          getDescendants(mesh, allChildren);
          for (let c = 0; c < allChildren.length; ++c)
          {
            if (allChildren[c] instanceof THREE.Mesh)
            {
              // Some Collada files load their own textures.
              // If the mesh already has a material with
              // a texture, we skip this step (but only if there is no
              // PBR materials involved).
              let isColladaWithTexture: boolean = ext === '.dae' &&
                !!(<THREE.Mesh>allChildren[c]).material &&
                !!(<THREE.MeshBasicMaterial>(<THREE.Mesh>allChildren[c]).material).map;

              if (!isColladaWithTexture || material.pbr) {
                that.scene.setMaterial(allChildren[c] as THREE.Mesh, material);
                break;
              }
            }
          }
        }
        else
        {
          that.scene.setMaterial(mesh, material);
        }
      }
      else
      {
        // By default, the STL Loader creates meshes with a basic material with a random color.
        // If no material is set via the SDF file, provide a more appropriate one.
        if (ext === '.stl')
        {
          that.scene.setMaterial(mesh, {'ambient': [1,1,1,1]});
        }
      }

      parent.add(mesh.clone());
      loadGeom(parent);
    }

    function loadGeom(visualObj: THREE.Object3D) {
      let allChildren: THREE.Object3D[] = [];
      getDescendants(visualObj, allChildren);
      for (var c = 0; c < allChildren.length; ++c)
      {
        if (allChildren[c] instanceof THREE.Mesh)
        {
          allChildren[c].castShadow = true;
          allChildren[c].receiveShadow = true;

          if (visualObj.castShadow)
          {
            allChildren[c].castShadow = visualObj.castShadow;
          }
          if (visualObj.receiveShadow)
          {
            allChildren[c].receiveShadow = visualObj.receiveShadow;
          }

          if (visualObj.name.indexOf('COLLISION_VISUAL') >= 0)
          {
            allChildren[c].castShadow = false;
            allChildren[c].receiveShadow = false;

            allChildren[c].visible = that.scene.showCollisions;
          }
          break;
        }
      }
    }
  }

  /**
   * Parses SDF visual element and creates THREE 3D object by parsing
   * geometry element using createGeom function
   * @param {object} visual - SDF visual element
   * @param {object} options - Options to send to the creation process.
   * It can include:
   *   - enableLights - True to have lights visible when the object is created.
   *                    False to create the lights, but set them to invisible
   *                    (off).
   *   - fuelName - Name of the resource in Fuel. Helps to match URLs to the
   *                correct path. Requires 'fuelOwner'.
   *   - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs
   *                 to the correct path. Requires 'fuelName'.
   * @returns {THREE.Object3D} visualObj - 3D object which is created
   * according to SDF visual element.
   */
  public createVisual(visual: any, options: any): THREE.Object3D {
    let visualObj: THREE.Object3D = new THREE.Object3D();
    //TODO: handle these node values
    // cast_shadow, receive_shadows
    if (visual.geometry)
    {
      visualObj.name = visual['@name'] || visual['name'];

      if (visual.pose) {
        var visualPose = this.parsePose(visual.pose);
        this.scene.setPose(visualObj, visualPose.position,
                           visualPose.orientation);
      }

      this.createGeom(visual.geometry, visual.material, visualObj, options);
    }

    return visualObj;
  }

  /**
   * Parses SDF sensor element and creates THREE 3D object
   * @param {object} sensor - SDF sensor element
   * @param {object} options - Options to send to the creation process.
   * It can include:
   *  - fuelName - Name of the resource in Fuel. Helps to match URLs to the
   *               correct path. Requires 'fuelOwner'.
   *  - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs
   *                to the correct path. Requires 'fuelName'.
   * @returns {THREE.Object3D} sensorObj - 3D object which is created
   * according to SDF sensor element.
   */
  public createSensor(sensor: any, options: any): THREE.Object3D {
    let sensorObj: THREE.Object3D = new THREE.Object3D();
    sensorObj.name = sensor['name'] || sensor['@name'] || '';

    if (sensor.pose) {
      let sensorPose: Pose = this.parsePose(sensor.pose);
      this.scene.setPose(sensorObj, sensorPose.position, sensorPose.orientation);
    }

    return sensorObj;
  }

  /**
   * Parses an object and spawns the given 3D object.
   * @param {object} obj - The object, obtained after parsing the SDF or from
   * a world message.
   * @param {object} options - Options to send to the creation process.
   * It can include:
   *  - enableLights - True to have lights visible when the object is created.
   *                   False to create the lights, but set them to invisible
   *                   (off).
   *  - fuelName - Name of the resource in Fuel. Helps to match URLs to the
   *               correct path. Requires 'fuelOwner'.
   *  - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs
   *                to the correct path. Requires 'fuelName'.
   * @returns {THREE.Object3D} object - 3D object which is created from the
   * given object.
   */
  public spawnFromObj(obj: any, options: any): THREE.Object3D {
    if (obj.model) {
      return this.spawnModelFromSDF(obj, options);
    }
    else if (obj.light) {
      return this.spawnLight(obj);
    }
    else if (obj.world) {
      return this.spawnWorldFromSDF(obj, options);
    }
    console.error('Unable to spawn from obj', obj);
    return new THREE.Object3D();
  }

  /**
   * Parses SDF XML string or SDF XML DOM object and return the created Object3D
   * @param {object} sdf - It is either SDF XML string or SDF XML DOM object
   * @returns {THREE.Object3D} object - 3D object which is created from the
   * given SDF.
   */
  public spawnFromSDF(sdf: any): THREE.Object3D {
    let sdfObj: any = this.parseSDF(sdf);
    return this.spawnFromObj(sdfObj, {
      enableLights: true
    });
  }

  /**
   * Parses SDF XML string or SDF XML DOM object
   * @param {object} sdf - It is either SDF XML string or SDF XML DOM object
   * @returns {object} object - The parsed SDF object.
   */
  public parseSDF(sdf: any): any {
    // SDF as a string.
    let sdfString;
    if ((typeof sdf) === 'string') {
      sdfString = sdf;
    } else {
      const serializer = new XMLSerializer();
      sdfString = serializer.serializeToString(sdf);
    }

    const options: Partial<X2jOptions> = {
      ignoreAttributes: false,
      attributeNamePrefix: '@',
      htmlEntities: true,
    }

    let sdfObj;
    const parser = new XMLParser(options);
    const validation = XMLValidator.validate(sdfString, options);

    // Validator returns true or an error object.
    if (validation === true) {
      sdfObj = parser.parse(sdfString).sdf;
    } else {
      console.error('Failed to parse SDF: ', validation.err);
      return;
    }

    return sdfObj;
  }

  /**
   * Loads SDF file according to given name.
   * @param {string} sdfName - Either name of model / world or the filename
   * @param {function} callback - The callback to use once the SDF file is ready.
   */
  public loadSDF(sdfName: string, callback: any): void {
    if (!sdfName) {
      let m: string = 'Must provide either a model/world name or the URL of an SDF file';
      console.error(m);
      return;
    }
    let lowerCaseName: string = sdfName.toLowerCase();
    let filename: string = '';

    // In case it is a full URL
    if (lowerCaseName.indexOf('http') === 0) {
      filename = sdfName;
    }
    // In case it is just the model/world name, look for it on the default URL
    else {
      if (lowerCaseName.endsWith('.world') || lowerCaseName.endsWith('.sdf')) {
        filename = this.MATERIAL_ROOT + '/worlds/' + sdfName;
      } else {
        filename = this.MATERIAL_ROOT + '/' + sdfName + '/model.sdf';
      }
    }

    if (!filename) {
      console.error('Error: unable to load ' + sdfName + ' - file not found');
      return;
    }

    let that = this;
    this.fileFromUrl(filename, function(sdf: any) {
      if (!sdf) {
        console.error('Error: Failed to get the SDF file (' + filename +
                      '). The XML is likely invalid.');
        return;
      }
      callback(that.spawnFromSDF(sdf));
    });
  }

  /**
   * Creates 3D object from parsed model SDF
   * @param {object} sdfObj - parsed SDF object
   * @param {object} options - Options to send to the creation process.
   * It can include:
   *  - enableLights - True to have lights visible when the object is created.
   *                   False to create the lights, but set them to invisible (off).
   *  - fuelName - Name of the resource in Fuel. Helps to match URLs to the correct path. Requires 'fuelOwner'.
   *  - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs to the correct path. Requires 'fuelName'.
   * @returns {THREE.Object3D} modelObject - 3D object which is created
   * according to SDF model object.
   */
  public spawnModelFromSDF(sdfObj: any, options: any): THREE.Object3D {
    // create the model
    let modelObj: THREE.Object3D = new THREE.Object3D();
    modelObj.name = sdfObj.model['name'] || sdfObj.model['@name'];

    let pose: Pose;
    let i, j, k: number;
    let visualObj: THREE.Object3D;
    let linkObj: THREE.Object3D;
    let linkPose: Pose;

    if (sdfObj.model.pose)
    {
      pose = this.parsePose(sdfObj.model.pose);
      this.scene.setPose(modelObj, pose.position, pose.orientation);
    }

    //convert link object to link array
    if (sdfObj.model.link) {
        if (!(sdfObj.model.link instanceof Array))
        {
          sdfObj.model.link = [sdfObj.model.link];
        }

        for (i = 0; i < sdfObj.model.link.length; ++i)
        {
          linkObj = this.createLink(sdfObj.model.link[i], options);
          if (linkObj)
          {
            modelObj.add(linkObj);
          }
        }
    }

    //convert nested model objects to model array
    if (sdfObj.model.model)
    {
      if (!(sdfObj.model.model instanceof Array))
      {
        sdfObj.model.model = [sdfObj.model.model];
      }
      for (i = 0; i < sdfObj.model.model.length; ++i)
      {
        var tmpModelObj = {model:sdfObj.model.model[i]};
        var nestedModelObj = this.spawnModelFromSDF(tmpModelObj, options);
        if (nestedModelObj)
        {
          modelObj.add(nestedModelObj);
        }
      }
    }

    // Parse included models.
    if (sdfObj.model.include) {
      // Convert to array.
      if (!(sdfObj.model.include instanceof Array)) {
        sdfObj.model.include = [sdfObj.model.include];
      }

      // Ignore linter warnings. We use arrow functions to avoid binding 'this'.
      sdfObj.model.include.forEach((includedModel: any) => {
        this.includeModel(includedModel, modelObj);
      });
    }

    return modelObj;
  }

  /**
   * Creates 3D object from parsed world SDF
   * @param {object} sdfObj - parsed SDF object
   * @param {object} options - Options to send to the creation process.
   * It can include:
   *   - enableLights - True to have lights visible when the object is created.
   *                    False to create the lights, but set them to invisible (off).
   *   - fuelName - Name of the resource in Fuel. Helps to match URLs to the correct path. Requires 'fuelOwner'.
   *   - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs to the correct path. Requires 'fuelName'.
   * @returns {THREE.Object3D} worldObject - 3D object which is created
   * according to SDF world object.
   */
  public spawnWorldFromSDF(sdfObj: any, options: any): THREE.Object3D
  {
    var worldObj = new THREE.Object3D();
    worldObj.name = this.createUniqueName(sdfObj.world);

    // remove default sun before adding objects
    // we will let the world file create its own light
    var sun = this.scene.getByName('sun');
    if (sun)
    {
      this.scene.remove(sun);
    }

    // parse models
    if (sdfObj.world.model)
    {
      // convert object to array
      if (!(sdfObj.world.model instanceof Array))
      {
        sdfObj.world.model = [sdfObj.world.model];
      }

      for (var j = 0; j < sdfObj.world.model.length; ++j)
      {
        var tmpModelObj = {model: sdfObj.world.model[j]};
        var modelObj = this.spawnModelFromSDF(tmpModelObj, options);
        worldObj.add(modelObj);
      }
    }

    // parse lights
    if (sdfObj.world.light)
    {
      // convert object to array
      if (!(sdfObj.world.light instanceof Array))
      {
        sdfObj.world.light = [sdfObj.world.light];
      }

      for (var k = 0; k < sdfObj.world.light.length; ++k)
      {
        var lightObj = this.spawnLight(sdfObj.world.light[k]);
        if (lightObj !== null && lightObj !== undefined) {
          if (options && options.enableLights) {
            lightObj.visible = options.enableLights;
          }
          worldObj.add(lightObj);
        }
      }
    }

    // Parse included models.
    if (sdfObj.world.include) {
      // Convert to array.
      if (!(sdfObj.world.include instanceof Array)) {
        sdfObj.world.include = [sdfObj.world.include];
      }

      // Ignore linter warnings. We use arrow functions to avoid binding 'this'.
      sdfObj.world.include.forEach((includedModel: any) => {
        this.includeModel(includedModel, worldObj);
      });
    }

    return worldObj;
  }

  /**
   * Auxiliary function to get and parse an included model.
   * To render an included model, we need to request its files to the Server.
   * A cache map is used to avoid making duplicated requests and reuse the obtained SDF.
   * @param {object} includedModel - The included model.
   * @param {THREE.Object3D} parent - The parent that is including the given model.
   */
  public includeModel(includedModel: any, parent: THREE.Object3D): void {
    // Suppress linter warnings. This shouldn't be necessary after
    // switching to es6 or more.

    // The included model is copied. This allows the SDF to be reused
    // without modifications. The parent is stored in the model, so we
    // don't lose their context once the model's Object3D is created.
    const model = {...includedModel, parent: parent};

    // We need to request the files of the model to the Server.
    // In order to avoid duplicated requests, we store the model in an
    // array until their files are available.
    if (!this.pendingModels.has(model.uri)) {
      // The URI is not in the cache map. We have to make the request to
      // the Server. Add the model to the models array of the map, to use
      // them once the request resolves.
      this.pendingModels.set(model.uri, { models: [model] });

      // Request the files from the server, and create the pending
      // models on it's callback.
      if (this.requestHeaderKey && this.requestHeaderValue) {
        this.fuelServer.setRequestHeader(this.requestHeaderKey,
                                         this.requestHeaderValue);
      }
      this.fuelServer.getFiles(model.uri, (files: string[]) => {
        // The files were obtained.
        let sdfUrl: string = '';
        files.forEach((file) => {
          if (file.endsWith('model.sdf')) {
            sdfUrl = file;
            return;
          }
          this.addUrl(file);
        });

        // Read and parse the SDF.
        this.fileFromUrl(sdfUrl, (sdf: any) => {
          if (!sdf) {
            console.error('Error: Failed to get the SDF file (' + sdfUrl +
                          '). The XML is likely invalid.');
            return;
          }
          const sdfObj = this.parseSDF(sdf);

          const entry = this.pendingModels.get(model.uri);
          entry.sdf = sdfObj;

          // Extract Fuel owner and name. Used to match the correct URL.
          let options: any;
          if (model.uri.startsWith('https://') ||
              model.uri.startsWith('file://')) {
            const uriSplit = model.uri.split('/');
            const modelsIndex = uriSplit.indexOf('models');
            options = {
              fuelOwner: uriSplit[modelsIndex - 1],
              fuelName: uriSplit[modelsIndex + 1],
            }
          }

          entry.models.forEach((pendingModel: any) => {
            // Create the Object3D.
            const modelObj = this.spawnFromObj(sdfObj, options);

            // Set name.
            if (pendingModel.name) {
              modelObj.name = pendingModel.name;
            }

            // Set pose.
            if (pendingModel.pose) {
              const pose = this.parsePose(pendingModel.pose);
              this.scene.setPose(modelObj, pose.position, pose.orientation);
            }

            // Add to parent.
            pendingModel.parent.add(modelObj);
          });

          // Cleanup: Remove the list of models.
          entry.models = [];
        });
      });
    } else {
      // The URI was received already. Push the model into the pending models array.
      const entry = this.pendingModels.get(model.uri);
      entry.models.push(model);

      // If the SDF was already obtained, apply it to this model.
      if (entry.sdf) {
        // Extract Fuel owner and name. Used to match the correct URL.
        let options: any;
        if (model.uri.startsWith('https://') || model.uri.startsWith('file://')) {
          const uriSplit = model.uri.split('/');
          const modelsIndex = uriSplit.indexOf('models');
          options = {
            fuelOwner: uriSplit[modelsIndex - 1],
            fuelName: uriSplit[modelsIndex + 1],
          }
        }

        entry.models.forEach((pendingModel: any) => {
          const sdfObj = entry.sdf;
          const modelObj = this.spawnFromObj(sdfObj, options);

          // Set name.
          if (pendingModel.name) {
            modelObj.name = pendingModel.name;
          }

          // Set pose.
          if (pendingModel.pose) {
            const pose = this.parsePose(pendingModel.pose);
            this.scene.setPose(modelObj, pose.position, pose.orientation);
          }

          // Add to parent.
          pendingModel.parent.add(modelObj);
        });

        // Cleanup: Remove the list of models.
        entry.models = [];
      }
    }
  }

  /**
   * Creates a link 3D object of the model. A model consists of links
   * these links are 3D objects. The function creates only visual elements
   * of the link by createLink function
   * @param {object} link - parsed SDF link object
   * @param {object} options - Options to send to the creation process. It can include:
   *                 - enableLights - True to have lights visible when the object is created.
   *                                  False to create the lights, but set them to invisible (off).
   *                 - fuelName - Name of the resource in Fuel. Helps to match URLs to the correct path. Requires 'fuelOwner'.
   *                 - fuelOwner - Name of the resource's owner in Fuel. Helps to match URLs to the correct path. Requires 'fuelName'.
   * @returns {THREE.Object3D} linkObject - 3D link object
   */
  public createLink(link: any, options: any): THREE.Object3D {
    let linkPose: Pose;
    let visualObj: THREE.Object3D;
    let sensorObj: THREE.Object3D;
    let linkObj: THREE.Object3D = new THREE.Object3D();

    linkObj.name = link['name'] || link['@name'] || '';

    if (link.inertial) {
      let inertialPose: Pose;
      let inertialMass: number
      let inertia: Inertia = new Inertia();
      linkObj.userData.inertial = {};
      inertialPose = link.inertial.pose;
      inertialMass = link.inertial.mass;
      inertia.ixx = link.inertial.ixx;
      inertia.ixy = link.inertial.ixy;
      inertia.ixz = link.inertial.ixz;
      inertia.iyy = link.inertial.iyy;
      inertia.iyz = link.inertial.iyz;
      inertia.izz = link.inertial.izz;
      linkObj.userData.inertial.inertia = inertia;
      if (inertialMass) {
        linkObj.userData.inertial.mass = inertialMass;
      }
      if (inertialPose) {
        linkObj.userData.inertial.pose = inertialPose;
      }
    }

    if (link.pose) {
      linkPose = this.parsePose(link.pose);
      this.scene.setPose(linkObj, linkPose.position, linkPose.orientation);
    }

    if (link.visual) {
      if (!(link.visual instanceof Array)) {
        link.visual = [link.visual];
      }

      for (var i = 0; i < link.visual.length; ++i) {
        visualObj = this.createVisual(link.visual[i], options);
        if (visualObj && !visualObj.parent) {
          linkObj.add(visualObj);
        }
      }
    }

    if (link.collision) {
      if (!(link.collision instanceof Array)) {
        link.collision = [link.collision];
      }

      for (var j = 0; j < link.collision.length; ++j) {
        visualObj = this.createVisual(link.collision[j], options);
        if (visualObj && !visualObj.parent)
        {
          visualObj.castShadow = false;
          visualObj.receiveShadow = false;
          visualObj.visible = this.scene.showCollisions;
          linkObj.add(visualObj);
        }
      }
    }

    if (link.light) {
      if (!(link.light instanceof Array)) {
        link.light = [link.light];
      }

      for (var k = 0; k < link.light.length; ++k) {
        var light = this.spawnLight(link.light[k]);
        if (light !== null && light !== undefined) {
          if (options && options.enableLights !== undefined) {
            light.visible = options.enableLights;
          }
          light.userData = {type: 'light'};
          linkObj.add(light);
        }
      }
    }

    if (link.particle_emitter) {
      if (!(link.particle_emitter instanceof Array)) {
        link.particle_emitter = [link.particle_emitter];
      }
      for (var em = 0; em < link.particle_emitter.length; ++em) {
        const emitter = this.createParticleEmitter(link.particle_emitter[em], linkObj);
        if (emitter !== null && emitter !== undefined) {
          linkObj.userData = {
            emitter: emitter
          };
          linkObj.add(emitter);
        }
      }
    }

    if (link.sensor) {
      if (!(link.sensor instanceof Array)) {
        link.sensor = [link.sensor];
      }

      for (var sidx = 0; sidx < link.sensor.length; ++sidx) {
        sensorObj = this.createSensor(link.sensor[sidx], options);
        if (sensorObj && !sensorObj.parent) {
          linkObj.add(sensorObj);
        }
      }
    }

    return linkObj;
  }

  /**
   * Creates the Particle Emitter.
   *
   * @param {object} Emitter. The emitter element from SDF or protobuf object.
   * @param {THREE.Object3D} Parent. The link that contains the emitter.
   * @return {THREE.Object3D} A THREE.Object3D that contains the particle emitter.
   */
  public createParticleEmitter(emitter: {[key: string]: any | Message;}, parent: THREE.Object3D): THREE.Object3D {
    // Particle Emitter is handled with Three Nebula, a third-party library.
    // More information at https://github.com/creativelifeform/three-nebula

    // Auxliar function to extract the value of an emitter property from
    // either SDF or protobuf object (stored in a data property).
    function extractValue(property: string): any | undefined {
      if (emitter && emitter[property] !== undefined) {
        if (emitter[property].data !== undefined) {
          // The Message Prototype has data, but if not specified, it uses a default
          // value (like 0 or false). We want only explicitly set data, which we get by converting
          // the message to JSON.
          const value = emitter[property] as Message;
          const valueJson = value.toJSON();
          return valueJson.data;
        } else {
          return emitter[property];
        }
      }
      return undefined;
    }

    const particleEmitterObj = new THREE.Object3D();

    // Given name of the emitter.
    const emitterName: string = this.createUniqueName(emitter);

    // Whether the emitter is generating particles or not.
    const emitting: boolean = this.parseBool(extractValue('emitting')) || false;

    // Duration of the particle emitter. Infinite if null.
    const extractedDuration = extractValue('duration');
    const duration = extractedDuration !== undefined ? parseFloat(extractedDuration) : null;

    // Emitter type.
    const type = extractValue('type') || extractValue('@type') || 'point';

    // Lifetime of the individual particles, in seconds.
    const extractedLifetime = extractValue('lifetime');
    const lifetime = extractedLifetime !== undefined ? parseFloat(extractedLifetime) : 5;

    // Velocity range.
    const extractedMinVelocity = extractValue('min_velocity');
    const minVelocity = extractedMinVelocity !== undefined ? parseFloat(extractedMinVelocity) : 1;

    const extractedMaxVelocity = extractValue('max_velocity');
    const maxVelocity = extractedMaxVelocity !== undefined ? parseFloat(extractedMaxVelocity) : 1;

    // Size of the particle emitter.
    // The SDF particle emitter spec lists size as
    // [x: width, y: height, z: depth].
    const extractedSize = extractValue('size');
    const size = this.parse3DVector(extractedSize) || new THREE.Vector3(1, 1, 1);

    // Size of the individual particles.
    const extractedParticleSize = extractValue('particle_size');
    const particleSize = this.parse3DVector(extractedParticleSize) || new THREE.Vector3(1, 1, 1);

    // Pose of the particle emitter
    const extractedPose = extractValue('pose');
    const pose = this.parsePose(extractedPose);

    // Particles per second emitted.
    const extractedRate = extractValue('rate');
    const rate = extractedRate !== undefined ? parseFloat(extractedRate) : 10;

    // Scale modifier for each particle. Modifies their size per second.
    const extractedScaleRate = extractValue('scale_rate');
    const scaleRate = extractedScaleRate !== undefined ? parseFloat(extractedScaleRate) : 1;

    // Material
    const particleMaterial = extractValue('material');
    const particleTextureUrl = particleMaterial.pbr.albedo_map;
    const particleTexture = this.scene.loadTexture(particleTextureUrl);

    // Create a Nebula Emitter.
    const nebulaEmitter = new Emitter();

    // Create the Nebula System, if needed.
    // We need only one system regardless of the amount of emitter we have.
    let nebulaSystem = this.scene.getParticleSystem();
    let nebulaRenderer = this.scene.getParticleRenderer();

    if (!nebulaSystem) {
      nebulaSystem = new System();
      // Note: We pass the global THREE object here, but we could pass an object with just the
      // THREE methods it uses.
      // See https://github.com/creativelifeform/three-nebula/tree/master/src/renderer
      nebulaRenderer = new SpriteRenderer(this.scene.scene, THREE);
      nebulaSystem.addRenderer(nebulaRenderer)

      this.scene.setupParticleSystem(nebulaSystem, nebulaRenderer);
    }

    // Initializers

    // Create the particle sprite and body.
    const createSprite = () => {
      const map = particleTexture;
      const material = new THREE.SpriteMaterial({
        map,
        transparent: true,
      });
      return new THREE.Sprite(material);
    };
    const bodyInitializer = new Body(createSprite());

    // Emitter's size
    // Note: Only Box type supported for now.
    const positionInitializer = new Position();

    const boxZone = new BoxZone(size.x, size.y, size.z);
    positionInitializer.addZone(boxZone);

    const particleLifetimeInitializer = new Life(lifetime);

    // Since rate is particles per second, we emit 1 particle per (1 / rate) seconds.
    const particleRate = new Rate(
      1,
      1 / rate
    );

    const particleSizeInitializer = new Radius(particleSize.x, particleSize.y);
    const particleVelocityInitializer = new VectorVelocity(new THREE.Vector3(1, 0, 0), 0);
    particleVelocityInitializer.radiusPan = new Span(minVelocity, maxVelocity);

    const scaleBehaviour = new Scale(
      // Starting scale factor.
      1,
      // Ending scale factor. Since Scale Rate is scale change per second,
      //we roughly calculate the scale factor at the end of the particle's life.
      Math.pow(scaleRate, lifetime),
    );

    // Explicity avoid damping, otherwise particles will be slowed down.
    nebulaEmitter.damping = 0;

    nebulaEmitter
      .setRate(particleRate)
      .addInitializers([
        positionInitializer,
        particleLifetimeInitializer,
        bodyInitializer,
        particleVelocityInitializer,
        particleSizeInitializer,
      ])
      .setPosition(parent.position)
      .setRotation(parent.rotation);

    if (scaleRate !== 1) {
      nebulaEmitter.addBehaviour(scaleBehaviour);
    }

    if (emitting) {
      nebulaEmitter.emit();
    }

    nebulaSystem
      .addEmitter(nebulaEmitter)
      .emit({ onStart: () => {}, onUpdate: () => {}, onEnd: () => {}});

    return particleEmitterObj;
  }

  /**
   * Creates 3D object according to model name and type of the model and add
   * the created object to the scene.
   * @param {THREE.Object3D} model - model object which will be added to scene
   * @param {string} type - type of the model which can be followings: box,
   * sphere, cylinder, spotlight, directionallight, pointlight
   */
  public addModelByType(model: THREE.Object3D, type: string): void {
    let sdf: any;
    let translation: THREE.Vector3 = new THREE.Vector3();
    let quaternion = new THREE.Quaternion();
    let modelObj: THREE.Object3D;
    let that = this;

    if (model.matrixWorld) {
      let matrix: THREE.Matrix4 = model.matrixWorld;
      let scale: THREE.Vector3 = new THREE.Vector3();
      matrix.decompose(translation, quaternion, scale);
    }

    let euler: THREE.Euler = new THREE.Euler();
    euler.setFromQuaternion(quaternion);

    if (type === 'box') {
      sdf = this.createBoxSDF(translation, euler);
      modelObj = this.spawnFromSDF(sdf);
    } else if (type === 'sphere') {
      sdf = this.createSphereSDF(translation, euler);
      modelObj = this.spawnFromSDF(sdf);
    } else if (type === 'cylinder') {
      sdf = this.createCylinderSDF(translation, euler);
      modelObj = this.spawnFromSDF(sdf);
    } else if (type == 'capsule'){
      sdf = this.createCapsuleSDF(translation, euler);
      modelObj = this.spawnFromSDF(sdf);

    } 
    else if (type === 'spotlight') {
      modelObj = this.scene.createLight(2);
      this.scene.setPose(modelObj, translation, quaternion);
    } else if (type === 'directionallight') {
      modelObj = this.scene.createLight(3);
      this.scene.setPose(modelObj, translation, quaternion);
    } else if (type === 'pointlight') {
      modelObj = this.scene.createLight(1);
      this.scene.setPose(modelObj, translation, quaternion);
    } else {
      this.loadSDF(type, function(sdfObj: any) {
        modelObj = new THREE.Object3D();
        modelObj.add(sdfObj);
        modelObj.name = model.name;
        that.scene.setPose(modelObj, translation, quaternion);
      });
    }

    let addModelFunc = function()
    {
      // check whether object is removed
      var obj = that.scene.getByName(modelObj.name);
      if (obj === undefined)
      {
        that.scene.add(modelObj);
      }
      else
      {
        setTimeout(addModelFunc, 100);
      }
    };

    setTimeout(addModelFunc , 100);
  }

  /**
   * Creates SDF string for simple shapes: box, cylinder, sphere, capsule.
   * @param {string} type - type of the model which can be followings: box,
   * sphere, cylinder, capsule
   * @param {THREE.Vector3} translation - denotes the x,y,z position
   * of the object
   * @param {THREE.Euler} euler - denotes the euler rotation of the object
   * @param {string} geomSDF - geometry element string of 3D object which is
   * already created according to type of the object
   * @returns {string} sdf - SDF string of the simple shape
   */
  public createSimpleShapeSDF(type: string, translation: THREE.Vector3,
          euler: THREE.Euler, geomSDF: string): string {
    var sdf;

    sdf = '<sdf version="' + this.SDF_VERSION + '">' + '<model name="' + type
            + '">' + '<pose>' + translation.x + ' ' + translation.y + ' '
            + translation.z + ' ' + euler.x + ' ' + euler.y + ' ' + euler.z
            + '</pose>' + '<link name="link">'
            + '<inertial><mass>1.0</mass></inertial>'
            + '<collision name="collision">' + '<geometry>' + geomSDF
            + '</geometry>' + '</collision>' + '<visual name="visual">'
            + '<geometry>' + geomSDF + '</geometry>' + '<material>' + '<script>'
            + '<uri>file://media/materials/scripts/gazebo.material' + '</uri>'
            + '<name>Gazebo/Grey</name>' + '</script>' + '</material>'
            + '</visual>' + '</link>' + '</model>' + '</sdf>';

    return sdf;
  }

  /**
   * Creates SDF string of box geometry element
   * @param {THREE.Vector3} translation - the x,y,z position of
   * the box object
   * @param {THREE.Euler} euler - the euler rotation of the box object
   * @returns {string} geomSDF - geometry SDF string of the box
   */
  public createBoxSDF(translation: THREE.Vector3, euler: THREE.Euler): string {
    var geomSDF = '<box>' + '<size>1.0 1.0 1.0</size>' + '</box>';

    return this.createSimpleShapeSDF('box', translation, euler, geomSDF);
  }

  /**
   * Creates SDF string of sphere geometry element
   * @param {THREE.Vector3} translation - the x,y,z position of
   * the box object
   * @param {THREE.Euler} euler - the euler rotation of the box object
   * @returns {string} geomSDF - geometry SDF string of the sphere
   */
  public createSphereSDF(translation: THREE.Vector3, euler: THREE.Euler): string {
    var geomSDF = '<sphere>' + '<radius>0.5</radius>' + '</sphere>';

    return this.createSimpleShapeSDF('sphere', translation, euler, geomSDF);
  }

  /**
   * Creates SDF string of cylinder geometry element
   * @param {THREE.Vector3} translation - the x,y,z position of
   * the box object
   * @param {THREE.Euler} euler - the euler rotation of the cylinder object
   * @returns {string} geomSDF - geometry SDF string of the cylinder
   */
  public createCylinderSDF(translation: THREE.Vector3, euler: THREE.Euler): string {
    var geomSDF = '<cylinder>' + '<radius>0.5</radius>' + '<length>1.0</length>'
            + '</cylinder>';

    return this.createSimpleShapeSDF('cylinder', translation, euler, geomSDF);
  }

  /**
   * Creates SDF string of capsule geometry element
   * @param {THREE.Vector3} translation - the x,y,z position of
   * the box object
   * @param {THREE.Euler} euler - the euler rotation of the capsule object
   * @returns {string} geomSDF - geometry SDF string of the capsule
   */
  public createCapsuleSDF(translation: THREE.Vector3, euler: THREE.Euler): string {
    var geomSDF = '<capsule>' + '<radius>0.5</radius>' + '<length>1.0</length>'
            + '</capsule>';
    return this.createSimpleShapeSDF('capsule', translation, euler, geomSDF);
  }


  /**
   * Set a request header for internal requests.
   * Parser uses XMLHttpRequest, which handle headers with key-value pairs instead of an object (like THREE uses).
   *
   * @param {string} header - The header to send in the request.
   * @param {string} value - The value to set to the header.
   */
  public setRequestHeader(header: string, value: string): void {
    this.requestHeaderKey = header;
    this.requestHeaderValue = value;
  }


  /**
   * Download a file from url.
   * @param {string} url - full URL to an SDF file.
   * @param {function} callback - The callback to use once the file is ready.
   */
  public fileFromUrl(url: string, callback: any): void {
    // The request is asynchronous. To avoid disrupting the current workflow too much, we use a callback.
    // TODO(germanmas): We should update and use async/await instead throughout the library.
    var xhttp = new XMLHttpRequest();
    xhttp.overrideMimeType('text/xml');
    xhttp.open('GET', url, true);

    if (this.requestHeaderKey && this.requestHeaderValue) {
      xhttp.setRequestHeader(this.requestHeaderKey, this.requestHeaderValue);
    }

    xhttp.onload = function() {
      if (xhttp.readyState === 4) {
        if (xhttp.status !== 200) {
          console.error('Failed to get URL [' + url + ']');
          return;
        }
        callback(xhttp.responseXML);
      }
    };

    xhttp.onerror = function (e) {
      console.error(xhttp.statusText);
    };

    try {
      xhttp.send();
    } catch(err: any) {
      console.error('Failed to get URL [' + url + ']: ' + err.message);
      return;
    }
  }

  private createUniqueName(obj: any): string {
    let objectName: string = obj['name'] || obj['@name'] || '';
    let objectId: string = obj['id'] || obj['@id'] || '';
    return objectName + objectId;
  }
}



---
File: /src/Shaders.js
---

export class Shaders {
  /**
   * @constructor
   * Holds custom shaders in string format which can be passed to
   * THREE.ShaderMaterial's options.
   */
  constructor()
  {
    // Custom vertex shader for heightmaps
    this.heightmapVS =
      'varying vec2 vUv;'+
      'varying vec3 vPosition;'+
      'varying vec3 vNormal;'+
      'void main( void ) {'+
      '  vUv = uv;'+
      '  vPosition = position;'+
      '  vNormal = -normal;'+
      '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);'+
      '}';
  
    // Custom fragment shader for heightmaps
    this.heightmapFS =
      'uniform sampler2D texture0;'+
      'uniform sampler2D texture1;'+
      'uniform sampler2D texture2;'+
      'uniform float repeat0;'+
      'uniform float repeat1;'+
      'uniform float repeat2;'+
      'uniform float minHeight1;'+
      'uniform float minHeight2;'+
      'uniform float fadeDist1;'+
      'uniform float fadeDist2;'+
      'uniform vec3 ambient;'+
      'uniform vec3 lightDiffuse;'+
      'uniform vec3 lightDir;'+
      'varying vec2 vUv;'+
      'varying vec3 vPosition;'+
      'varying vec3 vNormal;'+
      'float blend(float distance, float fadeDist) {'+
      '  float alpha = distance / fadeDist;'+
      '  if (alpha < 0.0) {'+
      '    alpha = 0.0;'+
      '  }'+
      '  if (alpha > 1.0) {'+
      '    alpha = 1.0;'+
      '  }'+
      '  return alpha;'+
      '}'+
      'void main()'+
      '{'+
      '  vec3 diffuse0 = texture2D( texture0, vUv*repeat0 ).rgb;'+
      '  vec3 diffuse1 = texture2D( texture1, vUv*repeat1 ).rgb;'+
      '  vec3 diffuse2 = texture2D( texture2, vUv*repeat2 ).rgb;'+
      '  vec3 fragcolor = diffuse0;'+
      '  if (fadeDist1 > 0.0)'+
      '  {'+
      '    fragcolor = mix('+
      '      fragcolor,'+
      '      diffuse1,'+
      '      blend(vPosition.z - minHeight1, fadeDist1)'+
      '    );'+
      '  }'+
      '  if (fadeDist2 > 0.0)'+
      '  {'+
      '    fragcolor = mix('+
      '      fragcolor,'+
      '      diffuse2,'+
      '      blend(vPosition.z - (minHeight1 + minHeight2), fadeDist2)'+
      '    );'+
      '  }'+
      '  vec3 lightDirNorm = normalize(lightDir);'+
      '  float intensity = max(dot(vNormal, lightDirNorm), 0.0);'+
      '  vec3 vLightFactor = ambient + lightDiffuse * intensity;'+
      '  gl_FragColor = vec4(fragcolor.rgb * vLightFactor, 1.0);'+
      '}';
  }
}



---
File: /src/SpawnModel.ts
---

import * as THREE from 'three';
import { getDescendants } from './Globals';
import { Scene } from './Scene';
import { SDFParser } from './SDFParser';

/**
 * Spawn a model into the scene
 * @constructor
 */
export class SpawnModel {

  public active: boolean = false; 
  public sdfParser: SDFParser;
  public scene: Scene;
  public domElement: HTMLElement | Document;
  public obj: THREE.Object3D;
  public callback: any;
  public spawnedShapeMaterial:THREE.MeshPhongMaterial;
  public plane:THREE.Plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
  public ray: THREE.Ray = new THREE.Ray();
  public snapDist: number | undefined = undefined;

  constructor(scene: Scene, domElement: HTMLElement)
  {
    this.scene = scene;
    this.domElement = ( domElement !== undefined ) ? domElement : document;
 
    // Material for simple shapes being spawned (grey transparent)
    this.spawnedShapeMaterial = new THREE.MeshPhongMaterial(
        {color: 0xffffff, flatShading: false} );
    this.spawnedShapeMaterial.transparent = true;
    this.spawnedShapeMaterial.opacity = 0.5;
  }

  /**
   * Start spawning an entity. Only simple shapes supported so far.
   * Adds a temp object to the scene which is not registered on the server.
   * @param {string} entity
   * @param {function} callback
   */
  public start(entity: string, callback: any): void {
    if (this.active) {
      this.finish();
    }
  
    this.callback = callback;

    let that = this;

    function meshLoaded(mesh: THREE.Object3D, spawnedMat?: boolean) {
      if (spawnedMat) {
        (mesh as THREE.Mesh).material = that.spawnedShapeMaterial;
      }
      that.obj.name = that.generateUniqueName(entity);
      that.obj.add(mesh);
    }
  
    this.obj = new THREE.Object3D();
    if (entity === 'box') {
      meshLoaded(this.scene.createBox(1, 1, 1), true);
    }
    else if (entity === 'sphere') {
      meshLoaded(this.scene.createSphere(0.5), true);
    } else if (entity === 'cylinder') {
      meshLoaded(this.scene.createCylinder(0.5, 1.0), true);
    }else if (entity === 'capsule') {
      meshLoaded(this.scene.createCapsule(1, 1), true);
    } else if (entity === 'pointlight') {
      meshLoaded(this.scene.createLight(1), false);
    } else if (entity === 'spotlight') {
      meshLoaded(this.scene.createLight(2), false);
    } else if (entity === 'directionallight') {
      meshLoaded(this.scene.createLight(3), false);
    } else {
      this.sdfParser.loadSDF(entity, meshLoaded);
      //TODO: add transparency to the object
    }
 
    // temp model appears within current view
    var pos = new THREE.Vector2(window.window.innerWidth/2, window.innerHeight/2);
    var intersect = new THREE.Vector3();
    this.scene.getRayCastModel(pos, intersect);
  
    this.obj.position.x = intersect.x;
    this.obj.position.y = intersect.y;
    this.obj.position.z += 0.5;
    this.scene.add(this.obj);
    // For the inserted light to have effect
    var allObjects: THREE.Object3D[] = [];
    getDescendants(this.scene.scene, allObjects);
    for (var l = 0; l < allObjects.length; ++l) {
      if ((allObjects[l] as any).material) {
        (allObjects[l] as any).material.needsUpdate = true;
      }
    }
  
    /*this.mouseDown = function(event) {that.onMouseDown(event);};
    this.mouseUp = function(event) {that.onMouseUp(event);};
    this.mouseMove = function(event) {that.onMouseMove(event);};
    this.keyDown = function(event) {that.onKeyDown(event);};
    this.touchMove = function(event) {that.onTouchMove(event,true);};
    this.touchEnd = function(event) {that.onTouchEnd(event);};
  
    this.domElement.addEventListener('mousedown', that.mouseDown, false);
    this.domElement.addEventListener( 'mouseup', that.mouseUp, false);
    this.domElement.addEventListener( 'mousemove', that.mouseMove, false);
    document.addEventListener( 'keydown', that.keyDown, false);
  
    this.domElement.addEventListener( 'touchmove', that.touchMove, false);
    this.domElement.addEventListener( 'touchend', that.touchEnd, false);
   */
  
    this.active = true;
  }

  /**
   * Finish spawning an entity: re-enable camera controls,
   * remove listeners, remove temp object
   */
  public finish(): void {
    var that = this;
  
    /*this.domElement.removeEventListener( 'mousedown', that.mouseDown, false);
    this.domElement.removeEventListener( 'mouseup', that.mouseUp, false);
    this.domElement.removeEventListener( 'mousemove', that.mouseMove, false);
    document.removeEventListener( 'keydown', that.keyDown, false);
   */
  
    this.scene.remove(this.obj);
    this.active = false;
  }

  /**
   * Window event callback
   * @param {} event - not yet
   */
  /*public onMouseDown(event: MouseEvent): void {
    // Does this ever get called?
    // Change like this:
    // https://bitbucket.org/osrf/gzweb/pull-request/14
    event.preventDefault();
    event.stopImmediatePropagation();
  }*/

  /**
   * Window event callback
   * @param {} event - mousemove events
   */
  /*public onMouseMove(event: MouseEvent): void {
    if (!this.active) {
      return;
    }
  
    event.preventDefault();
  
    this.moveSpawnedModel(event.clientX,event.clientY);
  }*/

  /**
   * Window event callback
   * @param {} event - touchmove events
   */
  /*public onTouchMove(event: TouchEvent, originalEvent: any): void {
    if (!this.active) {
      return;
    }
  
    var e;
  
    if (originalEvent) {
      e = event;
    }
    else {
      e = event.originalEvent;
    }
    e.preventDefault();
  
    if (e.touches.length === 1) {
      this.moveSpawnedModel(e.touches[ 0 ].pageX,e.touches[ 0 ].pageY);
    }
  }*/

  /**
   * Window event callback
   * @param {} event - touchend events
   */
  /*public onTouchEnd = function(): void {
    if (!this.active) {
      return;
    }
  
    this.callback(this.obj);
    this.finish();
  }*/

  /**
   * Window event callback
   * @param {} event - mousedown events
   */
  /*public onMouseUp(event: MouseEvent): void {
    if (!this.active) {
      return;
    }
  
    this.callback(this.obj);
    this.finish();
  }*/

  /**
   * Window event callback
   * @param {} event - keydown events
   */
  /*public onKeyDown(event: KeyEvent): void {
    if ( event.keyCode === 27 ) // Esc
    {
      this.finish();
    }
  }*/

  /**
   * Move temp spawned model
   * @param {integer} positionX - Horizontal position on the canvas
   * @param {integer} positionY - Vertical position on the canvas
   */
  /*public moveSpawnedModel(positionX: number, positionY: number): void {
    var vector = new THREE.Vector3( (positionX / window.innerWidth) * 2 - 1,
          -(positionY / window.innerHeight) * 2 + 1, 0.5);
    vector.unproject(this.scene.camera);
    this.ray.set(this.scene.camera.position,
        vector.sub(this.scene.camera.position).normalize());
    var point = this.ray.intersectPlane(this.plane);
  
    if (!point)
    {
      return;
    }
  
    point.z = this.obj.position.z;
  
    if (this.snapDist) {
      point.x = Math.round(point.x / this.snapDist) * this.snapDist;
      point.y = Math.round(point.y / this.snapDist) * this.snapDist;
    }
  
    this.scene.setPose(this.obj, point, new THREE.Quaternion());
  
    if (this.obj.children[0].children[0] &&
       (this.obj.children[0].children[0] instanceof THREE.SpotLight ||
        this.obj.children[0].children[0] instanceof THREE.DirectionalLight))
    {
      var lightObj = this.obj.children[0].children[0];
      if (lightObj.direction)
      {
        if (lightObj.target)
        {
          lightObj.target.position.copy(lightObj.direction);
        }
      }
    }
  }*/

  /**
   * Generate unique name for spawned entity
   * @param {string} entity - entity type
   */
  public generateUniqueName(entity: string): string {
    let i: number = 0;
    while (i < 1000) {
      if (this.scene.getByName(entity+'_'+i)) {
        ++i;
      } else {
        return entity+'_'+i;
      }
    }
    return entity;
  }
}



---
File: /src/Topic.ts
---

export type TopicCb = (msg: any) => void;

/**
 * Type that represents a topic to be subscribed. This allows communication between Components and
 * the Websocket service of a Simulation.
 */
export class Topic {
  /**
   * The name of the topic, used to identify it.
   */
  name: string;

  /**
   * Callback to use for this current topic.
   */
  cb: TopicCb;

  /**
   * Optional. Function to be called when unsubscribing from the topic.
   */
  unsubscribe?(): any;

  constructor(name: string, cb: TopicCb) {
    this.name = name;
    this.cb = cb;
  }
}



---
File: /src/Transport.ts
---

import { BehaviorSubject, Observable } from 'rxjs';
import { Root, Message, Type, parse } from 'protobufjs';
import { Publisher } from './Publisher';
import { Topic } from './Topic';
import { Asset, AssetCb, AssetError } from './Asset';

/**
 * The Transport class is in charge of managing the websocket connection to a
 * Gazebo websocket server.
 */
export class Transport {

  /**
   * Scene Information behavior subject.
   * Components can subscribe to it to get the scene information once it is obtained.
   */
  public sceneInfo$ = new BehaviorSubject<any>(null);

  /**
   * The Websocket object.
   */
  private ws: WebSocket;

  /**
   * The root namespace should be obtained from the Websocket upon connection.
   */
  private root: Root | null;

  /**
   * List of available topics.
   *
   * Array of objects containing {topic, msg_type}.
   */
  private availableTopics: object[] = [];

  /**
   * Map of the subscribed topics.
   * - Key: The topic name.
   * - Value: The Topic object, which includes the callback.
   *
   * New subscriptions should be added to this map, in order to correctly derive the messages
   * received.
   */
  private topicMap = new Map<string, Topic>();

  /**
   * A map of asset uri to asset types. This allows a caller to request
   * an asset from the websocket server and receive a callback when the
   * aseset has been fetched.
   */
  private assetMap = new Map<string, Asset>();

  /**
   * The world that is being used in the Simulation.
   */
  private world: string = '';

  /**
   * Status connection behavior subject.
   * Internally keeps track of the connection state.
   * Uses a Behavior Subject because it has an initial state and stores a value.
   */
  private status$ = new BehaviorSubject<string>('disconnected');

  /**
   * Connects to a websocket.
   *
   * @param url The url to connect to.
   * @param key Optional. A key to authorize access to the websocket messages.
   */
  public connect(url: string, key?: string): void {
    // First, disconnect from previous connections.
    // This way we make sure that we only support one websocket connection.
    this.disconnect();

    // Create the Websocket interface.
    this.ws = new WebSocket(url);

    // Set the handlers of the websocket events.
    this.ws.onopen = () => this.onOpen(key);
    this.ws.onclose = () => this.onClose();
    this.ws.onmessage = (msgEvent) => this.onMessage(msgEvent);
    this.ws.onerror = (errorEvent) => this.onError(errorEvent);
  }

  /**
   * Disconnects from a websocket.
   * Note: The cleanup should be done in the onclose event of the Websocket.
   */
  public disconnect(): void {
    if (this.ws) {
      this.ws.close();
    }
  }

  /**
   * Advertise a topic.
   *
   * @param topic The topic to advertise.
   * @param msgTypeName The message type the topic will handle.
   * @returns The Publisher instance.
   */
  public advertise(topic: string, msgTypeName: string): Publisher {
    this.sendMessage(['adv', topic, msgTypeName, '']);

    const msgDef = this.root!.lookupType(msgTypeName);

    return new Publisher(
      topic,
      msgTypeName,
      msgDef,
      (topic: string, msgTypeName: string, msg: string) => {
        this.publish(topic, msgTypeName, msg);
      }
    );
  }

  /**
   * Publish to a topic.
   *
   * @param topic The topic to publish to.
   * @param msgTypeName The message type.
   * @param msg The message to publish.
   */
  public publish(topic: string, msgTypeName: string, msg: string): void {
    this.sendMessage(['pub_in', topic, msgTypeName, msg]);
  }

  /**
   * Request a service.
   *
   * @param topic The service to request to.
   * @param msgTypeName The message type.
   * @param msg The message to publish. This should be a JSON representation
   * of the protobuf message.
   */
  public requestService(
    topic: string,
    msgTypeName: string,
    msgProperties: {[key: string]: any;}
  ): void {
    if (!this.root) {
      console.error('Unable to request service - Message definitions are not ready');
      return;
    }

    const msgDef = this.root.lookupType(msgTypeName);
    if (!msgDef || msgDef === undefined) {
      console.error(`Unable to lookup message type: ${msgTypeName}`);
      return;
    }

    const msg: Message = msgDef.create(msgProperties);
    if (!msg || msg === undefined) {
      console.error(`Unable to create ${msgTypeName}, from, ${msgProperties}`);
      return;
    }

    // Serialized the message
    const buffer = msgDef.encode(msg).finish();
    if (!buffer || buffer === undefined || buffer.length === 0) {
      console.error('Unable to serialize message.');
      return;
    }

    const strBuf = new TextDecoder().decode(buffer);

    this.sendMessage(['req', topic, msgTypeName, strBuf]);
  }

  /**
   * Subscribe to a topic.
   *
   * @param topic The topic to subscribe to.
   */
  public subscribe(topic: Topic): void {
    this.topicMap.set(topic.name, topic);

    const publisher = this.availableTopics.filter(pub => pub['topic'] === topic.name)[0];
    if (publisher['msg_type'] === 'ignition.msgs.Image' ||
        publisher['msg_type'] === 'gazebo.msgs.Image') {
      this.sendMessage(['image', topic.name, '', '']);
    }
    else {
      this.sendMessage(['sub', topic.name, '', '']);
    }
  }

  /**
   * Unsubscribe from a topic.
   *
   * @param name The name of the topic to unsubcribe from.
   */
  public unsubscribe(name: string): void {
    if (this.topicMap.has(name)) {
      const topic = this.topicMap.get(name);
      if (topic !== undefined && topic.unsubscribe !== undefined) {
        topic.unsubscribe();
      }

      this.topicMap.delete(name);
      this.sendMessage(['unsub', name, '', '']);
    }
  }

  /**
   * throttle the rate at which messages are published on a topic.
   *
   * @param topic The topic to throttle.
   * @param rate Publish rate.
   */
  public throttle(topic: Topic, rate: number): void {
    this.sendMessage(['throttle', topic.name, 'na', rate.toString()]);
  }

  /**
   * Return the list of available topics.
   *
   * @returns The list of topics that can be subscribed to.
   */
  public getAvailableTopics(): object[] {
    return this.availableTopics;
  }

  /**
   * Return the list of subscribed topics.
   *
   * @returns A map containing the name and message type of topics that we are currently
   *          subscribed to.
   */
  public getSubscribedTopics(): Map<string, Topic> {
    return this.topicMap;
  }

  /**
   * Return the world.
   *
   * @returns The name of the world the websocket is connected to.
   */
  public getWorld(): string {
    return this.world;
  }

  /**
   * Get an asset from Gazebo
   */
  public getAsset(_uri: string, _cb: AssetCb) {
    let asset: Asset = {
      uri: _uri,
      cb: _cb
    };

    console.log(`Getting asset via websocket - ${_uri}`);

    this.assetMap.set(_uri, asset);
    this.sendMessage(['asset', '', '', _uri]);
  }

  /**
   * Send a message through the websocket. It verifies if the message is correct and if the
   * connection status allows it to be sent.
   *
   * @param msg The message to send. It consists of four parts:
   *   1. Operation
   *   2. Topic name
   *   3. Message type
   *   4. Payload
   */
  public sendMessage(msg: string[]): void {
    // Verify the message has four parts.
    if (msg.length !== 4) {
      console.error('Message must have four parts', msg);
      return;
    }

    // Only send the message when the connection allows it.
    // Note: Some messages need to be sent during the connection process.
    const connectionStatus = this.status$.getValue();

    if (connectionStatus === 'error') {
      console.error('Cannot send the message. Connection failed.', { status: connectionStatus, message: msg });
      return;
    }

    // In order to properly establish a connection, we need to send certain messages, such as
    // authentication messages, world name, etc.
    const operation = msg[0];
    if (
      operation === 'auth' ||
      operation === 'protos' ||
      operation === 'topics-types' ||
      operation === 'worlds'
    ) {
      this.ws.send(this.buildMsg(msg));
      return;
    }

    // Other messages should be sent when the connection status is connected or ready.
    if (connectionStatus === 'disconnected') {
      console.error('Trying to send a message but the websocket is disconnected.', msg);
      return;
    }

    this.ws.send(this.buildMsg(msg));
  }

  /**
   * Exposes the connection status as an Observable.
   */
  public getConnectionStatus(): Observable<string> {
    return this.status$.asObservable();
  }

  /**
   * Handler for the open event of a Websocket.
   *
   * @param key Optional. A key to authorize access to the websocket messages.
   */
  private onOpen(key?: string): void {
    // An authorization key could be required to request the message definitions.
    if (key) {
      this.sendMessage(['auth', '', '', key]);
    } else {
      this.sendMessage(['protos', '', '', '']);
    }
  }

  /**
   * Handler for the close event of a Websocket.
   *
   * Cleanup the connections.
   */
  private onClose(): void {
    this.topicMap.clear();
    this.availableTopics = [];
    this.root = null;
    this.status$.next('disconnected');
    this.sceneInfo$.next(null);
  }

  /**
   * Handler for the message event of a Websocket.
   *
   * Parses message responses from Gazebo and sends to the corresponding topic.
   */
  private onMessage(event: MessageEvent): void {
    // If there is no Root, then handle authentication and the message definitions.
    const fileReader = new FileReader();
    if (!this.root) {
      fileReader.onloadend = () => {
        const content = fileReader.result as string;

        // Handle the response.
        switch (content) {
          case 'authorized':
            // Get the message definitions.
            this.sendMessage(['protos', '', '', '']);
            break;
          case 'invalid':
            // TODO(germanmas) Throw a proper Unauthorized error.
            console.error('Invalid key');
            break;
          default:
            // Parse the message definitions.
            this.root = parse(fileReader.result as string, {keepCase: true}).root;

            // Request topics.
            this.sendMessage(['topics-types', '', '', '']);

            // Request world information.
            this.sendMessage(['worlds', '', '', '']);

            // Now we can update the connection status.
            this.status$.next('connected');
            break;
        }
      };

      fileReader.readAsText(event.data);
      return;
    }

    fileReader.onloadend = () => {
      if (!this.root) {
        console.error("Protobuf root has not been created");
        return;
      }

      // Return if at any point, the websocket connection is lost.
      if (this.status$.getValue() === 'disconnected') {
        return;
      }

      // Decode as UTF-8 to get the header.
      const str = new TextDecoder('utf-8').decode(fileReader.result as BufferSource);
      const frameParts = str.split(',');
      const msgType = this.root.lookup(frameParts[2]) as Type;
      const buffer = new Uint8Array(fileReader.result as ArrayBuffer);

      // Decode the Message. The "+3" in the slice accounts for the commas in the frame.
      let msg;
      // get the actual msg payload without the header
      const msgData = buffer.slice(
        frameParts[0].length + frameParts[1].length + frameParts[2].length + 3
      );

      // do not decode image msg as it is raw compressed png data and not a
      // protobuf msg
      if (frameParts[2] === 'ignition.msgs.Image' ||
          frameParts[2] === 'gazebo.msgs.Image') {
        msg = msgData;
      }
      else {
        msg = msgType.decode(msgData);
      }

      // For frame format information see the WebsocketServer documentation at:
      // https://github.com/gazebosim/gz-launch/blob/ign-launch5/plugins/websocket_server/WebsocketServer.hh
      if (frameParts[0] == 'asset') {
        // Error to pass to the callback function, in order for the requester to handle it.
        let error: string | undefined;

        // Check for errors. We can check if the type is a string to avoid comapring with large assets.
        if (frameParts[2] === 'ignition.msgs.StringMsg' || frameParts[2] === 'gazebo.msgs.StringMsg') {
          switch (msg['data']) {
            case AssetError.URI_MISSING:
              console.error('Asset is missing an URI');
              break;
            case AssetError.NOT_FOUND:
              console.error(`Asset not found via websocket - ${frameParts[1]}`);
              // Set the error for the requester to handle.
              error = AssetError.NOT_FOUND;
              break;
            default:
              console.error(`Asset error:`, msg['data']);
              break;
          }

          // There is no error for the requester.
          if (!error) {
            return;
          }
        }

        // Run the callback associated with the asset. This lets the requester
        // process the asset message.
        if (this.assetMap.has(frameParts[1])) {
          this.assetMap.get(frameParts[1])!.cb(msg['data'], error);
        } else {
          console.error(`No resource callback for ${this.assetMap.get(frameParts[1])!.uri}`);
        }
      } else if (frameParts[0] == 'pub') {

        // Handle actions and messages.
        switch (frameParts[1]) {
          case 'topics-types':
            for (const pub of msg['publisher']) {
              this.availableTopics.push(pub);
            }
            break;
          case 'topics':
            this.availableTopics = msg['data'];
            break;
          case 'worlds':
            // The world name needs to be used to get the scene information.
            this.world = msg['data'][0];
            this.sendMessage(['scene', this.world, '', '']);
            break;
          case 'scene':
            // Emit the scene information. Contains all the models used.
            this.sceneInfo$.next(msg);

            // Once we received the Scene Information, we can start working.
            // We emit the Ready status to reflect this.
            this.status$.next('ready');
            break;
          default:
            // Message from a subscribed topic. Get the topic and execute its
            // callback.
            if (this.topicMap.has(frameParts[1])) {
              this?.topicMap?.get(frameParts[1])?.cb(msg);
            }
            break;
        }

      } else if (frameParts[0] == 'req') {
        // We are not handling response messages from service calls.
      } else {
        console.warn('Unhandled websocket message with frame operation', frameParts[0]);
      }
    };

    // Read the blob data as an array buffer.
    fileReader.readAsArrayBuffer(event.data);
    return;
  }

  /**
   * Handler for the error event of a Websocket.
   */
  private onError(event: Event): void {
    this.status$.next('error');
    this.disconnect();
    console.error(event);
  }

  /**
   * Helper function to build a message.
   * The message is a comma-separated string consisting in four parts:
   * 1. Operation
   * 2. Topic name
   * 3. Message type
   * 4. Payload
   */
  private buildMsg(parts: string[]): string {
    return parts.join(',');
  }
}



---
File: /src/WsLoadingManager.ts
---

import { LoadingManager } from "three";

/**
 * The Websocket Loading Manager is a custom Loading Manager that keeps track
 * of items that need to be loaded via the websocket server.
 *
 * Usually, when a loader fails to load an item, it marks it as done. This
 * manager handles that particular case: It doesn't mark the item as done
 * until it comes back from the websocket connection.
 *
 * Loading Managers handle and keep track of loaded and pending items.
 * For more information, see https://threejs.org/docs/#api/en/loaders/managers/LoadingManager
 */
export class WsLoadingManager extends LoadingManager {

  /**
   * Callback used when the first item starts loading.
   */
  public onStart: ((url: string, loaded: number, total: number) => void) | undefined;

  /**
   * LoadingManager method.
   * Called whenever a new item is being loaded by the Loader that has this manager.
   */
  public itemStart: (url: string) => void;

  /**
   * LoadingManager method.
   * Called whenever the Loader finishes loading an item (regardless of error status).
   */
  public itemEnd: (url: string) => void;

  /**
   * LoadingManager method.
   * Called whenever the Loader had an error while loading an item.
   */
  public itemError: (url: string) => void;

  /**
   * Array of URLs that had an error related to the Loader.
   * This manager keeps track of these because we need to try to get them from the websocket server.
   */
  private errorItems: string[] = [];

  /**
   * The number of items loaded. Used to determine progress.
   */
  private itemsLoaded: number = 0;

  /**
   * The total number of items to load. Used to determine progress.
   */
  private itemsTotal: number = 0;

  /**
   * Determine whether items are being loaded or not.
   * Once the loaded items equal the total, we consider the loading to be done.
   */
  private isLoading: boolean = false;

  /**
   * Note: The onLoad, onProgress and onError methods have nothing to do with the Loader that has
   * this manager.
   *
   * @param onLoad Callback when all the items are loaded.
   * @param onProgress Callback when an item is loaded.
   * @param onError Callback when there is an error getting the item from the websocket server. See {@link markAsError}.
   */
  constructor(
    onLoad?: () => void,
    onProgress?: (url: string, loaded: number, total: number) => void,
    onError?: (url: string) => void
  ) {
    super(onLoad, onProgress, onError);

    /**
     * itemStart method is called internally by loaders using this manager, whenever they start
     * getting the resource.
     */
    this.itemStart = (url) => {
      this.itemsTotal++;

      if (!this.isLoading) {
        if (this.onStart !== undefined) {
          this.onStart(url, this.itemsLoaded, this.itemsTotal);
        }
        this.isLoading = true;
      }
    };

    /**
     * itemEnd method is called internally by loaders using this manager, whenever they finish
     * loading the resource they where trying to load.
     *
     * This is called whether the resource had an error or not.
     */
    this.itemEnd = (url) => {
      // This manager keeps track of the items that had errors. We don't want to mark them as done,
      // as they need to be get from the websocket server.
      if (this.errorItems.includes(url)) {
        return;
      }

      // No error - Proceed to end the item.
      this.itemsLoaded++;

      if (onProgress !== undefined) {
        onProgress(url, this.itemsLoaded, this.itemsTotal);
      }

      if (this.itemsLoaded === this.itemsTotal) {
        this.isLoading = false;
        if (onLoad !== undefined) {
          onLoad();
        }
      }
    };

    /**
     * itemError method is called internally by loaders using this manager, whenever the resource
     * they are trying to load fails.
     */
    this.itemError = (url) => {
      // This manager keeps track of the items that had errors. We don't want to mark them as error until we tried
      // getting the resource from the websocket server.
      if (!this.errorItems.includes(url)) {
        this.errorItems.push(url);
        return;
      }

      if (onError !== undefined) {
        onError(url);
      }
    };
  }

  /**
   * Mark an item as Done.
   * This method should be called manually when the websocket connection successfully gets the item.
   *
   * @param url The URL of the resource.
   */
  public markAsDone(url: string): void {
    if (this.errorItems.includes(url)) {
      this.filterAndEnd(url);
    }
  }

  /**
   * Mark an item as Error.
   * This method should be called manually when the websocket connection fails to get the item.
   *
   * @param url The URL of the resource.
   */
  public markAsError(url: string): void {
    if (this.errorItems.includes(url)) {
      this.itemError(url);
      this.filterAndEnd(url);
    }
  }

  /**
   * Internal method that removes an URL from the error items array and ends it.
   *
   * @param url The URL of the resource.
   */
  private filterAndEnd(url: string): void {
    this.errorItems = this.errorItems.filter((errorUrl: string) => errorUrl !== url);
    this.itemEnd(url);
  }
}



---
File: /tests/unit/SceneManger.test.ts
---

import {SceneManager} from '../../src/SceneManager'

// Tests for default construction
describe('scene construction', () => {
  // Create the scene object
  let sceneMgr: SceneManager = new SceneManager();

  test('scene connection status is disconnected', () => {
    expect(sceneMgr.getConnectionStatus()).toBe('disconnected');
  });

  test('model list to be empty', () => {
    expect(sceneMgr.getModels().length).toBe(0);
  });
});




---
File: /tests/unit/Transport.test.ts
---

import {Transport} from '../../src/Transport'

// Tests for default construction
describe('transport construction', () => {
  // Create the transport object
  let transport: Transport = new Transport();

  test('world name is empty', () => {
    expect(transport.getWorld()).toBe('');
  });

  test('available topics are empty', () => {
    expect(transport.getAvailableTopics()).toHaveLength(0);
  });

  test('subscribed topics are empty', () => {
    expect(transport.getSubscribedTopics().size).toBe(0);
  });
});



---
File: /index.js
---

module.exports = require('./dist/gzweb.js');



---
File: /jest.config.ts
---

// Configre jest, which is used for testing.
import type { Config } from "@jest/types"

const config: Config.InitialOptions = {
  preset: "ts-jest",
  testEnvironment: "node",
  transform: {
    "^.+\\.jsx?$": "babel-jest",
  },
};
export default config;



---
File: /README.md
---

# Gzweb

Gzweb is a library that allows web clients to render models and worlds, as well as visualize and communicate with a running [Gazebo](https://gazebosim.org/home) simulation using the Websocket launcher plugin.

# Usage

Gzweb is available on NPM. Web clients can install it using:

```
npm install gzweb
```

Then, you can see The `AssetViewer` class if you want to render static models or worlds, or the `SceneManager` class if you want to render a running Gazebo simulation.

# Development

## Setup

You need the following:
- Node version 18.
- NPM version 8.

You can use [NVM](https://github.com/nvm-sh/nvm) to switch between versions easily. With it, you can then do:

```
nvm install 18
nvm use 18
node -v && npm -v # Your versions will be correct.
```

After this, install dependencies with:

```
npm install
```

## Test

Run the tests using

```
npm run test
```

## Build

Once you have your dependencies installed, you can run:

```
npm run build
```

## Local development

If you are working on changes on `gzweb` and want to try them in an application, then you can setup a `link` using these steps.

1. In the root of the `gzweb` sources run
    ```
    npm link
    ```

2. This should create a symlink to the `gzweb` folder in the global node path, which can be found using `npm root -g`.

3. Connect the downstream application to the `gzweb` symlink using
    ```
    npm link gzweb
    ```

4. In the downstream application's `node_modules` directory you should see a corresponding symlink to `gzweb`.

5. All you have to do now is run `npm run build`.



---
File: /rollup.config.js
---

// rollup.config.js
// import typescript from '@rollup/plugin-typescript';
import { terser } from 'rollup-plugin-terser';
import babel from '@rollup/plugin-babel';
// import { nodeResolve } from '@rollup/plugin-node-resolve';
//import commonjs from '@rollup/plugin-commonjs';

let builds = [
  // Module
  {
    input: 'tsc-out/src/gzweb.js',
    plugins: [ ],
    external: [
      'eventemitter2',
      'jszip',
      'protobufjs',
      'rxjs',
      'three',
      'three-nebula',
      'fast-xml-parser'
    ],
    output: [
      {
        format: 'esm',
        name: 'gzweb',
        file: 'dist/gzweb.module.js',
        globals: {
          eventemitter2: 'eventemitter2',
          protobufjs: 'protobufjs',
          rxjs: 'rxjs',
          three: 'THREE',
          jszip: 'JSZip',
          'fast-xml-parser': 'fast-xml-parser'
        }
      }
    ]
  },

  // UMD unminified
  {
    input: 'tsc-out/src/gzweb.js',
    plugins: [
      /*commonjs(),
      nodeResolve({
        browser: true,
      }),*/
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
        compact: false
      })
    ],
    external: [
      'eventemitter2',
      'jszip',
      'protobufjs',
      'rxjs',
      'three',
      'three-nebula',
      'fast-xml-parser'
    ],
    output: [
      {
        format: 'umd',
        name: 'gzweb',
        file: 'dist/gzweb.js',
        globals: {
          eventemitter2: 'eventemitter2',
          protobufjs: 'protobufjs',
          rxjs: 'rxjs',
          three: 'THREE',
          jszip: 'JSZip',
          'three-nebula': 'three-nebula',
          'fast-xml-parser': 'fast-xml-parser'
        }
      }
    ]
  },

  // UMD minified
  {
    input: 'tsc-out/src/gzweb.js',
    plugins: [
      /*commonjs(),
      nodeResolve({
        browser: true,
      }),*/
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**'
      }),
      terser()
    ],
    external: [
      'eventemitter2',
      'jszip',
      'protobufjs',
      'rxjs',
      'three',
      'three-nebula',
      'fast-xml-parser'
    ],
    output: [
      {
        format: 'umd',
        name: 'gzweb',
        file: 'dist/gzweb.min.js',
        globals: {
          eventemitter2: 'eventemitter2',
          protobufjs: 'protobufjs',
          rxjs: 'rxjs',
          three: 'THREE',
          jszip: 'JSZip',
          'three-nebula': 'three-nebula',
          'fast-xml-parser': 'fast-xml-parser'
        }
      }
    ]
  }
]

export default builds;
//{
//  input: 'tsc-out/src/gzweb.js',
//  external: [
//    'eventemitter2',
//    'protobufjs',
//    'rxjs',
//    'three',
//  ],
//  output: [
//    {
//      file: 'dist/gzweb.js',
//      format: 'umd',
//      name: 'gzweb',
//      sourcemap: 'inline',
//      globals: {
//        eventemitter2: 'eventemitter2',
//        protobufjs: 'protobufjs',
//        rxjs: 'rxjs',
//        three: 'three'
//      }
//    },
//    {
//      file: 'dist/gzweb.min.js',
//      format: 'umd',
//      name: 'gzweb',
//      plugins: [terser()],
//      globals: {
//        eventemitter2: 'eventemitter2',
//        protobufjs: 'protobufjs',
//        rxjs: 'rxjs',
//        three: 'three'
//      }
//    }
//  ],
//
//  plugins: [
//    /*commonjs(),
//    nodeResolve({
//      browser: true,
//    }),*/
//    babel({
//      babelHelpers: 'bundled',
//      exclude: 'node_modules/**'
//    })
//  ]
//};



---
File: /tsconfig.json
---

{
  "compilerOptions": {
    "allowJs": true,
    "target": "es2015",
    "module": "es2015",
    "moduleResolution": "node",
    "forceConsistentCasingInFileNames": true,
    "suppressImplicitAnyIndexErrors": true,
    "strictPropertyInitialization": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir":"./tsc-out",
    "lib": ["dom", "es2015"]
  },
  "include": ["./src/*"]
}

